

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>matplotlib.image &mdash; smpl  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> smpl
          

          
          </a>

          
            
            
              <div class="version">
                1.2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Links:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/APN-Pucky/smpl">GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../example/index.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/smpl.html">smpl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Profiling:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../performance/index.html">Graph Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance/line.html">Line Profiling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://smpl.readthedocs.io/en/stable/">RTD</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/smpl/">Stable</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/smpl/test/">Dev</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">smpl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../matplotlib.html">matplotlib</a> &raquo;</li>
        
      <li>matplotlib.image</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for matplotlib.image</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The image module supports basic image loading, rescaling and display</span>
<span class="sd">operations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">PIL.PngImagePlugin</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">_api</span><span class="p">,</span> <span class="n">cbook</span><span class="p">,</span> <span class="n">cm</span>
<span class="c1"># For clarity, names from _image are given explicitly in this module</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">_image</span>
<span class="c1"># For user convenience, the names from _image are also imported into</span>
<span class="c1"># the image namespace</span>
<span class="kn">from</span> <span class="nn">matplotlib._image</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.artist</span> <span class="k">as</span> <span class="nn">martist</span>
<span class="kn">from</span> <span class="nn">matplotlib.backend_bases</span> <span class="kn">import</span> <span class="n">FigureCanvasBase</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
<span class="kn">from</span> <span class="nn">matplotlib.transforms</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Affine2D</span><span class="p">,</span> <span class="n">BboxBase</span><span class="p">,</span> <span class="n">Bbox</span><span class="p">,</span> <span class="n">BboxTransform</span><span class="p">,</span> <span class="n">BboxTransformTo</span><span class="p">,</span>
    <span class="n">IdentityTransform</span><span class="p">,</span> <span class="n">TransformedBbox</span><span class="p">)</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># map interpolation strings to module constants</span>
<span class="n">_interpd_</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;antialiased&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span>  <span class="c1"># this will use nearest or Hanning...</span>
    <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span>  <span class="c1"># fall back to nearest when not supported</span>
    <span class="s1">&#39;nearest&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span>
    <span class="s1">&#39;bilinear&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
    <span class="s1">&#39;bicubic&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">BICUBIC</span><span class="p">,</span>
    <span class="s1">&#39;spline16&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">SPLINE16</span><span class="p">,</span>
    <span class="s1">&#39;spline36&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">SPLINE36</span><span class="p">,</span>
    <span class="s1">&#39;hanning&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">HANNING</span><span class="p">,</span>
    <span class="s1">&#39;hamming&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">HAMMING</span><span class="p">,</span>
    <span class="s1">&#39;hermite&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">HERMITE</span><span class="p">,</span>
    <span class="s1">&#39;kaiser&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">KAISER</span><span class="p">,</span>
    <span class="s1">&#39;quadric&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">QUADRIC</span><span class="p">,</span>
    <span class="s1">&#39;catrom&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">CATROM</span><span class="p">,</span>
    <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">GAUSSIAN</span><span class="p">,</span>
    <span class="s1">&#39;bessel&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">BESSEL</span><span class="p">,</span>
    <span class="s1">&#39;mitchell&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">MITCHELL</span><span class="p">,</span>
    <span class="s1">&#39;sinc&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">SINC</span><span class="p">,</span>
    <span class="s1">&#39;lanczos&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">LANCZOS</span><span class="p">,</span>
    <span class="s1">&#39;blackman&#39;</span><span class="p">:</span> <span class="n">_image</span><span class="o">.</span><span class="n">BLACKMAN</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">interpolations_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_interpd_</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">composite_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Composite a number of RGBA images into one.  The images are</span>
<span class="sd">    composited in the order in which they appear in the *images* list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    images : list of Images</span>
<span class="sd">        Each must have a `make_image` method.  For each image,</span>
<span class="sd">        `can_composite` should return `True`, though this is not</span>
<span class="sd">        enforced by this function.  Each image must have a purely</span>
<span class="sd">        affine transformation with no shear.</span>

<span class="sd">    renderer : `.RendererBase`</span>

<span class="sd">    magnification : float, default: 1</span>
<span class="sd">        The additional magnification to apply for the renderer in use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : uint8 array (M, N, 4)</span>
<span class="sd">        The composited RGBA image.</span>
<span class="sd">    offset_x, offset_y : float</span>
<span class="sd">        The (left, bottom) offset where the composited image should be placed</span>
<span class="sd">        in the output figure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">make_image</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">*=</span> <span class="n">magnification</span>
            <span class="n">y</span> <span class="o">*=</span> <span class="n">magnification</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">_get_scalar_alpha</span><span class="p">()))</span>
            <span class="n">bboxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Bbox</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

    <span class="n">bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">height</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">bbox</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">bbox</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span>
        <span class="n">_image</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">_image</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span>
                        <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">bbox</span><span class="o">.</span><span class="n">x0</span> <span class="o">/</span> <span class="n">magnification</span><span class="p">,</span> <span class="n">bbox</span><span class="o">.</span><span class="n">y0</span> <span class="o">/</span> <span class="n">magnification</span>


<span class="k">def</span> <span class="nf">_draw_list_compositing_images</span><span class="p">(</span>
        <span class="n">renderer</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">artists</span><span class="p">,</span> <span class="n">suppress_composite</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draw a sorted list of artists, compositing images into a single</span>
<span class="sd">    image where possible.</span>

<span class="sd">    For internal Matplotlib use only: It is here to reduce duplication</span>
<span class="sd">    between `Figure.draw` and `Axes.draw`, but otherwise should not be</span>
<span class="sd">    generally useful.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">has_images</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_ImageBase</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">artists</span><span class="p">)</span>

    <span class="c1"># override the renderer default if suppressComposite is not None</span>
    <span class="n">not_composite</span> <span class="o">=</span> <span class="p">(</span><span class="n">suppress_composite</span> <span class="k">if</span> <span class="n">suppress_composite</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                     <span class="k">else</span> <span class="n">renderer</span><span class="o">.</span><span class="n">option_image_nocomposite</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">not_composite</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">has_images</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">artists</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">renderer</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Composite any adjacent images together</span>
        <span class="n">image_group</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">get_image_magnification</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">flush_images</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">image_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">renderer</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">composite_images</span><span class="p">(</span><span class="n">image_group</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">mag</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
                    <span class="n">gc</span><span class="o">.</span><span class="n">set_clip_rectangle</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>
                    <span class="n">gc</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">())</span>
                    <span class="n">renderer</span><span class="o">.</span><span class="n">draw_image</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
                    <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">image_group</span><span class="p">[:]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">artists</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_ImageBase</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">can_composite</span><span class="p">()</span> <span class="ow">and</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">get_clip_on</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()):</span>
                <span class="n">image_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flush_images</span><span class="p">()</span>
                <span class="n">a</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">renderer</span><span class="p">)</span>
        <span class="n">flush_images</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_resample</span><span class="p">(</span>
        <span class="n">image_obj</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience wrapper around `._image.resample` to resample *data* to</span>
<span class="sd">    *out_shape* (with a third dimension if *data* is RGBA) that takes care of</span>
<span class="sd">    allocating the output array and fetching the relevant properties from the</span>
<span class="sd">    Image object *image_obj*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># AGG can only handle coordinates smaller than 24-bit signed integers,</span>
    <span class="c1"># so raise errors if the input data is larger than _image.resample can</span>
    <span class="c1"># handle.</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Data with more than </span><span class="si">{n}</span><span class="s1"> cannot be accurately displayed. &#39;</span>
           <span class="s1">&#39;Downsampling to less than </span><span class="si">{n}</span><span class="s1"> before displaying. &#39;</span>
           <span class="s1">&#39;To remove this warning, manually downsample your data.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">23</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="s1">&#39;2**23 columns&#39;</span><span class="p">))</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mi">23</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">::</span><span class="n">step</span><span class="p">]</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">transform</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="s1">&#39;2**24 rows&#39;</span><span class="p">))</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[::</span><span class="n">step</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="n">transform</span>
    <span class="c1"># decide if we need to apply anti-aliasing if the data is upsampled:</span>
    <span class="c1"># compare the number of displayed pixels to the number of</span>
    <span class="c1"># the data pixels.</span>
    <span class="n">interpolation</span> <span class="o">=</span> <span class="n">image_obj</span><span class="o">.</span><span class="n">get_interpolation</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;antialiased&#39;</span><span class="p">:</span>
        <span class="c1"># don&#39;t antialias if upsampling by an integer number or</span>
        <span class="c1"># if zooming in more than a factor of 3</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="n">disp</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">dispx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">disp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">dispy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">disp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">dispx</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">dispx</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">dispx</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">dispy</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">dispy</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">dispy</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">interpolation</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interpolation</span> <span class="o">=</span> <span class="s1">&#39;hanning&#39;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">out_shape</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># 2D-&gt;2D, 3D-&gt;3D.</span>
    <span class="k">if</span> <span class="n">resample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">resample</span> <span class="o">=</span> <span class="n">image_obj</span><span class="o">.</span><span class="n">get_resample</span><span class="p">()</span>
    <span class="n">_image</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="n">_interpd_</span><span class="p">[</span><span class="n">interpolation</span><span class="p">],</span>
                    <span class="n">resample</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="p">,</span>
                    <span class="n">image_obj</span><span class="o">.</span><span class="n">get_filternorm</span><span class="p">(),</span>
                    <span class="n">image_obj</span><span class="o">.</span><span class="n">get_filterrad</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_rgb_to_rgba</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an RGB image to RGBA, as required by the image resample C++</span>
<span class="sd">    extension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rgba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">rgba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
    <span class="k">if</span> <span class="n">rgba</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
        <span class="n">rgba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rgba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">rgba</span>


<span class="k">class</span> <span class="nc">_ImageBase</span><span class="p">(</span><span class="n">martist</span><span class="o">.</span><span class="n">Artist</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for images.</span>

<span class="sd">    interpolation and cmap default to their rc settings</span>

<span class="sd">    cmap is a colors.Colormap instance</span>
<span class="sd">    norm is a colors.Normalize instance to map luminance to 0-1</span>

<span class="sd">    extent is data axes (left, right, bottom, top) for making image plots</span>
<span class="sd">    registered with data plots.  Default is to label the pixel</span>
<span class="sd">    centers with the zero-based row and column indices.</span>

<span class="sd">    Additional kwargs are matplotlib.artist properties</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zorder</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filternorm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">filterrad</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
                 <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">interpolation_stage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="n">martist</span><span class="o">.</span><span class="n">Artist</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.origin&#39;</span><span class="p">]</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">],</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_filternorm</span><span class="p">(</span><span class="n">filternorm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_filterrad</span><span class="p">(</span><span class="n">filterrad</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_interpolation</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_interpolation_stage</span><span class="p">(</span><span class="n">interpolation_stage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_resample</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">ax</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(size=</span><span class="si">{</span><span class="n">size</span><span class="si">!r}</span><span class="s2">)&quot;</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Save some space on the pickle by not saving the cache.</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span> <span class="s2">&quot;_imcache&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the size of the image as tuple (numrows, numcols).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must first set the image array&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the alpha value used for blending - not supported on all backends.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float or 2D array-like or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">martist</span><span class="o">.</span><span class="n">Artist</span><span class="o">.</span><span class="n">_set_alpha_for_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;alpha must be a float, two-dimensional &#39;</span>
                            <span class="s1">&#39;array, or None&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_scalar_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a scalar alpha value to be applied to the artist as a whole.</span>

<span class="sd">        If the alpha value is a matrix, the method returns 1.0 because pixels</span>
<span class="sd">        have individual alpha values (see `~._ImageBase._make_image` for</span>
<span class="sd">        details). If the alpha value is a scalar, the method returns said value</span>
<span class="sd">        to be applied to the artist as a whole because pixels do not have</span>
<span class="sd">        individual alpha values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> \
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span>

    <span class="k">def</span> <span class="nf">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call this whenever the mappable is changed so observers can update.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="n">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">in_bbox</span><span class="p">,</span> <span class="n">out_bbox</span><span class="p">,</span> <span class="n">clip_bbox</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">unsampled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_to_pixel_border</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize, rescale, and colormap the image *A* from the given *in_bbox*</span>
<span class="sd">        (in data space), to the given *out_bbox* (in pixel space) clipped to</span>
<span class="sd">        the given *clip_bbox* (also in pixel space), and magnified by the</span>
<span class="sd">        *magnification* factor.</span>

<span class="sd">        *A* may be a greyscale image (M, N) with a dtype of float32, float64,</span>
<span class="sd">        float128, uint16 or uint8, or an (M, N, 4) RGBA image with a dtype of</span>
<span class="sd">        float32, float64, float128, or uint8.</span>

<span class="sd">        If *unsampled* is True, the image will not be scaled, but an</span>
<span class="sd">        appropriate affine transformation will be returned instead.</span>

<span class="sd">        If *round_to_pixel_border* is True, the output image size will be</span>
<span class="sd">        rounded to the nearest pixel boundary.  This makes the images align</span>
<span class="sd">        correctly with the axes.  It should not be used if exact scaling is</span>
<span class="sd">        needed, such as for `FigureImage`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : (M, N, 4) uint8 array</span>
<span class="sd">            The RGBA image, resampled unless *unsampled* is True.</span>
<span class="sd">        x, y : float</span>
<span class="sd">            The upper left corner where the image should be drawn, in pixel</span>
<span class="sd">            space.</span>
<span class="sd">        trans : Affine2D</span>
<span class="sd">            The affine transformation from image to pixel space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must first set the image &#39;</span>
                               <span class="s1">&#39;array or the image attribute&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;_make_image must get a non-empty image. &quot;</span>
                               <span class="s2">&quot;Your Artist&#39;s draw method must filter before &quot;</span>
                               <span class="s2">&quot;this method is called.&quot;</span><span class="p">)</span>

        <span class="n">clipped_bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">out_bbox</span><span class="p">,</span> <span class="n">clip_bbox</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clipped_bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">out_width_base</span> <span class="o">=</span> <span class="n">clipped_bbox</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">magnification</span>
        <span class="n">out_height_base</span> <span class="o">=</span> <span class="n">clipped_bbox</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">magnification</span>

        <span class="k">if</span> <span class="n">out_width_base</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">out_height_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
            <span class="c1"># Flip the input image using a transform.  This avoids the</span>
            <span class="c1"># problem with flipping the array, which results in a copy</span>
            <span class="c1"># when it is converted to contiguous in the C wrapper</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">IdentityTransform</span><span class="p">()</span>

        <span class="n">t0</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">Affine2D</span><span class="p">()</span>
            <span class="o">.</span><span class="n">scale</span><span class="p">(</span>
                <span class="n">in_bbox</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">in_bbox</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">in_bbox</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">in_bbox</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">())</span>

        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span>
             <span class="o">+</span> <span class="p">(</span><span class="n">Affine2D</span><span class="p">()</span>
                <span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">clipped_bbox</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="o">-</span><span class="n">clipped_bbox</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span>
                <span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">magnification</span><span class="p">)))</span>

        <span class="c1"># So that the image is aligned with the edge of the axes, we want to</span>
        <span class="c1"># round up the output width to the next integer.  This also means</span>
        <span class="c1"># scaling the transform slightly to account for the extra subpixel.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="n">round_to_pixel_border</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">out_width_base</span> <span class="o">%</span> <span class="mf">1.0</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">out_height_base</span> <span class="o">%</span> <span class="mf">1.0</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)):</span>
            <span class="n">out_width</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">out_width_base</span><span class="p">)</span>
            <span class="n">out_height</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">out_height_base</span><span class="p">)</span>
            <span class="n">extra_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_width</span> <span class="o">-</span> <span class="n">out_width_base</span><span class="p">)</span> <span class="o">/</span> <span class="n">out_width_base</span>
            <span class="n">extra_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_height</span> <span class="o">-</span> <span class="n">out_height_base</span><span class="p">)</span> <span class="o">/</span> <span class="n">out_height_base</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">extra_width</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">extra_height</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out_width_base</span><span class="p">)</span>
            <span class="n">out_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out_height_base</span><span class="p">)</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_height</span><span class="p">,</span> <span class="n">out_width</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">unsampled</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid shape </span><span class="si">{</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> for image data&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation_stage</span> <span class="o">!=</span> <span class="s1">&#39;rgba&#39;</span><span class="p">:</span>
                <span class="c1"># if we are a 2D array, then we are running through the</span>
                <span class="c1"># norm + colormap transformation.  However, in general the</span>
                <span class="c1"># input data is not going to match the size on the screen so we</span>
                <span class="c1"># have to resample to the correct number of pixels</span>

                <span class="c1"># TODO slice input array first</span>
                <span class="n">a_min</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">a_max</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">a_min</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>  <span class="c1"># All masked; values don&#39;t matter.</span>
                    <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>  <span class="c1"># Float dtype: scale to same dtype.</span>
                    <span class="n">scaled_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">scaled_dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">:</span>
                        <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Casting input data from </span><span class="si">{</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                                           <span class="sa">f</span><span class="s2">&quot; to </span><span class="si">{</span><span class="n">scaled_dtype</span><span class="si">}</span><span class="s2"> for imshow.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Int dtype, likely.</span>
                    <span class="c1"># Scale to appropriately sized float: use float32 if the</span>
                    <span class="c1"># dynamic range is small, to limit the memory footprint.</span>
                    <span class="n">da</span> <span class="o">=</span> <span class="n">a_max</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">a_min</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">scaled_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="k">if</span> <span class="n">da</span> <span class="o">&gt;</span> <span class="mf">1e8</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>

                <span class="c1"># Scale the input data to [.1, .9].  The Agg interpolators clip</span>
                <span class="c1"># to [0, 1] internally, and we use a smaller input scale to</span>
                <span class="c1"># identify the interpolated points that need to be flagged as</span>
                <span class="c1"># over/under.  This may introduce numeric instabilities in very</span>
                <span class="c1"># broadly scaled data.</span>

                <span class="c1"># Always copy, and don&#39;t allow array subtypes.</span>
                <span class="n">A_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">scaled_dtype</span><span class="p">)</span>
                <span class="c1"># Clip scaled data around norm if necessary.  This is necessary</span>
                <span class="c1"># for big numbers at the edge of float64&#39;s ability to represent</span>
                <span class="c1"># changes.  Applying a norm first would be good, but ruins the</span>
                <span class="c1"># interpolation of over numbers.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span><span class="p">)</span>
                <span class="n">vmid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span><span class="p">)</span> <span class="o">+</span> <span class="n">dv</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">fact</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="k">if</span> <span class="n">scaled_dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="k">else</span> <span class="mf">1e4</span>
                <span class="n">newmin</span> <span class="o">=</span> <span class="n">vmid</span> <span class="o">-</span> <span class="n">dv</span> <span class="o">*</span> <span class="n">fact</span>
                <span class="k">if</span> <span class="n">newmin</span> <span class="o">&lt;</span> <span class="n">a_min</span><span class="p">:</span>
                    <span class="n">newmin</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">newmin</span><span class="p">)</span>
                <span class="n">newmax</span> <span class="o">=</span> <span class="n">vmid</span> <span class="o">+</span> <span class="n">dv</span> <span class="o">*</span> <span class="n">fact</span>
                <span class="k">if</span> <span class="n">newmax</span> <span class="o">&gt;</span> <span class="n">a_max</span><span class="p">:</span>
                    <span class="n">newmax</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">newmax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">newmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">A_scaled</span><span class="p">,</span> <span class="n">newmin</span><span class="p">,</span> <span class="n">newmax</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">A_scaled</span><span class="p">)</span>

                <span class="c1"># Rescale the raw data to [offset, 1-offset] so that the</span>
                <span class="c1"># resampling code will run cleanly.  Using dyadic numbers here</span>
                <span class="c1"># could reduce the error, but would not fully eliminate it and</span>
                <span class="c1"># breaks a number of tests (due to the slightly different</span>
                <span class="c1"># error bouncing some pixels across a boundary in the (very</span>
                <span class="c1"># quantized) colormapping step).</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mf">.1</span>
                <span class="n">frac</span> <span class="o">=</span> <span class="mf">.8</span>
                <span class="c1"># Run vmin/vmax through the same rescaling as the raw data;</span>
                <span class="c1"># otherwise, data values close or equal to the boundaries can</span>
                <span class="c1"># end up on the wrong side due to floating point error.</span>
                <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span>
                <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
                    <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span>
                <span class="n">vrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">scaled_dtype</span><span class="p">)</span>

                <span class="n">A_scaled</span> <span class="o">-=</span> <span class="n">a_min</span>
                <span class="n">vrange</span> <span class="o">-=</span> <span class="n">a_min</span>
                <span class="c1"># .item() handles a_min/a_max being ndarray subclasses.</span>
                <span class="n">a_min</span> <span class="o">=</span> <span class="n">a_min</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">scaled_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">a_max</span> <span class="o">=</span> <span class="n">a_max</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">scaled_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">a_min</span> <span class="o">!=</span> <span class="n">a_max</span><span class="p">:</span>
                    <span class="n">A_scaled</span> <span class="o">/=</span> <span class="p">((</span><span class="n">a_max</span> <span class="o">-</span> <span class="n">a_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">frac</span><span class="p">)</span>
                    <span class="n">vrange</span> <span class="o">/=</span> <span class="p">((</span><span class="n">a_max</span> <span class="o">-</span> <span class="n">a_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">frac</span><span class="p">)</span>
                <span class="n">A_scaled</span> <span class="o">+=</span> <span class="n">offset</span>
                <span class="n">vrange</span> <span class="o">+=</span> <span class="n">offset</span>
                <span class="c1"># resample the input data to the correct resolution and shape</span>
                <span class="n">A_resampled</span> <span class="o">=</span> <span class="n">_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A_scaled</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">A_scaled</span>  <span class="c1"># Make sure we don&#39;t use A_scaled anymore!</span>
                <span class="c1"># Un-scale the resampled data to approximately the original</span>
                <span class="c1"># range. Things that interpolated to outside the original range</span>
                <span class="c1"># will still be outside, but possibly clipped in the case of</span>
                <span class="c1"># higher order interpolation + drastically changing data.</span>
                <span class="n">A_resampled</span> <span class="o">-=</span> <span class="n">offset</span>
                <span class="n">vrange</span> <span class="o">-=</span> <span class="n">offset</span>
                <span class="k">if</span> <span class="n">a_min</span> <span class="o">!=</span> <span class="n">a_max</span><span class="p">:</span>
                    <span class="n">A_resampled</span> <span class="o">*=</span> <span class="p">((</span><span class="n">a_max</span> <span class="o">-</span> <span class="n">a_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">frac</span><span class="p">)</span>
                    <span class="n">vrange</span> <span class="o">*=</span> <span class="p">((</span><span class="n">a_max</span> <span class="o">-</span> <span class="n">a_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">frac</span><span class="p">)</span>
                <span class="n">A_resampled</span> <span class="o">+=</span> <span class="n">a_min</span>
                <span class="n">vrange</span> <span class="o">+=</span> <span class="n">a_min</span>
                <span class="c1"># if using NoNorm, cast back to the original datatype</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">):</span>
                    <span class="n">A_resampled</span> <span class="o">=</span> <span class="n">A_resampled</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># nontrivial mask</span>
                        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
                <span class="c1"># we always have to interpolate the mask to account for</span>
                <span class="c1"># non-affine transformations</span>
                <span class="n">out_alpha</span> <span class="o">=</span> <span class="n">_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">mask</span>  <span class="c1"># Make sure we don&#39;t use mask anymore!</span>
                <span class="c1"># Agg updates out_alpha in place.  If the pixel has no image</span>
                <span class="c1"># data it will not be updated (and still be 0 as we initialized</span>
                <span class="c1"># it), if input data that would go into that output pixel than</span>
                <span class="c1"># it will be `nan`, if all the input data for a pixel is good</span>
                <span class="c1"># it will be 1, and if there is _some_ good data in that output</span>
                <span class="c1"># pixel it will be between [0, 1] (such as a rotated image).</span>
                <span class="n">out_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out_alpha</span><span class="p">)</span>
                <span class="n">out_alpha</span><span class="p">[</span><span class="n">out_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># Apply the pixel-by-pixel alpha values if present</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out_alpha</span> <span class="o">*=</span> <span class="n">_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span>
                                           <span class="n">t</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># mask and run through the norm</span>
                <span class="n">resampled_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">A_resampled</span><span class="p">,</span> <span class="n">out_mask</span><span class="p">)</span>
                <span class="c1"># we have re-set the vmin/vmax to account for small errors</span>
                <span class="c1"># that may have moved input values in/out of range</span>
                <span class="n">s_vmin</span><span class="p">,</span> <span class="n">s_vmax</span> <span class="o">=</span> <span class="n">vrange</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s_vmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t give 0 or negative values to LogNorm</span>
                    <span class="n">s_vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">scaled_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
                <span class="c1"># Block the norm from sending an update signal during the</span>
                <span class="c1"># temporary vmin/vmax change</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">blocked</span><span class="p">(),</span> \
                     <span class="n">cbook</span><span class="o">.</span><span class="n">_setattr_cm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">s_vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">s_vmax</span><span class="p">):</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">resampled_masked</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># _interpolation_stage == &#39;rgba&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">_rgb_to_rgba</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scalar_alpha</span><span class="p">()</span>
                <span class="n">output_alpha</span> <span class="o">=</span> <span class="n">_resample</span><span class="p">(</span>  <span class="c1"># resample alpha channel</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">_resample</span><span class="p">(</span>  <span class="c1"># resample rgb channels</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">_rgb_to_rgba</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]),</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_alpha</span>  <span class="c1"># recombine rgb and alpha</span>

            <span class="c1"># output is now either a 2D array of normed (int or float) data</span>
            <span class="c1"># or an RGBA array of re-sampled input</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># output is now a correctly sized RGBA array of uint8</span>

            <span class="c1"># Apply alpha *after* if the input was greyscale without a mask</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scalar_alpha</span><span class="p">()</span>
                <span class="n">alpha_channel</span> <span class="o">=</span> <span class="n">output</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">alpha_channel</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># Assignment will cast to uint8.</span>
                    <span class="n">alpha_channel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_alpha</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span>

            <span class="c1"># Subset the input image to only the part that will be displayed.</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">TransformedBbox</span><span class="p">(</span><span class="n">clip_bbox</span><span class="p">,</span> <span class="n">t0</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">ymax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">+</span> <span class="n">t</span>

        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">clipped_bbox</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">clipped_bbox</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">make_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize, rescale, and colormap this image&#39;s data for rendering using</span>
<span class="sd">        *renderer*, with the given *magnification*.</span>

<span class="sd">        If *unsampled* is True, the image will not be scaled, but an</span>
<span class="sd">        appropriate affine transformation will be returned instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : (M, N, 4) uint8 array</span>
<span class="sd">            The RGBA image, resampled unless *unsampled* is True.</span>
<span class="sd">        x, y : float</span>
<span class="sd">            The upper left corner where the image should be drawn, in pixel</span>
<span class="sd">            space.</span>
<span class="sd">        trans : Affine2D</span>
<span class="sd">            The affine transformation from image to pixel space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;The make_image method must be overridden&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_unsampled_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the image is better to be drawn unsampled.</span>

<span class="sd">        The derived class needs to override it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@martist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># if not visible, declare victory and return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="c1"># for empty images, there is nothing to draw!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="c1"># actually render the image.</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_gc_clip</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_scalar_alpha</span><span class="p">())</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_url</span><span class="p">())</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_gid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gid</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">renderer</span><span class="o">.</span><span class="n">option_scale_image</span><span class="p">()</span>  <span class="c1"># Renderer supports transform kwarg.</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_unsampled_image</span><span class="p">()</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span><span class="o">.</span><span class="n">is_affine</span><span class="p">):</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_image</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">trans</span>
                <span class="n">renderer</span><span class="o">.</span><span class="n">draw_image</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_image</span><span class="p">(</span>
                <span class="n">renderer</span><span class="p">,</span> <span class="n">renderer</span><span class="o">.</span><span class="n">get_image_magnification</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">renderer</span><span class="o">.</span><span class="n">draw_image</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouseevent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether the mouse event occurred within the image.&quot;&quot;&quot;</span>
        <span class="n">inside</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_contains</span><span class="p">(</span><span class="n">mouseevent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inside</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inside</span><span class="p">,</span> <span class="n">info</span>
        <span class="c1"># 1) This doesn&#39;t work for figimage; but figimage also needs a fix</span>
        <span class="c1">#    below (as the check cannot use x/ydata and extents).</span>
        <span class="c1"># 2) As long as the check below uses x/ydata, we need to test axes</span>
        <span class="c1">#    identity instead of `self.axes.contains(event)` because even if</span>
        <span class="c1">#    axes overlap, x/ydata is only valid for event.inaxes anyways.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mouseevent</span><span class="o">.</span><span class="n">inaxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">{}</span>
        <span class="c1"># TODO: make sure this is consistent with patch and patch</span>
        <span class="c1"># collection on nonlinear transformed coordinates.</span>
        <span class="c1"># TODO: consider returning image coordinates (shouldn&#39;t</span>
        <span class="c1"># be too difficult given that the image is rectilinear</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">mouseevent</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mouseevent</span><span class="o">.</span><span class="n">y</span><span class="p">])</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extent</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">xmin</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmin</span>
        <span class="k">if</span> <span class="n">ymin</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">ymin</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ymin</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">inside</span><span class="p">,</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">write_png</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the image to png file *fname*.&quot;&quot;&quot;</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span>
                          <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">im</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the image array.</span>

<span class="sd">        Note that this function does *not* update the normalization used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : array-like or `PIL.Image.Image`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">pil_to_array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># Needed e.g. to apply png palette.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;same_kind&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Image data of dtype </span><span class="si">{}</span><span class="s2"> cannot be converted to &quot;</span>
                            <span class="s2">&quot;float&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If just one dimension assume scalar and apply colormap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid shape </span><span class="si">{}</span><span class="s2"> for image data&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># If the input data has values outside the valid range (after</span>
            <span class="c1"># normalisation), we issue a warning and then clip X to the bounds</span>
            <span class="c1"># - otherwise casting wraps extreme values, hiding outliers and</span>
            <span class="c1"># making reliable interpretation impossible.</span>
            <span class="n">high</span> <span class="o">=</span> <span class="mi">255</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">high</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;Clipping input data to the valid range for imshow with &#39;</span>
                    <span class="s1">&#39;RGB data ([0..1] for floats or [0..255] for integers).&#39;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
            <span class="c1"># Cast unsupported integer types to uint8</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retained for backwards compatibility - use set_data instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : array-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This also needs to be here to override the inherited</span>
        <span class="c1"># cm.ScalarMappable.set_array method so it is not invoked by mistake.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the interpolation method the image uses when resizing.</span>

<span class="sd">        One of &#39;antialiased&#39;, &#39;nearest&#39;, &#39;bilinear&#39;, &#39;bicubic&#39;, &#39;spline16&#39;,</span>
<span class="sd">        &#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;, &#39;kaiser&#39;, &#39;quadric&#39;,</span>
<span class="sd">        &#39;catrom&#39;, &#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;, &#39;sinc&#39;, &#39;lanczos&#39;,</span>
<span class="sd">        or &#39;none&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation</span>

    <span class="k">def</span> <span class="nf">set_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the interpolation method the image uses when resizing.</span>

<span class="sd">        If None, use :rc:`image.interpolation`. If &#39;none&#39;, the image is</span>
<span class="sd">        shown as is without interpolating. &#39;none&#39; is only supported in</span>
<span class="sd">        agg, ps and pdf backends and will fall back to &#39;nearest&#39; mode</span>
<span class="sd">        for other backends.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : {&#39;antialiased&#39;, &#39;nearest&#39;, &#39;bilinear&#39;, &#39;bicubic&#39;, &#39;spline16&#39;, \</span>
<span class="sd">&#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;, &#39;kaiser&#39;, &#39;quadric&#39;, &#39;catrom&#39;, \</span>
<span class="sd">&#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;, &#39;sinc&#39;, &#39;lanczos&#39;, &#39;none&#39;} or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.interpolation&#39;</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">(</span><span class="n">_interpd_</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">set_interpolation_stage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set when interpolation happens during the transform to RGBA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : {&#39;data&#39;, &#39;rgba&#39;} or None</span>
<span class="sd">            Whether to apply up/downsampling interpolation in data or rgba</span>
<span class="sd">            space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>  <span class="c1"># placeholder for maybe having rcParam</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;rgba&#39;</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation_stage</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">can_composite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the image can be composited with its neighbors.&quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span> <span class="ow">and</span>
            <span class="n">trans</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span>
            <span class="n">trans</span><span class="o">.</span><span class="n">is_separable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set whether image resampling is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : bool or None</span>
<span class="sd">            If None, use :rc:`image.resample`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.resample&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resample</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether image resampling is used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resample</span>

    <span class="k">def</span> <span class="nf">set_filternorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filternorm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set whether the resize filter normalizes the weights.</span>

<span class="sd">        See help for `~.Axes.imshow`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filternorm : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filternorm</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">filternorm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_filternorm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the resize filter normalizes the weights.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filternorm</span>

    <span class="k">def</span> <span class="nf">set_filterrad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filterrad</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the resize filter radius only applicable to some</span>
<span class="sd">        interpolation schemes -- see help for imshow</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filterrad : positive float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">filterrad</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The filter radius must be a positive number&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filterrad</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_filterrad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the filterrad setting.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filterrad</span>


<span class="k">class</span> <span class="nc">AxesImage</span><span class="p">(</span><span class="n">_ImageBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An image attached to an Axes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ax : `~.axes.Axes`</span>
<span class="sd">        The axes the image will belong to.</span>
<span class="sd">    cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`</span>
<span class="sd">        The Colormap instance or registered colormap name used to map scalar</span>
<span class="sd">        data to colors.</span>
<span class="sd">    norm : str or `~matplotlib.colors.Normalize`</span>
<span class="sd">        Maps luminance to 0-1.</span>
<span class="sd">    interpolation : str, default: :rc:`image.interpolation`</span>
<span class="sd">        Supported values are &#39;none&#39;, &#39;antialiased&#39;, &#39;nearest&#39;, &#39;bilinear&#39;,</span>
<span class="sd">        &#39;bicubic&#39;, &#39;spline16&#39;, &#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;,</span>
<span class="sd">        &#39;kaiser&#39;, &#39;quadric&#39;, &#39;catrom&#39;, &#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;,</span>
<span class="sd">        &#39;sinc&#39;, &#39;lanczos&#39;, &#39;blackman&#39;.</span>
<span class="sd">    interpolation_stage : {&#39;data&#39;, &#39;rgba&#39;}, default: &#39;data&#39;</span>
<span class="sd">        If &#39;data&#39;, interpolation</span>
<span class="sd">        is carried out on the data provided by the user.  If &#39;rgba&#39;, the</span>
<span class="sd">        interpolation is carried out after the colormapping has been</span>
<span class="sd">        applied (visual interpolation).</span>
<span class="sd">    origin : {&#39;upper&#39;, &#39;lower&#39;}, default: :rc:`image.origin`</span>
<span class="sd">        Place the [0, 0] index of the array in the upper left or lower left</span>
<span class="sd">        corner of the axes. The convention &#39;upper&#39; is typically used for</span>
<span class="sd">        matrices and images.</span>
<span class="sd">    extent : tuple, optional</span>
<span class="sd">        The data axes (left, right, bottom, top) for making image plots</span>
<span class="sd">        registered with data plots.  Default is to label the pixel</span>
<span class="sd">        centers with the zero-based row and column indices.</span>
<span class="sd">    filternorm : bool, default: True</span>
<span class="sd">        A parameter for the antigrain image resize filter</span>
<span class="sd">        (see the antigrain documentation).</span>
<span class="sd">        If filternorm is set, the filter normalizes integer values and corrects</span>
<span class="sd">        the rounding errors. It doesn&#39;t do anything with the source floating</span>
<span class="sd">        point values, it corrects only integers according to the rule of 1.0</span>
<span class="sd">        which means that any sum of pixel weights must be equal to 1.0. So,</span>
<span class="sd">        the filter function must produce a graph of the proper shape.</span>
<span class="sd">    filterrad : float &gt; 0, default: 4</span>
<span class="sd">        The filter radius for filters that have a radius parameter, i.e. when</span>
<span class="sd">        interpolation is one of: &#39;sinc&#39;, &#39;lanczos&#39; or &#39;blackman&#39;.</span>
<span class="sd">    resample : bool, default: False</span>
<span class="sd">        When True, use a full resampling method. When False, only resample when</span>
<span class="sd">        the output image is larger than the input image.</span>
<span class="sd">    **kwargs : `.Artist` properties</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@_api</span><span class="o">.</span><span class="n">make_keyword_only</span><span class="p">(</span><span class="s2">&quot;3.6&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cmap&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filternorm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">filterrad</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
                 <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">interpolation_stage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="o">=</span> <span class="n">extent</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ax</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">filternorm</span><span class="o">=</span><span class="n">filternorm</span><span class="p">,</span>
            <span class="n">filterrad</span><span class="o">=</span><span class="n">filterrad</span><span class="p">,</span>
            <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
            <span class="n">interpolation_stage</span><span class="o">=</span><span class="n">interpolation_stage</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_window_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">from_extents</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">bbox</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="c1"># image is created in the canvas coordinate.</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extent</span><span class="p">()</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">],</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]]))</span>
        <span class="n">transformed_bbox</span> <span class="o">=</span> <span class="n">TransformedBbox</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="n">clip</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_clip_box</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_clip_on</span><span class="p">()</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">transformed_bbox</span><span class="p">,</span> <span class="n">clip</span><span class="p">,</span>
                                <span class="n">magnification</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="n">unsampled</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_unsampled_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the image would be better drawn unsampled.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interpolation</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span>

    <span class="k">def</span> <span class="nf">set_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the image extent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extent : 4-tuple of float</span>
<span class="sd">            The position and size of the image as tuple</span>
<span class="sd">            ``(left, right, bottom, top)`` in data coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This updates ``ax.dataLim``, and, if autoscaling, sets ``ax.viewLim``</span>
<span class="sd">        to tightly fit the image, regardless of ``dataLim``.  Autoscaling</span>
<span class="sd">        state is not changed, so following this with ``ax.autoscale_view()``</span>
<span class="sd">        will redo the autoscaling in accord with ``dataLim``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_autoscalex_on</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">),</span> <span class="n">auto</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_autoscaley_on</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="n">auto</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the image extent as tuple (left, right, bottom, top).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
            <span class="n">numrows</span><span class="p">,</span> <span class="n">numcols</span> <span class="o">=</span> <span class="n">sz</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">numcols</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">numrows</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">numcols</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">numrows</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cursor_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the image value at the event position or *None* if the event is</span>
<span class="sd">        outside the image.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        matplotlib.artist.Artist.get_cursor_data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extent</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">ymin</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">data_extent</span> <span class="o">=</span> <span class="n">Bbox</span><span class="p">([[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">],</span> <span class="p">[</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">]])</span>
        <span class="n">array_extent</span> <span class="o">=</span> <span class="n">Bbox</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="n">trans</span> <span class="o">+=</span> <span class="n">BboxTransform</span><span class="p">(</span><span class="n">boxin</span><span class="o">=</span><span class="n">data_extent</span><span class="p">,</span> <span class="n">boxout</span><span class="o">=</span><span class="n">array_extent</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">event</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">y</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">point</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Clip the coordinates at array bounds</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>


<div class="viewcode-block" id="NonUniformImage"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage">[docs]</a><span class="k">class</span> <span class="nc">NonUniformImage</span><span class="p">(</span><span class="n">AxesImage</span><span class="p">):</span>
    <span class="n">mouseover</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># This class still needs its own get_cursor_data impl.</span>

<div class="viewcode-block" id="NonUniformImage.__init__"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interpolation : {&#39;nearest&#39;, &#39;bilinear&#39;}, default: &#39;nearest&#39;</span>

<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are identical to those of `.AxesImage`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_interpolation</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_unsampled_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return False. Do not use unsampled image.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="NonUniformImage.make_image"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.make_image">[docs]</a>    <span class="k">def</span> <span class="nf">make_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must first set the image array&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unsampled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unsampled not supported on NonUniformImage&#39;</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">4</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">B</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">B</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
        <span class="n">vl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">viewLim</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(((</span><span class="nb">round</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">*</span> <span class="n">magnification</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(((</span><span class="nb">round</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">*</span> <span class="n">magnification</span><span class="p">)</span>
        <span class="n">x_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">vl</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">vl</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">y_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">vl</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">vl</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">x_mid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">y_mid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">x_int</span> <span class="o">=</span> <span class="n">x_mid</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_pix</span><span class="p">)</span>
            <span class="n">y_int</span> <span class="o">=</span> <span class="n">y_mid</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">y_pix</span><span class="p">)</span>
            <span class="c1"># The following is equal to `A[y_int[:, None], x_int[None, :]]`,</span>
            <span class="c1"># but many times faster.  Both casting to uint32 (to have an</span>
            <span class="c1"># effectively 1D array) and manual index flattening matter.</span>
            <span class="n">im</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">y_int</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_int</span><span class="p">)]</span>
                <span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># self._interpolation == &quot;bilinear&quot;</span>
            <span class="c1"># Use np.interp to compute x_int/x_float has similar speed.</span>
            <span class="n">x_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_pix</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">y_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">y_pix</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">idx_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">y_int</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_int</span><span class="p">)</span>
            <span class="n">x_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x_pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">[</span><span class="n">x_int</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">)[</span><span class="n">x_int</span><span class="p">],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>  <span class="c1"># Downcasting helps with speed.</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">y_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">y_pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">[</span><span class="n">y_int</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">)[</span><span class="n">y_int</span><span class="p">],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">f00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_frac</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x_frac</span><span class="p">)</span>
            <span class="n">f10</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">y_frac</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x_frac</span><span class="p">)</span>
            <span class="n">f01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_frac</span><span class="p">,</span> <span class="n">x_frac</span><span class="p">)</span>
            <span class="n">f11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">y_frac</span><span class="p">,</span> <span class="n">x_frac</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">ac</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">chan</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># reshape(-1) avoids a copy.</span>
                <span class="c1"># Shifting the buffer start (`ac[offset:]`) avoids an array</span>
                <span class="c1"># addition (`ac[idx_int + offset]`).</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">f00</span> <span class="o">*</span> <span class="n">ac</span><span class="p">[</span><span class="n">idx_int</span><span class="p">]</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="n">f10</span> <span class="o">*</span> <span class="n">ac</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:][</span><span class="n">idx_int</span><span class="p">]</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="n">f01</span> <span class="o">*</span> <span class="n">ac</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">idx_int</span><span class="p">]</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="n">f11</span> <span class="o">*</span> <span class="n">ac</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:][</span><span class="n">idx_int</span><span class="p">]</span>
                <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span>  <span class="c1"># Implicitly casts to uint8.</span>
        <span class="k">return</span> <span class="n">im</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">()</span></div>

<div class="viewcode-block" id="NonUniformImage.set_data"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.set_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the grid for the pixel centers, and the pixel values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : 1D array-like</span>
<span class="sd">            Monotonic arrays of shapes (N,) and (M,), respectively, specifying</span>
<span class="sd">            pixel centers.</span>
<span class="sd">        A : array-like</span>
<span class="sd">            (M, N) ndarray or masked array of values to be colormapped, or</span>
<span class="sd">            (M, N, 3) RGB array, or (M, N, 4) RGBA array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Axes don&#39;t match array shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only plot 2D or 3D data&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;3D arrays must have three (RGB) &quot;</span>
                            <span class="s2">&quot;or four (RGBA) color components&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="NonUniformImage.set_array"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.set_array">[docs]</a>    <span class="k">def</span> <span class="nf">set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Method not supported&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="NonUniformImage.set_interpolation"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.set_interpolation">[docs]</a>    <span class="k">def</span> <span class="nf">set_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : {&#39;nearest&#39;, &#39;bilinear&#39;} or None</span>
<span class="sd">            If None, use :rc:`image.interpolation`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;bilinear&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only nearest neighbor and &#39;</span>
                                      <span class="s1">&#39;bilinear interpolations are supported&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_interpolation</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<div class="viewcode-block" id="NonUniformImage.get_extent"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.get_extent">[docs]</a>    <span class="k">def</span> <span class="nf">get_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Must set data first&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="NonUniformImage.set_filternorm"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.set_filternorm">[docs]</a>    <span class="k">def</span> <span class="nf">set_filternorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="NonUniformImage.set_filterrad"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.set_filterrad">[docs]</a>    <span class="k">def</span> <span class="nf">set_filterrad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="NonUniformImage.set_norm"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.set_norm">[docs]</a>    <span class="k">def</span> <span class="nf">set_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot change colors after loading data&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span></div>

<div class="viewcode-block" id="NonUniformImage.set_cmap"><a class="viewcode-back" href="../../_autosummary/smpl.plot2d.NonUniformImage.html#smpl.plot2d.NonUniformImage.set_cmap">[docs]</a>    <span class="k">def</span> <span class="nf">set_cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot change colors after loading data&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">PcolorImage</span><span class="p">(</span><span class="n">AxesImage</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a pcolor-style plot with an irregular rectangular grid.</span>

<span class="sd">    This uses a variation of the original irregular image code,</span>
<span class="sd">    and it is used by pcolorfast for the corresponding grid type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@_api</span><span class="o">.</span><span class="n">make_keyword_only</span><span class="p">(</span><span class="s2">&quot;3.6&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cmap&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span>
                 <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : `~.axes.Axes`</span>
<span class="sd">            The axes the image will belong to.</span>
<span class="sd">        x, y : 1D array-like, optional</span>
<span class="sd">            Monotonic arrays of length N+1 and M+1, respectively, specifying</span>
<span class="sd">            rectangle boundaries.  If not given, will default to</span>
<span class="sd">            ``range(N + 1)`` and ``range(M + 1)``, respectively.</span>
<span class="sd">        A : array-like</span>
<span class="sd">            The data to be color-coded. The interpretation depends on the</span>
<span class="sd">            shape:</span>

<span class="sd">            - (M, N) ndarray or masked array: values to be colormapped</span>
<span class="sd">            - (M, N, 3): RGB array</span>
<span class="sd">            - (M, N, 4): RGBA array</span>

<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`</span>
<span class="sd">            The Colormap instance or registered colormap name used to map</span>
<span class="sd">            scalar data to colors.</span>
<span class="sd">        norm : str or `~matplotlib.colors.Normalize`</span>
<span class="sd">            Maps luminance to 0-1.</span>
<span class="sd">        **kwargs : `.Artist` properties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must first set the image array&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unsampled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unsampled not supported on PColorImage&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span>
        <span class="n">padded_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">padded_A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bg</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">padded_A</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">padded_A</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bg</span>

        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">magnification</span><span class="p">))</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">magnification</span><span class="p">))</span>
        <span class="n">vl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">viewLim</span>

        <span class="n">x_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">vl</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">vl</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">y_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">vl</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">vl</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">x_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_pix</span><span class="p">)</span>
        <span class="n">y_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">y_pix</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># See comment in NonUniformImage.make_image re: performance.</span>
            <span class="n">padded_A</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">y_int</span> <span class="o">*</span> <span class="n">padded_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_int</span><span class="p">)]</span>
            <span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">im</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_check_unsampled_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the grid for the rectangle boundaries, and the data values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : 1D array-like, optional</span>
<span class="sd">            Monotonic arrays of length N+1 and M+1, respectively, specifying</span>
<span class="sd">            rectangle boundaries.  If not given, will default to</span>
<span class="sd">            ``range(N + 1)`` and ``range(M + 1)``, respectively.</span>
<span class="sd">        A : array-like</span>
<span class="sd">            The data to be color-coded. The interpretation depends on the</span>
<span class="sd">            shape:</span>

<span class="sd">            - (M, N) ndarray or masked array: values to be colormapped</span>
<span class="sd">            - (M, N, 3): RGB array</span>
<span class="sd">            - (M, N, 4): RGBA array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Axes don&#39;t match array shape. Got </span><span class="si">%s</span><span class="s2">, expected </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A must be 2D or 3D&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;3D arrays must have RGB or RGBA as last dim&quot;</span><span class="p">)</span>

        <span class="c1"># For efficient cursor readout, ensure x and y are increasing.</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_imcache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Method not supported&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cursor_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ax</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ay</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">FigureImage</span><span class="p">(</span><span class="n">_ImageBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An image attached to a figure.&quot;&quot;&quot;</span>

    <span class="n">zorder</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">_interpolation</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span>

    <span class="nd">@_api</span><span class="o">.</span><span class="n">make_keyword_only</span><span class="p">(</span><span class="s2">&quot;3.6&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cmap&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">offsetx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">offsety</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        cmap is a colors.Colormap instance</span>
<span class="sd">        norm is a colors.Normalize instance to map luminance to 0-1</span>

<span class="sd">        kwargs are an optional list of Artist keyword args</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">figure</span> <span class="o">=</span> <span class="n">fig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ox</span> <span class="o">=</span> <span class="n">offsetx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oy</span> <span class="o">=</span> <span class="n">offsety</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnification</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="nf">get_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the image extent as tuple (left, right, bottom, top).&quot;&quot;&quot;</span>
        <span class="n">numrows</span><span class="p">,</span> <span class="n">numcols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ox</span><span class="p">,</span> <span class="n">numcols</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ox</span><span class="p">,</span>
                <span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">oy</span><span class="p">,</span> <span class="n">numrows</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">oy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">dpi</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span>
        <span class="c1"># fac here is to account for pdf, eps, svg backends where</span>
        <span class="c1"># figure.dpi is set to 72.  This means we need to scale the</span>
        <span class="c1"># image (using magnification) and offset it appropriately.</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">ox</span><span class="o">/</span><span class="n">fac</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">oy</span><span class="o">/</span><span class="n">fac</span><span class="p">],</span>
                     <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">ox</span><span class="o">/</span><span class="n">fac</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oy</span><span class="o">/</span><span class="n">fac</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]])</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">get_size_inches</span><span class="p">()</span>
        <span class="n">width</span> <span class="o">*=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">dpi</span>
        <span class="n">height</span> <span class="o">*=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">dpi</span>
        <span class="n">clip</span> <span class="o">=</span> <span class="n">Bbox</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">]])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_image</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">clip</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="n">magnification</span> <span class="o">/</span> <span class="n">fac</span><span class="p">,</span>
            <span class="n">unsampled</span><span class="o">=</span><span class="n">unsampled</span><span class="p">,</span> <span class="n">round_to_pixel_border</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the image array.&quot;&quot;&quot;</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">BboxImage</span><span class="p">(</span><span class="n">_ImageBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The Image class whose size is determined by the given bbox.&quot;&quot;&quot;</span>

    <span class="nd">@_api</span><span class="o">.</span><span class="n">make_keyword_only</span><span class="p">(</span><span class="s2">&quot;3.6&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cmap&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filternorm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">filterrad</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
                 <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        cmap is a colors.Colormap instance</span>
<span class="sd">        norm is a colors.Normalize instance to map luminance to 0-1</span>

<span class="sd">        kwargs are an optional list of Artist keyword args</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">filternorm</span><span class="o">=</span><span class="n">filternorm</span><span class="p">,</span>
            <span class="n">filterrad</span><span class="o">=</span><span class="n">filterrad</span><span class="p">,</span>
            <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span>

    <span class="k">def</span> <span class="nf">get_window_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">renderer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">renderer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span><span class="o">.</span><span class="n">_get_renderer</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbox</span><span class="p">,</span> <span class="n">BboxBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbox</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox</span><span class="p">(</span><span class="n">renderer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown type of bbox&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouseevent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether the mouse event occurred within the image.&quot;&quot;&quot;</span>
        <span class="n">inside</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_contains</span><span class="p">(</span><span class="n">mouseevent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inside</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inside</span><span class="p">,</span> <span class="n">info</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>  <span class="c1"># or self.get_figure()._renderer is None:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">{}</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mouseevent</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mouseevent</span><span class="o">.</span><span class="n">y</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inside</span><span class="p">,</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">make_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">get_canvas_width_height</span><span class="p">()</span>
        <span class="n">bbox_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">(</span><span class="n">renderer</span><span class="p">)</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span>
        <span class="n">bbox_in</span><span class="o">.</span><span class="n">_points</span> <span class="o">/=</span> <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">]</span>
        <span class="n">bbox_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">(</span><span class="n">renderer</span><span class="p">)</span>
        <span class="n">clip</span> <span class="o">=</span> <span class="n">Bbox</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">BboxTransformTo</span><span class="p">(</span><span class="n">clip</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_image</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span>
            <span class="n">bbox_in</span><span class="p">,</span> <span class="n">bbox_out</span><span class="p">,</span> <span class="n">clip</span><span class="p">,</span> <span class="n">magnification</span><span class="p">,</span> <span class="n">unsampled</span><span class="o">=</span><span class="n">unsampled</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">imread</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read an image from a file into an array.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function exists for historical reasons.  It is recommended to</span>
<span class="sd">        use `PIL.Image.open` instead for loading images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str or file-like</span>
<span class="sd">        The image file to read: a filename, a URL or a file-like object opened</span>
<span class="sd">        in read-binary mode.</span>

<span class="sd">        Passing a URL is deprecated.  Please open the URL</span>
<span class="sd">        for reading and pass the result to Pillow, e.g. with</span>
<span class="sd">        ``np.array(PIL.Image.open(urllib.request.urlopen(url)))``.</span>
<span class="sd">    format : str, optional</span>
<span class="sd">        The image file format assumed for reading the data.  The image is</span>
<span class="sd">        loaded as a PNG file if *format* is set to &quot;png&quot;, if *fname* is a path</span>
<span class="sd">        or opened file with a &quot;.png&quot; extension, or if it is an URL.  In all</span>
<span class="sd">        other cases, *format* is ignored and the format is auto-detected by</span>
<span class="sd">        `PIL.Image.open`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.array`</span>
<span class="sd">        The image data. The returned array has shape</span>

<span class="sd">        - (M, N) for grayscale images.</span>
<span class="sd">        - (M, N, 3) for RGB images.</span>
<span class="sd">        - (M, N, 4) for RGBA images.</span>

<span class="sd">        PNG images are returned as float arrays (0-1).  All other formats are</span>
<span class="sd">        returned as int arrays, with a bit depth determined by the file&#39;s</span>
<span class="sd">        contents.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># hide imports to speed initial import on systems with slow linkers</span>
    <span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">parse</span>

    <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">parsed</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">urlparse</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="c1"># If the string is a URL (Windows paths appear as if they have a</span>
            <span class="c1"># length-1 scheme), assume png.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">scheme</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;png&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;geturl&#39;</span><span class="p">):</span>  <span class="c1"># Returned by urlopen().</span>
            <span class="c1"># We could try to parse the url&#39;s path and use the extension, but</span>
            <span class="c1"># returning png is consistent with the block above.  Note that this</span>
            <span class="c1"># if clause has to come before checking for fname.name as</span>
            <span class="c1"># urlopen(&quot;file:///...&quot;) also has a name attribute (with the fixed</span>
            <span class="c1"># value &quot;&lt;urllib response&gt;&quot;).</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;png&#39;</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fname</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;png&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="nb">format</span>
    <span class="n">img_open</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">PIL</span><span class="o">.</span><span class="n">PngImagePlugin</span><span class="o">.</span><span class="n">PngImageFile</span> <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;png&#39;</span> <span class="k">else</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">parse</span><span class="o">.</span><span class="n">urlparse</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">scheme</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Pillow doesn&#39;t handle URLs directly.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Please open the URL for reading and pass the &quot;</span>
            <span class="s2">&quot;result to Pillow, e.g. with &quot;</span>
            <span class="s2">&quot;``np.array(PIL.Image.open(urllib.request.urlopen(url)))``.&quot;</span>
            <span class="p">)</span>
    <span class="k">with</span> <span class="n">img_open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">image</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_pil_png_to_float_array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">PIL</span><span class="o">.</span><span class="n">PngImagePlugin</span><span class="o">.</span><span class="n">PngImageFile</span><span class="p">)</span> <span class="k">else</span>
                <span class="n">pil_to_array</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">imsave</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pil_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Colormap and save an array as an image file.</span>

<span class="sd">    RGB(A) images are passed through.  Single channel images will be</span>
<span class="sd">    colormapped according to *cmap* and *norm*.</span>

<span class="sd">    .. note ::</span>

<span class="sd">       If you want to save a single channel image as gray scale please use an</span>
<span class="sd">       image I/O library (such as pillow, tifffile, or imageio) directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str or path-like or file-like</span>
<span class="sd">        A path or a file-like object to store the image in.</span>
<span class="sd">        If *format* is not set, then the output format is inferred from the</span>
<span class="sd">        extension of *fname*, if any, and from :rc:`savefig.format` otherwise.</span>
<span class="sd">        If *format* is set, it determines the output format.</span>
<span class="sd">    arr : array-like</span>
<span class="sd">        The image data. The shape can be one of</span>
<span class="sd">        MxN (luminance), MxNx3 (RGB) or MxNx4 (RGBA).</span>
<span class="sd">    vmin, vmax : float, optional</span>
<span class="sd">        *vmin* and *vmax* set the color scaling for the image by fixing the</span>
<span class="sd">        values that map to the colormap color limits. If either *vmin*</span>
<span class="sd">        or *vmax* is None, that limit is determined from the *arr*</span>
<span class="sd">        min/max value.</span>
<span class="sd">    cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`</span>
<span class="sd">        A Colormap instance or registered colormap name. The colormap</span>
<span class="sd">        maps scalar data to colors. It is ignored for RGB(A) data.</span>
<span class="sd">    format : str, optional</span>
<span class="sd">        The file format, e.g. &#39;png&#39;, &#39;pdf&#39;, &#39;svg&#39;, ...  The behavior when this</span>
<span class="sd">        is unset is documented under *fname*.</span>
<span class="sd">    origin : {&#39;upper&#39;, &#39;lower&#39;}, default: :rc:`image.origin`</span>
<span class="sd">        Indicates whether the ``(0, 0)`` index of the array is in the upper</span>
<span class="sd">        left or lower left corner of the axes.</span>
<span class="sd">    dpi : float</span>
<span class="sd">        The DPI to store in the metadata of the file.  This does not affect the</span>
<span class="sd">        resolution of the output image.  Depending on file format, this may be</span>
<span class="sd">        rounded to the nearest integer.</span>
<span class="sd">    metadata : dict, optional</span>
<span class="sd">        Metadata in the image file.  The supported keys depend on the output</span>
<span class="sd">        format, see the documentation of the respective backends for more</span>
<span class="sd">        information.</span>
<span class="sd">    pil_kwargs : dict, optional</span>
<span class="sd">        Keyword arguments passed to `PIL.Image.Image.save`.  If the &#39;pnginfo&#39;</span>
<span class="sd">        key is present, it completely overrides *metadata*, including the</span>
<span class="sd">        default &#39;Software&#39; key.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">matplotlib.figure</span> <span class="kn">import</span> <span class="n">Figure</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">):</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fspath</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                  <span class="k">else</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;savefig.format&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pdf&quot;</span><span class="p">,</span> <span class="s2">&quot;ps&quot;</span><span class="p">,</span> <span class="s2">&quot;eps&quot;</span><span class="p">,</span> <span class="s2">&quot;svg&quot;</span><span class="p">]:</span>
        <span class="c1"># Vector formats that are not handled by PIL.</span>
        <span class="k">if</span> <span class="n">pil_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot use &#39;pil_kwargs&#39; when saving to </span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">Figure</span><span class="p">(</span><span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">figimage</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                     <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Don&#39;t bother creating an image; this avoids rounding errors on the</span>
        <span class="c1"># size when dividing and then multiplying by dpi.</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;image.origin&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span>
                <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
            <span class="c1"># Such an ``arr`` would also be handled fine by sm.to_rgba below</span>
            <span class="c1"># (after casting with asarray), but it is useful to special-case it</span>
            <span class="c1"># because that&#39;s what backend_agg passes, and can be in fact used</span>
            <span class="c1"># as is, saving a few operations.</span>
            <span class="n">rgba</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">sm</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
            <span class="n">rgba</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pil_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pil_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pil_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rgba</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rgba</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span>
            <span class="s2">&quot;RGBA&quot;</span><span class="p">,</span> <span class="n">pil_shape</span><span class="p">,</span> <span class="n">rgba</span><span class="p">,</span> <span class="s2">&quot;raw&quot;</span><span class="p">,</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;png&quot;</span><span class="p">:</span>
            <span class="c1"># Only use the metadata kwarg if pnginfo is not set, because the</span>
            <span class="c1"># semantics of duplicate keys in pnginfo is unclear.</span>
            <span class="k">if</span> <span class="s2">&quot;pnginfo&quot;</span> <span class="ow">in</span> <span class="n">pil_kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">metadata</span><span class="p">:</span>
                    <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span><span class="s2">&quot;&#39;metadata&#39; is overridden by the &quot;</span>
                                       <span class="s2">&quot;&#39;pnginfo&#39; entry in &#39;pil_kwargs&#39;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;Software&quot;</span><span class="p">:</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matplotlib version</span><span class="si">{</span><span class="n">mpl</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;https://matplotlib.org/&quot;</span><span class="p">),</span>
                    <span class="o">**</span><span class="p">(</span><span class="n">metadata</span> <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}),</span>
                <span class="p">}</span>
                <span class="n">pil_kwargs</span><span class="p">[</span><span class="s2">&quot;pnginfo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnginfo</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">PngImagePlugin</span><span class="o">.</span><span class="n">PngInfo</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">metadata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pnginfo</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;jpg&quot;</span><span class="p">,</span> <span class="s2">&quot;jpeg&quot;</span><span class="p">]:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;jpeg&quot;</span>  <span class="c1"># Pillow doesn&#39;t recognize &quot;jpg&quot;.</span>
            <span class="n">facecolor</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;savefig.facecolor&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_str_equal</span><span class="p">(</span><span class="n">facecolor</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">):</span>
                <span class="n">facecolor</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.facecolor&quot;</span><span class="p">]</span>
            <span class="n">color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">facecolor</span><span class="p">))</span>
            <span class="n">background</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;RGB&quot;</span><span class="p">,</span> <span class="n">pil_shape</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">background</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">background</span>
        <span class="n">pil_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
        <span class="n">pil_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;dpi&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">dpi</span><span class="p">))</span>
        <span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">pil_kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pil_to_array</span><span class="p">(</span><span class="n">pilImage</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a `PIL image`_ and return it as a numpy int array.</span>

<span class="sd">    .. _PIL image: https://pillow.readthedocs.io/en/latest/reference/Image.html</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array</span>

<span class="sd">        The array shape depends on the image type:</span>

<span class="sd">        - (M, N) for grayscale images.</span>
<span class="sd">        - (M, N, 3) for RGB images.</span>
<span class="sd">        - (M, N, 4) for RGBA images.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pilImage</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="s1">&#39;RGBX&#39;</span><span class="p">,</span> <span class="s1">&#39;RGB&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">]:</span>
        <span class="c1"># return MxNx4 RGBA, MxNx3 RBA, or MxN luminance array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pilImage</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pilImage</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;I;16&#39;</span><span class="p">):</span>
        <span class="c1"># return MxN luminance array of uint16</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">pilImage</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;raw&#39;</span><span class="p">,</span> <span class="n">pilImage</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pilImage</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="s1">&#39;&gt;u2&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="s1">&#39;&lt;u2&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pilImage</span><span class="o">.</span><span class="n">size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;=u2&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># try to convert to an rgba image</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pilImage</span> <span class="o">=</span> <span class="n">pilImage</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown image mode&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pilImage</span><span class="p">)</span>  <span class="c1"># return MxNx4 RGBA array</span>


<span class="k">def</span> <span class="nf">_pil_png_to_float_array</span><span class="p">(</span><span class="n">pil_png</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a PIL `PNGImageFile` to a 0-1 float array.&quot;&quot;&quot;</span>
    <span class="c1"># Unlike pil_to_array this converts to 0-1 float32s for backcompat with the</span>
    <span class="c1"># old libpng-based loader.</span>
    <span class="c1"># The supported rawmodes are from PIL.PngImagePlugin._MODES.  When</span>
    <span class="c1"># mode == &quot;RGB(A)&quot;, the 16-bit raw data has already been coarsened to 8-bit</span>
    <span class="c1"># by Pillow.</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">pil_png</span><span class="o">.</span><span class="n">mode</span>
    <span class="n">rawmode</span> <span class="o">=</span> <span class="n">pil_png</span><span class="o">.</span><span class="n">png</span><span class="o">.</span><span class="n">im_rawmode</span>
    <span class="k">if</span> <span class="n">rawmode</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>  <span class="c1"># Grayscale.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pil_png</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rawmode</span> <span class="o">==</span> <span class="s2">&quot;L;2&quot;</span><span class="p">:</span>  <span class="c1"># Grayscale.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rawmode</span> <span class="o">==</span> <span class="s2">&quot;L;4&quot;</span><span class="p">:</span>  <span class="c1"># Grayscale.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rawmode</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>  <span class="c1"># Grayscale.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rawmode</span> <span class="o">==</span> <span class="s2">&quot;I;16B&quot;</span><span class="p">:</span>  <span class="c1"># Grayscale.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;RGB&quot;</span><span class="p">:</span>  <span class="c1"># RGB.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span><span class="p">:</span>  <span class="c1"># Palette.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;RGBA&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;LA&quot;</span><span class="p">:</span>  <span class="c1"># Grayscale + alpha.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;RGBA&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">:</span>  <span class="c1"># RGBA.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pil_png</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown PIL rawmode: </span><span class="si">{</span><span class="n">rawmode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">thumbnail</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">thumbfile</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span>
              <span class="n">preview</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a thumbnail of image in *infile* with output filename *thumbfile*.</span>

<span class="sd">    See :doc:`/gallery/misc/image_thumbnail_sgskip`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    infile : str or file-like</span>
<span class="sd">        The image file. Matplotlib relies on Pillow_ for image reading, and</span>
<span class="sd">        thus supports a wide range of file formats, including PNG, JPG, TIFF</span>
<span class="sd">        and others.</span>

<span class="sd">        .. _Pillow: https://python-pillow.org/</span>

<span class="sd">    thumbfile : str or file-like</span>
<span class="sd">        The thumbnail filename.</span>

<span class="sd">    scale : float, default: 0.1</span>
<span class="sd">        The scale factor for the thumbnail.</span>

<span class="sd">    interpolation : str, default: &#39;bilinear&#39;</span>
<span class="sd">        The interpolation scheme used in the resampling. See the</span>
<span class="sd">        *interpolation* parameter of `~.Axes.imshow` for possible values.</span>

<span class="sd">    preview : bool, default: False</span>
<span class="sd">        If True, the default backend (presumably a user interface</span>
<span class="sd">        backend) will be used which will cause a figure to be raised if</span>
<span class="sd">        `~matplotlib.pyplot.show` is called.  If it is False, the figure is</span>
<span class="sd">        created using `.FigureCanvasBase` and the drawing backend is selected</span>
<span class="sd">        as `.Figure.savefig` would normally do.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `.Figure`</span>
<span class="sd">        The figure instance containing the thumbnail.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">im</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># This doesn&#39;t really matter (it cancels in the end) but the API needs it.</span>
    <span class="n">dpi</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="n">height</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">/</span> <span class="n">dpi</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">/</span> <span class="n">dpi</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="k">if</span> <span class="n">preview</span><span class="p">:</span>
        <span class="c1"># Let the UI backend do everything.</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">matplotlib.figure</span> <span class="kn">import</span> <span class="n">Figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">FigureCanvasBase</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                      <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">thumbfile</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Alexander Puck Neuwirth.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>