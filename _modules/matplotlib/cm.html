

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>matplotlib.cm &mdash; smpl  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> smpl
          

          
          </a>

          
            
            
              <div class="version">
                1.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Links:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/APN-Pucky/smpl">GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../example/index.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/smpl.html">smpl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Profiling:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../performance/index.html">Graph Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance/line.html">Line Profiling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://smpl.readthedocs.io/en/stable/">RTD</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/smpl/">Stable</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/smpl/test/">Dev</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">smpl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../matplotlib.html">matplotlib</a> &raquo;</li>
        
      <li>matplotlib.cm</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for matplotlib.cm</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Builtin colormaps, colormap handling utilities, and the `ScalarMappable` mixin.</span>

<span class="sd">.. seealso::</span>

<span class="sd">  :doc:`/gallery/color/colormap_reference` for a list of builtin colormaps.</span>

<span class="sd">  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to</span>
<span class="sd">  make colormaps.</span>

<span class="sd">  :doc:`/tutorials/colors/colormaps` an in-depth discussion of</span>
<span class="sd">  choosing colormaps.</span>

<span class="sd">  :doc:`/tutorials/colors/colormapnorms` for more details about data</span>
<span class="sd">  normalization.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">_api</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cbook</span><span class="p">,</span> <span class="n">scale</span>
<span class="kn">from</span> <span class="nn">matplotlib._cm</span> <span class="kn">import</span> <span class="n">datad</span>
<span class="kn">from</span> <span class="nn">matplotlib._cm_listed</span> <span class="kn">import</span> <span class="n">cmaps</span> <span class="k">as</span> <span class="n">cmaps_listed</span>


<span class="nd">@_api</span><span class="o">.</span><span class="n">caching_module_getattr</span>  <span class="c1"># module-level deprecations</span>
<span class="k">class</span> <span class="nc">__getattr__</span><span class="p">:</span>
    <span class="n">LUTSIZE</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">obj_type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;rcParams[&#39;image.lut&#39;]&quot;</span><span class="p">)(</span>
            <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">_LUTSIZE</span><span class="p">))</span>


<span class="n">_LUTSIZE</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.lut&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_gen_cmap_registry</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a dict mapping standard colormap names to standard colormaps, as</span>
<span class="sd">    well as the reversed colormaps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cmap_d</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">cmaps_listed</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">datad</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">cmap_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># Precache the cmaps at a fixed lutsize..</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">_LUTSIZE</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;red&#39;</span> <span class="ow">in</span> <span class="n">spec</span> <span class="k">else</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="s1">&#39;listed&#39;</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;listed&#39;</span> <span class="ow">in</span> <span class="n">spec</span> <span class="k">else</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">_LUTSIZE</span><span class="p">))</span>
    <span class="c1"># Generate reversed cmaps.</span>
    <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">cmap_d</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">reversed</span><span class="p">()</span>
        <span class="n">cmap_d</span><span class="p">[</span><span class="n">rmap</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmap</span>
    <span class="k">return</span> <span class="n">cmap_d</span>


<span class="k">class</span> <span class="nc">ColormapRegistry</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for colormaps that are known to Matplotlib by name.</span>

<span class="sd">    The universal registry instance is `matplotlib.colormaps`. There should be</span>
<span class="sd">    no need for users to instantiate `.ColormapRegistry` themselves.</span>

<span class="sd">    Read access uses a dict-like interface mapping names to `.Colormap`\s::</span>

<span class="sd">        import matplotlib as mpl</span>
<span class="sd">        cmap = mpl.colormaps[&#39;viridis&#39;]</span>

<span class="sd">    Returned `.Colormap`\s are copies, so that their modification does not</span>
<span class="sd">    change the global definition of the colormap.</span>

<span class="sd">    Additional colormaps can be added via `.ColormapRegistry.register`::</span>

<span class="sd">        mpl.colormaps.register(my_colormap)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmaps</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span> <span class="o">=</span> <span class="n">cmaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_builtin_cmaps</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cmaps</span><span class="p">)</span>
        <span class="c1"># A shim to allow register_cmap() to force an override</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allow_override_builtin</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">!r}</span><span class="s2"> is not a known colormap name&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;ColormapRegistry; available colormaps:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the registered colormap names.</span>

<span class="sd">        This exists only for backward-compatibility in `.pyplot` which had a</span>
<span class="sd">        ``plt.colormaps()`` method. The recommended way to get this list is</span>
<span class="sd">        now ``list(colormaps)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a new colormap.</span>

<span class="sd">        The colormap name can then be used as a string argument to any ``cmap``</span>
<span class="sd">        parameter in Matplotlib. It is also available in ``pyplot.get_cmap``.</span>

<span class="sd">        The colormap registry stores a copy of the given colormap, so that</span>
<span class="sd">        future changes to the original colormap instance do not affect the</span>
<span class="sd">        registered colormap. Think of this as the registry taking a snapshot</span>
<span class="sd">        of the colormap at registration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : matplotlib.colors.Colormap</span>
<span class="sd">            The colormap to register.</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            The name for the colormap. If not given, ``cmap.name`` is used.</span>

<span class="sd">        force : bool, default: False</span>
<span class="sd">            If False, a ValueError is raised if trying to overwrite an already</span>
<span class="sd">            registered name. True supports overwriting registered colormaps</span>
<span class="sd">            other than the builtin colormaps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_isinstance</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">Colormap</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">cmap</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
                <span class="c1"># don&#39;t allow registering an already existing cmap</span>
                <span class="c1"># unless explicitly asked to</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;A colormap named &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; is already registered.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builtin_cmaps</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_override_builtin</span><span class="p">):</span>
                <span class="c1"># We don&#39;t allow overriding a builtin unless privately</span>
                <span class="c1"># coming from register_cmap()</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Re-registering the builtin cmap &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is not allowed.&quot;</span><span class="p">)</span>

            <span class="c1"># Warn that we are updating an already existing colormap</span>
            <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overwriting the cmap </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                               <span class="s2">&quot;that was already in the registry.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">unregister</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a colormap from the registry.</span>

<span class="sd">        You cannot remove built-in colormaps.</span>

<span class="sd">        If the named colormap is not registered, returns with no error, raises</span>
<span class="sd">        if you try to de-register a default colormap.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            Colormap names are currently a shared namespace that may be used</span>
<span class="sd">            by multiple packages. Use `unregister` only if you know you</span>
<span class="sd">            have registered that name before. In particular, do not</span>
<span class="sd">            unregister just in case to clean the name before registering a</span>
<span class="sd">            new colormap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the colormap to be removed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If you try to remove a default built-in colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builtin_cmaps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot unregister </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> which is a builtin &quot;</span>
                             <span class="s2">&quot;colormap.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a color map specified through *cmap*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : str or `~matplotlib.colors.Colormap` or None</span>

<span class="sd">            - if a `.Colormap`, return it</span>
<span class="sd">            - if a string, look it up in ``mpl.colormaps``</span>
<span class="sd">            - if None, return the Colormap defined in :rc:`image.cmap`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Colormap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the default color map</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;image.cmap&quot;</span><span class="p">]]</span>

        <span class="c1"># if the user passed in a Colormap, simply return it</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">Colormap</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cmap</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">_colormaps</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
            <span class="c1"># otherwise, it must be a string so look it up</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">cmap</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;get_cmap expects None or an instance of a str or Colormap . &#39;</span> <span class="o">+</span>
            <span class="sa">f</span><span class="s1">&#39;you passed </span><span class="si">{</span><span class="n">cmap</span><span class="si">!r}</span><span class="s1"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>


<span class="c1"># public access to the colormaps should be via `matplotlib.colormaps`. For now,</span>
<span class="c1"># we still create the registry here, but that should stay an implementation</span>
<span class="c1"># detail.</span>
<span class="n">_colormaps</span> <span class="o">=</span> <span class="n">ColormapRegistry</span><span class="p">(</span><span class="n">_gen_cmap_registry</span><span class="p">())</span>
<span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_colormaps</span><span class="p">)</span>


<div class="viewcode-block" id="register_cmap"><a class="viewcode-back" href="../../_autosummary/smpl.plot.register_cmap.html#smpl.plot.register_cmap">[docs]</a><span class="nd">@_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
    <span class="s1">&#39;3.6&#39;</span><span class="p">,</span>
    <span class="n">pending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;``matplotlib.colormaps.register(name)``&quot;</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">register_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">override_builtin</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a colormap to the set recognized by :func:`get_cmap`.</span>

<span class="sd">    Register a new colormap to be accessed by name ::</span>

<span class="sd">        LinearSegmentedColormap(&#39;swirly&#39;, data, lut)</span>
<span class="sd">        register_cmap(cmap=swirly_cmap)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">       The name that can be used in :func:`get_cmap` or :rc:`image.cmap`</span>

<span class="sd">       If absent, the name will be the :attr:`~matplotlib.colors.Colormap.name`</span>
<span class="sd">       attribute of the *cmap*.</span>

<span class="sd">    cmap : matplotlib.colors.Colormap</span>
<span class="sd">       Despite being the second argument and having a default value, this</span>
<span class="sd">       is a required argument.</span>

<span class="sd">    override_builtin : bool</span>

<span class="sd">        Allow built-in colormaps to be overridden by a user-supplied</span>
<span class="sd">        colormap.</span>

<span class="sd">        Please do not use this unless you are sure you need it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_api</span><span class="o">.</span><span class="n">check_isinstance</span><span class="p">((</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must include a name or a &quot;</span>
                             <span class="s2">&quot;Colormap&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="c1"># override_builtin is allowed here for backward compatibility</span>
    <span class="c1"># this is just a shim to enable that to work privately in</span>
    <span class="c1"># the global ColormapRegistry</span>
    <span class="n">_colormaps</span><span class="o">.</span><span class="n">_allow_override_builtin</span> <span class="o">=</span> <span class="n">override_builtin</span>
    <span class="n">_colormaps</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">override_builtin</span><span class="p">)</span>
    <span class="n">_colormaps</span><span class="o">.</span><span class="n">_allow_override_builtin</span> <span class="o">=</span> <span class="kc">False</span></div>


<span class="k">def</span> <span class="nf">_get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lut</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a colormap instance, defaulting to rc values if *name* is None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : `matplotlib.colors.Colormap` or str or None, default: None</span>
<span class="sd">        If a `.Colormap` instance, it will be returned. Otherwise, the name of</span>
<span class="sd">        a colormap known to Matplotlib, which will be resampled by *lut*. The</span>
<span class="sd">        default, None, means :rc:`image.cmap`.</span>
<span class="sd">    lut : int or None, default: None</span>
<span class="sd">        If *name* is not already a Colormap instance and *lut* is not None, the</span>
<span class="sd">        colormap will be resampled to have *lut* entries in the lookup table.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Colormap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.cmap&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">Colormap</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">_colormaps</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_colormaps</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_colormaps</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">lut</span><span class="p">)</span>

<span class="c1"># do it in two steps like this so we can have an un-deprecated version in</span>
<span class="c1"># pyplot.</span>
<span class="n">get_cmap</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
    <span class="s1">&#39;3.6&#39;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;get_cmap&#39;</span><span class="p">,</span>
    <span class="n">pending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">alternative</span><span class="o">=</span><span class="p">(</span>
        <span class="s2">&quot;``matplotlib.colormaps[name]`` &quot;</span> <span class="o">+</span>
        <span class="s2">&quot;or ``matplotlib.colormaps.get_cmap(obj)``&quot;</span>
    <span class="p">)</span>
<span class="p">)(</span><span class="n">_get_cmap</span><span class="p">)</span>


<span class="nd">@_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
    <span class="s1">&#39;3.6&#39;</span><span class="p">,</span>
    <span class="n">pending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;``matplotlib.colormaps.unregister(name)``&quot;</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">unregister_cmap</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove a colormap recognized by :func:`get_cmap`.</span>

<span class="sd">    You may not remove built-in colormaps.</span>

<span class="sd">    If the named colormap is not registered, returns with no error, raises</span>
<span class="sd">    if you try to de-register a default colormap.</span>

<span class="sd">    .. warning::</span>

<span class="sd">      Colormap names are currently a shared namespace that may be used</span>
<span class="sd">      by multiple packages. Use `unregister_cmap` only if you know you</span>
<span class="sd">      have registered that name before. In particular, do not</span>
<span class="sd">      unregister just in case to clean the name before registering a</span>
<span class="sd">      new colormap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the colormap to be un-registered</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ColorMap or None</span>
<span class="sd">        If the colormap was registered, return it if not return `None`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">       If you try to de-register a default built-in colormap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">_colormaps</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">_colormaps</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cmap</span>


<span class="k">def</span> <span class="nf">_auto_norm_from_scale</span><span class="p">(</span><span class="n">scale_cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Automatically generate a norm class from *scale_cls*.</span>

<span class="sd">    This differs from `.colors.make_norm_from_scale` in the following points:</span>

<span class="sd">    - This function is not a class decorator, but directly returns a norm class</span>
<span class="sd">      (as if decorating `.Normalize`).</span>
<span class="sd">    - The scale is automatically constructed with ``nonpositive=&quot;mask&quot;``, if it</span>
<span class="sd">      supports such a parameter, to work around the difference in defaults</span>
<span class="sd">      between standard scales (which use &quot;clip&quot;) and norms (which use &quot;mask&quot;).</span>

<span class="sd">    Note that ``make_norm_from_scale`` caches the generated norm classes</span>
<span class="sd">    (not the instances) and reuses them for later calls.  For example,</span>
<span class="sd">    ``type(_auto_norm_from_scale(&quot;log&quot;)) == LogNorm``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Actually try to construct an instance, to verify whether</span>
    <span class="c1"># ``nonpositive=&quot;mask&quot;`` is supported.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">make_norm_from_scale</span><span class="p">(</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">scale_cls</span><span class="p">,</span> <span class="n">nonpositive</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">))(</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">)()</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">make_norm_from_scale</span><span class="p">(</span><span class="n">scale_cls</span><span class="p">)(</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">)()</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ScalarMappable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mixin class to map scalar data to RGBA.</span>

<span class="sd">    The ScalarMappable applies data normalization before returning RGBA colors</span>
<span class="sd">    from the given colormap.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : `.Normalize` (or subclass thereof) or str or None</span>
<span class="sd">            The normalizing object which scales data, typically into the</span>
<span class="sd">            interval ``[0, 1]``.</span>
<span class="sd">            If a `str`, a `.Normalize` subclass is dynamically generated based</span>
<span class="sd">            on the scale with the corresponding name.</span>
<span class="sd">            If *None*, *norm* defaults to a *colors.Normalize* object which</span>
<span class="sd">            initializes its scaling based on the first data processed.</span>
<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`</span>
<span class="sd">            The colormap used to map normalized data values to RGBA colors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># So that the setter knows we&#39;re initializing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>  <span class="c1"># The Normalize instance of this ScalarMappable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># So that the setter knows we&#39;re initializing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>  <span class="c1"># The Colormap instance of this ScalarMappable.</span>
        <span class="c1">#: The last colorbar associated with this ScalarMappable. May be None.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorbar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">CallbackRegistry</span><span class="p">(</span><span class="n">signals</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;changed&quot;</span><span class="p">])</span>

    <span class="n">callbacksSM</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;callbacks&quot;</span><span class="p">)(</span>
        <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_scale_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper for initial scaling.</span>

<span class="sd">        Used by public functions that create a ScalarMappable and support</span>
<span class="sd">        parameters *vmin*, *vmax* and *norm*. This makes sure that a *norm*</span>
<span class="sd">        will take precedence over *vmin*, *vmax*.</span>

<span class="sd">        Note that this method does not set the norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Passing a Normalize instance simultaneously with &quot;</span>
                    <span class="s2">&quot;vmin/vmax is not supported.  Please pass vmin/vmax &quot;</span>
                    <span class="s2">&quot;directly to the norm when creating it.&quot;</span><span class="p">)</span>

        <span class="c1"># always resolve the autoscaling so we have concrete limits</span>
        <span class="c1"># rather than deferring to draw time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a normalized rgba array corresponding to *x*.</span>

<span class="sd">        In the normal case, *x* is a 1D or 2D sequence of scalars, and</span>
<span class="sd">        the corresponding ndarray of rgba values will be returned,</span>
<span class="sd">        based on the norm and colormap set for this ScalarMappable.</span>

<span class="sd">        There is one special case, for handling images that are already</span>
<span class="sd">        rgb or rgba, such as might have been read from an image file.</span>
<span class="sd">        If *x* is an ndarray with 3 dimensions,</span>
<span class="sd">        and the last dimension is either 3 or 4, then it will be</span>
<span class="sd">        treated as an rgb or rgba array, and no mapping will be done.</span>
<span class="sd">        The array can be uint8, or it can be floating point with</span>
<span class="sd">        values in the 0-1 range; otherwise a ValueError will be raised.</span>
<span class="sd">        If it is a masked array, the mask will be ignored.</span>
<span class="sd">        If the last dimension is 3, the *alpha* kwarg (defaulting to 1)</span>
<span class="sd">        will be used to fill in the transparency.  If the last dimension</span>
<span class="sd">        is 4, the *alpha* kwarg is ignored; it does not</span>
<span class="sd">        replace the preexisting alpha.  A ValueError will be raised</span>
<span class="sd">        if the third dimension is other than 3 or 4.</span>

<span class="sd">        In either case, if *bytes* is *False* (default), the rgba</span>
<span class="sd">        array will be floats in the 0-1 range; if it is *True*,</span>
<span class="sd">        the returned rgba array will be uint8 in the 0 to 255 range.</span>

<span class="sd">        If norm is False, no normalization of the input data is</span>
<span class="sd">        performed, and it is assumed to be in the range (0-1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check for special case, image input:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>
                    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">xx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="n">xx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
                <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Third dimension must be 3 or 4&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">norm</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">xx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Floating point image RGB values &quot;</span>
                                         <span class="s2">&quot;must be in the 0..1 range.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">xx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">xx</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image RGB array must be uint8 or &quot;</span>
                                     <span class="s2">&quot;floating point; found </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">xx</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">xx</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># e.g., x is not an ndarray; so try mapping it</span>
            <span class="k">pass</span>

        <span class="c1"># This is the normal case, mapping a scalar array:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">rgba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="nb">bytes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rgba</span>

    <span class="k">def</span> <span class="nf">set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value array from array-like *A*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : array-like or None</span>
<span class="sd">            The values that are mapped to colors.</span>

<span class="sd">            The base class `.ScalarMappable` does not make any assumptions on</span>
<span class="sd">            the dimensionality and shape of the value array *A*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image data of dtype </span><span class="si">{</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> cannot be &quot;</span>
                            <span class="s2">&quot;converted to float&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array of values, that are mapped to colors.</span>

<span class="sd">        The base class `.ScalarMappable` does not make any assumptions on</span>
<span class="sd">        the dimensionality and shape of the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>

    <span class="k">def</span> <span class="nf">get_cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `.Colormap` instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span>

    <span class="k">def</span> <span class="nf">get_clim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the values (min, max) that are mapped to the colormap limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span>

    <span class="k">def</span> <span class="nf">set_clim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the norm limits for image scaling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vmin, vmax : float</span>
<span class="sd">             The limits.</span>

<span class="sd">             The limits may also be passed as a tuple (*vmin*, *vmax*) as a</span>
<span class="sd">             single positional argument.</span>

<span class="sd">             .. ACCEPTS: (vmin: float, vmax: float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the norm&#39;s limits are updated self.changed() will be called</span>
        <span class="c1"># through the callbacks attached to the norm</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmin</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">_sanitize_extrema</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">_sanitize_extrema</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Always returns 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This method is intended to be overridden by Artist sub-classes</span>
        <span class="k">return</span> <span class="mf">1.</span>

    <span class="k">def</span> <span class="nf">set_cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the colormap for luminance data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : `.Colormap` or str or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">_ensure_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>  <span class="c1"># Things are not set up properly yet.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span>

    <span class="nd">@norm</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_isinstance</span><span class="p">((</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale_cls</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">_scale_mapping</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid norm str name; the following values are &quot;</span>
                    <span class="s2">&quot;supported: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scale</span><span class="o">.</span><span class="n">_scale_mapping</span><span class="p">))</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">_auto_norm_from_scale</span><span class="p">(</span><span class="n">scale_cls</span><span class="p">)()</span>

        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">:</span>
            <span class="c1"># We aren&#39;t updating anything</span>
            <span class="k">return</span>

        <span class="n">in_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="c1"># Remove the current callback and connect to the new one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the normalization instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : `.Normalize` or str or None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If there are any colorbars using the mappable for this norm, setting</span>
<span class="sd">        the norm of the mappable will reset the norm, locator, and formatters</span>
<span class="sd">        on the colorbar to default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>

    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoscale the scalar limits on the norm instance using the</span>
<span class="sd">        current array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must first set_array for mappable&#39;</span><span class="p">)</span>
        <span class="c1"># If the norm&#39;s limits are updated self.changed() will be called</span>
        <span class="c1"># through the callbacks attached to the norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">autoscale_None</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoscale the scalar limits on the norm instance using the</span>
<span class="sd">        current array, changing only limits that are None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must first set_array for mappable&#39;</span><span class="p">)</span>
        <span class="c1"># If the norm&#39;s limits are updated self.changed() will be called</span>
        <span class="c1"># through the callbacks attached to the norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call this whenever the mappable is changed to notify all the</span>
<span class="sd">        callbackSM listeners to the &#39;changed&#39; signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>


<span class="c1"># The docstrings here must be generic enough to apply to all relevant methods.</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">_docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">cmap_doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`</span>
<span class="s2">    The Colormap instance or registered colormap name used to map scalar data</span>
<span class="s2">    to colors.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">norm_doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">norm : str or `~matplotlib.colors.Normalize`, optional</span>
<span class="s2">    The normalization method used to scale scalar data to the [0, 1] range</span>
<span class="s2">    before mapping to colors using *cmap*. By default, a linear scaling is</span>
<span class="s2">    used, mapping the lowest value to 0 and the highest to 1.</span>

<span class="s2">    If given, this can be one of the following:</span>

<span class="s2">    - An instance of `.Normalize` or one of its subclasses</span>
<span class="s2">      (see :doc:`/tutorials/colors/colormapnorms`).</span>
<span class="s2">    - A scale name, i.e. one of &quot;linear&quot;, &quot;log&quot;, &quot;symlog&quot;, &quot;logit&quot;, etc.  For a</span>
<span class="s2">      list of available scales, call `matplotlib.scale.get_scale_names()`.</span>
<span class="s2">      In that case, a suitable `.Normalize` subclass is dynamically generated</span>
<span class="s2">      and instantiated.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">vmin_vmax_doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">vmin, vmax : float, optional</span>
<span class="s2">    When using scalar data and no explicit *norm*, *vmin* and *vmax* define</span>
<span class="s2">    the data range that the colormap covers. By default, the colormap covers</span>
<span class="s2">    the complete value range of the supplied data. It is an error to use</span>
<span class="s2">    *vmin*/*vmax* when a *norm* instance is given (but using a `str` *norm*</span>
<span class="s2">    name together with *vmin*/*vmax* is acceptable).&quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_ensure_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure that we have a `.Colormap` object.</span>

<span class="sd">    For internal use to preserve type stability of errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cmap : None, str, Colormap</span>

<span class="sd">        - if a `Colormap`, return it</span>
<span class="sd">        - if a string, look it up in mpl.colormaps</span>
<span class="sd">        - if None, look up the default color map in mpl.colormaps</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Colormap</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">Colormap</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cmap</span>
    <span class="n">cmap_name</span> <span class="o">=</span> <span class="n">cmap</span> <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;image.cmap&quot;</span><span class="p">]</span>
    <span class="c1"># use check_in_list to ensure type stability of the exception raised by</span>
    <span class="c1"># the internal usage of this (ValueError vs KeyError)</span>
    <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">_colormaps</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="n">cmap_name</span><span class="p">]</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Alexander Puck Neuwirth.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>