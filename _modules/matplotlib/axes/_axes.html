

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>matplotlib.axes._axes &mdash; smpl  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> smpl
          

          
          </a>

          
            
            
              <div class="version">
                1.2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Links:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/APN-Pucky/smpl">GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../example/index.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.html">smpl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Profiling:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../performance/index.html">Graph Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance/line.html">Line Profiling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://smpl.readthedocs.io/en/stable/">RTD</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/smpl/">Stable</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/smpl/test/">Dev</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">smpl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../matplotlib.html">matplotlib</a> &raquo;</li>
        
      <li>matplotlib.axes._axes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for matplotlib.axes._axes</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Number</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.category</span>  <span class="c1"># Register category unit converter as side-effect.</span>
<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mcoll</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
<span class="kn">import</span> <span class="nn">matplotlib.contour</span> <span class="k">as</span> <span class="nn">mcontour</span>
<span class="kn">import</span> <span class="nn">matplotlib.dates</span>  <span class="c1"># noqa # Register date unit converter as side-effect.</span>
<span class="kn">import</span> <span class="nn">matplotlib.image</span> <span class="k">as</span> <span class="nn">mimage</span>
<span class="kn">import</span> <span class="nn">matplotlib.legend</span> <span class="k">as</span> <span class="nn">mlegend</span>
<span class="kn">import</span> <span class="nn">matplotlib.lines</span> <span class="k">as</span> <span class="nn">mlines</span>
<span class="kn">import</span> <span class="nn">matplotlib.markers</span> <span class="k">as</span> <span class="nn">mmarkers</span>
<span class="kn">import</span> <span class="nn">matplotlib.mlab</span> <span class="k">as</span> <span class="nn">mlab</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.quiver</span> <span class="k">as</span> <span class="nn">mquiver</span>
<span class="kn">import</span> <span class="nn">matplotlib.stackplot</span> <span class="k">as</span> <span class="nn">mstack</span>
<span class="kn">import</span> <span class="nn">matplotlib.streamplot</span> <span class="k">as</span> <span class="nn">mstream</span>
<span class="kn">import</span> <span class="nn">matplotlib.table</span> <span class="k">as</span> <span class="nn">mtable</span>
<span class="kn">import</span> <span class="nn">matplotlib.text</span> <span class="k">as</span> <span class="nn">mtext</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">mticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">mtransforms</span>
<span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="k">as</span> <span class="nn">mtri</span>
<span class="kn">import</span> <span class="nn">matplotlib.units</span> <span class="k">as</span> <span class="nn">munits</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">_api</span><span class="p">,</span> <span class="n">_docstring</span><span class="p">,</span> <span class="n">_preprocess_data</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes._base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_AxesBase</span><span class="p">,</span> <span class="n">_TransformedBoundsLocator</span><span class="p">,</span> <span class="n">_process_plot_format</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes._secondary_axes</span> <span class="kn">import</span> <span class="n">SecondaryAxis</span>
<span class="kn">from</span> <span class="nn">matplotlib.container</span> <span class="kn">import</span> <span class="n">BarContainer</span><span class="p">,</span> <span class="n">ErrorbarContainer</span><span class="p">,</span> <span class="n">StemContainer</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># The axes module contains all the wrappers to plotting functions.</span>
<span class="c1"># All the other methods should go in the _AxesBase class.</span>


<div class="viewcode-block" id="Axes"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes">[docs]</a><span class="nd">@_docstring</span><span class="o">.</span><span class="n">interpd</span>
<span class="k">class</span> <span class="nc">Axes</span><span class="p">(</span><span class="n">_AxesBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The `Axes` contains most of the figure elements: `~.axis.Axis`,</span>
<span class="sd">    `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,</span>
<span class="sd">    and sets the coordinate system.</span>

<span class="sd">    The `Axes` instance supports callbacks through a callbacks attribute which</span>
<span class="sd">    is a `~.cbook.CallbackRegistry` instance.  The events you can connect to</span>
<span class="sd">    are &#39;xlim_changed&#39; and &#39;ylim_changed&#39; and the callback will be called with</span>
<span class="sd">    func(*ax*) where *ax* is the `Axes` instance.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dataLim : `.Bbox`</span>
<span class="sd">        The bounding box enclosing all data displayed in the Axes.</span>
<span class="sd">    viewLim : `.Bbox`</span>
<span class="sd">        The view limits in data coordinates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">### Labelling, legend and texts</span>

<div class="viewcode-block" id="Axes.get_title"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.get_title">[docs]</a>    <span class="k">def</span> <span class="nf">get_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an Axes title.</span>

<span class="sd">        Get one of the three available Axes titles. The available titles</span>
<span class="sd">        are positioned above the Axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : {&#39;center&#39;, &#39;left&#39;, &#39;right&#39;}, str, default: &#39;center&#39;</span>
<span class="sd">            Which title to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The title text string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">titles</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                  <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                  <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">check_getitem</span><span class="p">(</span><span class="n">titles</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">title</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span></div>

<div class="viewcode-block" id="Axes.set_title"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.set_title">[docs]</a>    <span class="k">def</span> <span class="nf">set_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a title for the Axes.</span>

<span class="sd">        Set one of the three available Axes titles. The available titles</span>
<span class="sd">        are positioned above the Axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : str</span>
<span class="sd">            Text to use for the title</span>

<span class="sd">        fontdict : dict</span>
<span class="sd">            A dictionary controlling the appearance of the title text,</span>
<span class="sd">            the default *fontdict* is::</span>

<span class="sd">               {&#39;fontsize&#39;: rcParams[&#39;axes.titlesize&#39;],</span>
<span class="sd">                &#39;fontweight&#39;: rcParams[&#39;axes.titleweight&#39;],</span>
<span class="sd">                &#39;color&#39;: rcParams[&#39;axes.titlecolor&#39;],</span>
<span class="sd">                &#39;verticalalignment&#39;: &#39;baseline&#39;,</span>
<span class="sd">                &#39;horizontalalignment&#39;: loc}</span>

<span class="sd">        loc : {&#39;center&#39;, &#39;left&#39;, &#39;right&#39;}, default: :rc:`axes.titlelocation`</span>
<span class="sd">            Which title to set.</span>

<span class="sd">        y : float, default: :rc:`axes.titley`</span>
<span class="sd">            Vertical Axes location for the title (1.0 is the top).  If</span>
<span class="sd">            None (the default) and :rc:`axes.titley` is also None, y is</span>
<span class="sd">            determined automatically to avoid decorators on the Axes.</span>

<span class="sd">        pad : float, default: :rc:`axes.titlepad`</span>
<span class="sd">            The offset of the title from the top of the Axes, in points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.Text`</span>
<span class="sd">            The matplotlib text instance representing the title</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `.Text` properties</span>
<span class="sd">            Other keyword arguments are text properties, see `.Text` for a list</span>
<span class="sd">            of valid text properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titlelocation&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titley&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_autotitlepos</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

        <span class="n">titles</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                  <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                  <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">check_getitem</span><span class="p">(</span><span class="n">titles</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titlesize&#39;</span><span class="p">],</span>
            <span class="s1">&#39;fontweight&#39;</span><span class="p">:</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titleweight&#39;</span><span class="p">],</span>
            <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;baseline&#39;</span><span class="p">,</span>
            <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="n">titlecolor</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titlecolor&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_str_lower_equal</span><span class="p">(</span><span class="n">titlecolor</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">):</span>
            <span class="n">default</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">titlecolor</span>
        <span class="k">if</span> <span class="n">pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titlepad&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_title_offset_trans</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pad</span><span class="p">))</span>
        <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fontdict</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title</span></div>

<div class="viewcode-block" id="Axes.get_legend_handles_labels"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.get_legend_handles_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_legend_handles_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend_handler_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return handles and labels for legend</span>

<span class="sd">        ``ax.legend()`` is equivalent to ::</span>

<span class="sd">          h, l = ax.get_legend_handles_labels()</span>
<span class="sd">          ax.legend(h, l)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pass through to legend.</span>
        <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">_get_legend_handles_labels</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="n">legend_handler_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="Axes.legend"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.legend">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Place a legend on the Axes.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            legend()</span>
<span class="sd">            legend(handles, labels)</span>
<span class="sd">            legend(handles=handles)</span>
<span class="sd">            legend(labels)</span>

<span class="sd">        The call signatures correspond to the following different ways to use</span>
<span class="sd">        this method:</span>

<span class="sd">        **1. Automatic detection of elements to be shown in the legend**</span>

<span class="sd">        The elements to be added to the legend are automatically determined,</span>
<span class="sd">        when you do not pass in any extra arguments.</span>

<span class="sd">        In this case, the labels are taken from the artist. You can specify</span>
<span class="sd">        them either at artist creation or by calling the</span>
<span class="sd">        :meth:`~.Artist.set_label` method on the artist::</span>

<span class="sd">            ax.plot([1, 2, 3], label=&#39;Inline label&#39;)</span>
<span class="sd">            ax.legend()</span>

<span class="sd">        or::</span>

<span class="sd">            line, = ax.plot([1, 2, 3])</span>
<span class="sd">            line.set_label(&#39;Label via method&#39;)</span>
<span class="sd">            ax.legend()</span>

<span class="sd">        .. note::</span>
<span class="sd">            Specific artists can be excluded from the automatic legend element</span>
<span class="sd">            selection by using a label starting with an underscore, &quot;_&quot;.</span>
<span class="sd">            A string starting with an underscore is the default label for all</span>
<span class="sd">            artists, so calling `.Axes.legend` without any arguments and</span>
<span class="sd">            without setting the labels manually will result in no legend being</span>
<span class="sd">            drawn.</span>


<span class="sd">        **2. Explicitly listing the artists and labels in the legend**</span>

<span class="sd">        For full control of which artists have a legend entry, it is possible</span>
<span class="sd">        to pass an iterable of legend artists followed by an iterable of</span>
<span class="sd">        legend labels respectively::</span>

<span class="sd">            ax.legend([line1, line2, line3], [&#39;label1&#39;, &#39;label2&#39;, &#39;label3&#39;])</span>


<span class="sd">        **3. Explicitly listing the artists in the legend**</span>

<span class="sd">        This is similar to 2, but the labels are taken from the artists&#39;</span>
<span class="sd">        label properties. Example::</span>

<span class="sd">            line1, = ax.plot([1, 2, 3], label=&#39;label1&#39;)</span>
<span class="sd">            line2, = ax.plot([1, 2, 3], label=&#39;label2&#39;)</span>
<span class="sd">            ax.legend(handles=[line1, line2])</span>


<span class="sd">        **4. Labeling existing plot elements**</span>

<span class="sd">        .. admonition:: Discouraged</span>

<span class="sd">            This call signature is discouraged, because the relation between</span>
<span class="sd">            plot elements and labels is only implicit by their order and can</span>
<span class="sd">            easily be mixed up.</span>

<span class="sd">        To make a legend for all artists on an Axes, call this function with</span>
<span class="sd">        an iterable of strings, one for each legend item. For example::</span>

<span class="sd">            ax.plot([1, 2, 3])</span>
<span class="sd">            ax.plot([5, 6, 7])</span>
<span class="sd">            ax.legend([&#39;First line&#39;, &#39;Second line&#39;])</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        handles : sequence of `.Artist`, optional</span>
<span class="sd">            A list of Artists (lines, patches) to be added to the legend.</span>
<span class="sd">            Use this together with *labels*, if you need full control on what</span>
<span class="sd">            is shown in the legend and the automatic mechanism described above</span>
<span class="sd">            is not sufficient.</span>

<span class="sd">            The length of handles and labels should be the same in this</span>
<span class="sd">            case. If they are not, they are truncated to the smaller length.</span>

<span class="sd">        labels : list of str, optional</span>
<span class="sd">            A list of labels to show next to the artists.</span>
<span class="sd">            Use this together with *handles*, if you need full control on what</span>
<span class="sd">            is shown in the legend and the automatic mechanism described above</span>
<span class="sd">            is not sufficient.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.legend.Legend`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        %(_legend_kw_doc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        .Figure.legend</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Some artists are not supported by this function.  See</span>
<span class="sd">        :doc:`/tutorials/intermediate/legend_guide` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: gallery/text_labels_and_annotations/legend.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">extra_args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">_parse_legend_args</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;legend only accepts two non-keyword arguments&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">Legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span><span class="o">.</span><span class="n">_remove_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_legend</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span></div>

    <span class="k">def</span> <span class="nf">_remove_legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Axes.inset_axes"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.inset_axes">[docs]</a>    <span class="k">def</span> <span class="nf">inset_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a child inset Axes to this existing Axes.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This method is experimental as of 3.0, and the API may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds : [x0, y0, width, height]</span>
<span class="sd">            Lower-left corner of inset Axes, and its width and height.</span>

<span class="sd">        transform : `.Transform`</span>
<span class="sd">            Defaults to `ax.transAxes`, i.e. the units of *rect* are in</span>
<span class="sd">            Axes-relative coordinates.</span>

<span class="sd">        projection : {None, &#39;aitoff&#39;, &#39;hammer&#39;, &#39;lambert&#39;, &#39;mollweide&#39;, \</span>
<span class="sd">&#39;polar&#39;, &#39;rectilinear&#39;, str}, optional</span>
<span class="sd">            The projection type of the inset `~.axes.Axes`. *str* is the name</span>
<span class="sd">            of a custom projection, see `~matplotlib.projections`. The default</span>
<span class="sd">            None results in a &#39;rectilinear&#39; projection.</span>

<span class="sd">        polar : bool, default: False</span>
<span class="sd">            If True, equivalent to projection=&#39;polar&#39;.</span>

<span class="sd">        axes_class : subclass type of `~.axes.Axes`, optional</span>
<span class="sd">            The `.axes.Axes` subclass that is instantiated.  This parameter</span>
<span class="sd">            is incompatible with *projection* and *polar*.  See</span>
<span class="sd">            :ref:`axisartist_users-guide-index` for examples.</span>

<span class="sd">        zorder : number</span>
<span class="sd">            Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower</span>
<span class="sd">            to change whether it is above or below data plotted on the</span>
<span class="sd">            parent Axes.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Other keyword arguments are passed on to the inset Axes class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax</span>
<span class="sd">            The created `~.axes.Axes` instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This example makes two inset Axes, the first is in Axes-relative</span>
<span class="sd">        coordinates, and the second in data-coordinates::</span>

<span class="sd">            fig, ax = plt.subplots()</span>
<span class="sd">            ax.plot(range(10))</span>
<span class="sd">            axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])</span>
<span class="sd">            axin2 = ax.inset_axes(</span>
<span class="sd">                    [5, 7, 2.3, 2.3], transform=ax.transData)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transAxes</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;inset_axes&#39;</span><span class="p">)</span>

        <span class="c1"># This puts the rectangle into figure-relative coordinates.</span>
        <span class="n">inset_locator</span> <span class="o">=</span> <span class="n">_TransformedBoundsLocator</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">inset_locator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">projection_class</span><span class="p">,</span> <span class="n">pkw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">_process_projection_requirements</span><span class="p">(</span>
                <span class="n">bounds</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">inset_ax</span> <span class="o">=</span> <span class="n">projection_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span> <span class="o">**</span><span class="n">pkw</span><span class="p">)</span>

        <span class="c1"># this locator lets the axes move if in data coordinates.</span>
        <span class="c1"># it gets called in `ax.apply_aspect() (of all places)</span>
        <span class="n">inset_ax</span><span class="o">.</span><span class="n">set_axes_locator</span><span class="p">(</span><span class="n">inset_locator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_child_axes</span><span class="p">(</span><span class="n">inset_ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inset_ax</span></div>

<div class="viewcode-block" id="Axes.indicate_inset"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.indicate_inset">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">indicate_inset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">inset_ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;0.5&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                       <span class="n">zorder</span><span class="o">=</span><span class="mf">4.99</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an inset indicator to the Axes.  This is a rectangle on the plot</span>
<span class="sd">        at the position indicated by *bounds* that optionally has lines that</span>
<span class="sd">        connect the rectangle to an inset Axes (`.Axes.inset_axes`).</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This method is experimental as of 3.0, and the API may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds : [x0, y0, width, height]</span>
<span class="sd">            Lower-left corner of rectangle to be marked, and its width</span>
<span class="sd">            and height.</span>

<span class="sd">        inset_ax : `.Axes`</span>
<span class="sd">            An optional inset Axes to draw connecting lines to.  Two lines are</span>
<span class="sd">            drawn connecting the indicator box to the inset Axes on corners</span>
<span class="sd">            chosen so as to not overlap with the indicator box.</span>

<span class="sd">        transform : `.Transform`</span>
<span class="sd">            Transform for the rectangle coordinates. Defaults to</span>
<span class="sd">            `ax.transAxes`, i.e. the units of *rect* are in Axes-relative</span>
<span class="sd">            coordinates.</span>

<span class="sd">        facecolor : color, default: &#39;none&#39;</span>
<span class="sd">            Facecolor of the rectangle.</span>

<span class="sd">        edgecolor : color, default: &#39;0.5&#39;</span>
<span class="sd">            Color of the rectangle and color of the connecting lines.</span>

<span class="sd">        alpha : float, default: 0.5</span>
<span class="sd">            Transparency of the rectangle and connector lines.</span>

<span class="sd">        zorder : float, default: 4.99</span>
<span class="sd">            Drawing order of the rectangle and connector lines.  The default,</span>
<span class="sd">            4.99, is just below the default level of inset Axes.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Other keyword arguments are passed on to the `.Rectangle` patch:</span>

<span class="sd">            %(Rectangle:kwdoc)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rectangle_patch : `.patches.Rectangle`</span>
<span class="sd">             The indicator frame.</span>

<span class="sd">        connector_lines : 4-tuple of `.patches.ConnectionPatch`</span>
<span class="sd">            The four connector lines connecting to (lower_left, upper_left,</span>
<span class="sd">            lower_right upper_right) corners of *inset_ax*. Two lines are</span>
<span class="sd">            set with visibility to *False*,  but the user can set the</span>
<span class="sd">            visibility to True if the automatic choice is not deemed correct.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># to make the axes connectors work, we need to apply the aspect to</span>
        <span class="c1"># the parent axes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_aspect</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;_indicate_inset&#39;</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="n">rectangle_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span>
            <span class="n">facecolor</span><span class="o">=</span><span class="n">facecolor</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rectangle_patch</span><span class="p">)</span>

        <span class="n">connects</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">inset_ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># connect the inset_axes to the rectangle</span>
            <span class="k">for</span> <span class="n">xy_inset_ax</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
                <span class="c1"># inset_ax positions are in axes coordinates</span>
                <span class="c1"># The 0, 1 values define the four edges if the inset_ax</span>
                <span class="c1"># lower_left, upper_left, lower_right upper_right.</span>
                <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span> <span class="o">=</span> <span class="n">xy_inset_ax</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_inverted</span><span class="p">():</span>
                    <span class="n">ex</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ex</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_inverted</span><span class="p">():</span>
                    <span class="n">ey</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ey</span>
                <span class="n">xy_data</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">ex</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">ey</span> <span class="o">*</span> <span class="n">height</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">ConnectionPatch</span><span class="p">(</span>
                    <span class="n">xyA</span><span class="o">=</span><span class="n">xy_inset_ax</span><span class="p">,</span> <span class="n">coordsA</span><span class="o">=</span><span class="n">inset_ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
                    <span class="n">xyB</span><span class="o">=</span><span class="n">xy_data</span><span class="p">,</span> <span class="n">coordsB</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
                    <span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
                    <span class="n">edgecolor</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
                <span class="n">connects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="c1"># decide which two of the lines to keep visible....</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">inset_ax</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
            <span class="n">bboxins</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">transSubfigure</span><span class="p">)</span>
            <span class="n">rectbbox</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">from_bounds</span><span class="p">(</span>
                <span class="o">*</span><span class="n">bounds</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">x0</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">x0</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">x1</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">y0</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">y0</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">y1</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">y1</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x0</span> <span class="o">^</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x0</span> <span class="o">==</span> <span class="n">y1</span><span class="p">)</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x1</span> <span class="o">^</span> <span class="n">y1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rectangle_patch</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">connects</span><span class="p">)</span> <span class="k">if</span> <span class="n">connects</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Axes.indicate_inset_zoom"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.indicate_inset_zoom">[docs]</a>    <span class="k">def</span> <span class="nf">indicate_inset_zoom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inset_ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an inset indicator rectangle to the Axes based on the axis</span>
<span class="sd">        limits for an *inset_ax* and draw connectors between *inset_ax*</span>
<span class="sd">        and the rectangle.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This method is experimental as of 3.0, and the API may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inset_ax : `.Axes`</span>
<span class="sd">            Inset Axes to draw connecting lines to.  Two lines are</span>
<span class="sd">            drawn connecting the indicator box to the inset Axes on corners</span>
<span class="sd">            chosen so as to not overlap with the indicator box.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Other keyword arguments are passed on to `.Axes.indicate_inset`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rectangle_patch : `.patches.Rectangle`</span>
<span class="sd">             Rectangle artist.</span>

<span class="sd">        connector_lines : 4-tuple of `.patches.ConnectionPatch`</span>
<span class="sd">            Each of four connector lines coming from the rectangle drawn on</span>
<span class="sd">            this axis, in the order lower left, upper left, lower right,</span>
<span class="sd">            upper right.</span>
<span class="sd">            Two are set with visibility to *False*,  but the user can</span>
<span class="sd">            set the visibility to *True* if the automatic choice is not deemed</span>
<span class="sd">            correct.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xlim</span> <span class="o">=</span> <span class="n">inset_ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="n">inset_ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicate_inset</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="n">inset_ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.secondary_xaxis"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.secondary_xaxis">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">secondary_xaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a second x-axis to this Axes.</span>

<span class="sd">        For example if we want to have a second scale for the data plotted on</span>
<span class="sd">        the xaxis.</span>

<span class="sd">        %(_secax_docstring)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The main axis shows frequency, and the secondary axis shows period.</span>

<span class="sd">        .. plot::</span>

<span class="sd">            fig, ax = plt.subplots()</span>
<span class="sd">            ax.loglog(range(1, 360, 5), range(1, 360, 5))</span>
<span class="sd">            ax.set_xlabel(&#39;frequency [Hz]&#39;)</span>

<span class="sd">            def invert(x):</span>
<span class="sd">                # 1/x with special treatment of x == 0</span>
<span class="sd">                x = np.array(x).astype(float)</span>
<span class="sd">                near_zero = np.isclose(x, 0)</span>
<span class="sd">                x[near_zero] = np.inf</span>
<span class="sd">                x[~near_zero] = 1 / x[~near_zero]</span>
<span class="sd">                return x</span>

<span class="sd">            # the inverse of 1/x is itself</span>
<span class="sd">            secax = ax.secondary_xaxis(&#39;top&#39;, functions=(invert, invert))</span>
<span class="sd">            secax.set_xlabel(&#39;Period [s]&#39;)</span>
<span class="sd">            plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="n">secondary_ax</span> <span class="o">=</span> <span class="n">SecondaryAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_child_axes</span><span class="p">(</span><span class="n">secondary_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">secondary_ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;secondary_xaxis location must be either &#39;</span>
                             <span class="s1">&#39;a float or &quot;top&quot;/&quot;bottom&quot;&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.secondary_yaxis"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.secondary_yaxis">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">secondary_yaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a second y-axis to this Axes.</span>

<span class="sd">        For example if we want to have a second scale for the data plotted on</span>
<span class="sd">        the yaxis.</span>

<span class="sd">        %(_secax_docstring)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Add a secondary Axes that converts from radians to degrees</span>

<span class="sd">        .. plot::</span>

<span class="sd">            fig, ax = plt.subplots()</span>
<span class="sd">            ax.plot(range(1, 360, 5), range(1, 360, 5))</span>
<span class="sd">            ax.set_ylabel(&#39;degrees&#39;)</span>
<span class="sd">            secax = ax.secondary_yaxis(&#39;right&#39;, functions=(np.deg2rad,</span>
<span class="sd">                                                           np.rad2deg))</span>
<span class="sd">            secax.set_ylabel(&#39;radians&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="n">secondary_ax</span> <span class="o">=</span> <span class="n">SecondaryAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span>
                                         <span class="n">functions</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_child_axes</span><span class="p">(</span><span class="n">secondary_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">secondary_ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;secondary_yaxis location must be either &#39;</span>
                             <span class="s1">&#39;a float or &quot;left&quot;/&quot;right&quot;&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.text"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.text">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add text to the Axes.</span>

<span class="sd">        Add the text *s* to the Axes at location *x*, *y* in data coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : float</span>
<span class="sd">            The position to place the text. By default, this is in data</span>
<span class="sd">            coordinates. The coordinate system can be changed using the</span>
<span class="sd">            *transform* parameter.</span>

<span class="sd">        s : str</span>
<span class="sd">            The text.</span>

<span class="sd">        fontdict : dict, default: None</span>
<span class="sd">            A dictionary to override the default text properties. If fontdict</span>
<span class="sd">            is None, the defaults are determined by `.rcParams`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.Text`</span>
<span class="sd">            The created `.Text` instance.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.text.Text` properties.</span>
<span class="sd">            Other miscellaneous text parameters.</span>

<span class="sd">            %(Text:kwdoc)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Individual keyword arguments can be used to override any given</span>
<span class="sd">        parameter::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, fontsize=12)</span>

<span class="sd">        The default transform specifies that text is in data coords,</span>
<span class="sd">        alternatively, you can specify text in axis coords ((0, 0) is</span>
<span class="sd">        lower-left and (1, 1) is upper-right).  The example below places</span>
<span class="sd">        text in the center of the Axes::</span>

<span class="sd">            &gt;&gt;&gt; text(0.5, 0.5, &#39;matplotlib&#39;, horizontalalignment=&#39;center&#39;,</span>
<span class="sd">            ...      verticalalignment=&#39;center&#39;, transform=ax.transAxes)</span>

<span class="sd">        You can put a rectangular box around the text instance (e.g., to</span>
<span class="sd">        set a background color) by using the keyword *bbox*.  *bbox* is</span>
<span class="sd">        a dictionary of `~matplotlib.patches.Rectangle`</span>
<span class="sd">        properties.  For example::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, bbox=dict(facecolor=&#39;red&#39;, alpha=0.5))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">effective_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;baseline&#39;</span><span class="p">,</span>
            <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
            <span class="s1">&#39;clip_on&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span><span class="n">fontdict</span> <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}),</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">effective_kwargs</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>

<div class="viewcode-block" id="Axes.annotate"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.annotate">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">arrowprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotation_clip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Signature must match Annotation. This is verified in</span>
        <span class="c1"># test_annotate_signature().</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Annotation</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="n">xytext</span><span class="p">,</span> <span class="n">xycoords</span><span class="o">=</span><span class="n">xycoords</span><span class="p">,</span>
                             <span class="n">textcoords</span><span class="o">=</span><span class="n">textcoords</span><span class="p">,</span> <span class="n">arrowprops</span><span class="o">=</span><span class="n">arrowprops</span><span class="p">,</span>
                             <span class="n">annotation_clip</span><span class="o">=</span><span class="n">annotation_clip</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;clip_on&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>
    <span class="n">annotate</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Annotation</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="c1">#### Lines and spans</span>

<div class="viewcode-block" id="Axes.axhline"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.axhline">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axhline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a horizontal line across the Axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : float, default: 0</span>
<span class="sd">            y position in data coordinates of the horizontal line.</span>

<span class="sd">        xmin : float, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        xmax : float, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.lines.Line2D`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Valid keyword arguments are `.Line2D` properties, with the</span>
<span class="sd">            exception of &#39;transform&#39;:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hlines : Add horizontal lines in data coordinates.</span>
<span class="sd">        axhspan : Add a horizontal span (rectangle) across the axis.</span>
<span class="sd">        axline : Add a line with an arbitrary slope.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        * draw a thick red hline at &#39;y&#39; = 0 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(linewidth=4, color=&#39;r&#39;)</span>

<span class="sd">        * draw a default hline at &#39;y&#39; = 1 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=1)</span>

<span class="sd">        * draw a default hline at &#39;y&#39; = .5 that spans the middle half of</span>
<span class="sd">          the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=.5, xmin=0.25, xmax=0.75)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_no_units</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">,</span> <span class="s1">&#39;xmax&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;transform&#39; is not allowed as a keyword &quot;</span>
                             <span class="s2">&quot;argument; axhline generates its own transform.&quot;</span><span class="p">)</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ybound</span><span class="p">()</span>

        <span class="c1"># Strip away the units for comparison with non-unitized bounds.</span>
        <span class="n">yy</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">scaley</span> <span class="o">=</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&lt;</span> <span class="n">ymin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scaley</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="Axes.axvline"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.axvline">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axvline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertical line across the Axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float, default: 0</span>
<span class="sd">            x position in data coordinates of the vertical line.</span>

<span class="sd">        ymin : float, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        ymax : float, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.lines.Line2D`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Valid keyword arguments are `.Line2D` properties, with the</span>
<span class="sd">            exception of &#39;transform&#39;:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        vlines : Add vertical lines in data coordinates.</span>
<span class="sd">        axvspan : Add a vertical span (rectangle) across the axis.</span>
<span class="sd">        axline : Add a line with an arbitrary slope.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        * draw a thick red vline at *x* = 0 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(linewidth=4, color=&#39;r&#39;)</span>

<span class="sd">        * draw a default vline at *x* = 1 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=1)</span>

<span class="sd">        * draw a default vline at *x* = .5 that spans the middle half of</span>
<span class="sd">          the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=.5, ymin=0.25, ymax=0.75)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_no_units</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">,</span> <span class="s1">&#39;ymax&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;transform&#39; is not allowed as a keyword &quot;</span>
                             <span class="s2">&quot;argument; axvline generates its own transform.&quot;</span><span class="p">)</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xbound</span><span class="p">()</span>

        <span class="c1"># Strip away the units for comparison with non-unitized bounds.</span>
        <span class="n">xx</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">scalex</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_no_units</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="c1"># Helper method to check that vals are not unitized</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">munits</span><span class="o">.</span><span class="n">_is_natively_supported</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> must be a single scalar value, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Axes.axline"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.axline">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy1</span><span class="p">,</span> <span class="n">xy2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an infinitely long straight line.</span>

<span class="sd">        The line can be defined either by two points *xy1* and *xy2*, or</span>
<span class="sd">        by one point *xy1* and a *slope*.</span>

<span class="sd">        This draws a straight line &quot;on the screen&quot;, regardless of the x and y</span>
<span class="sd">        scales, and is thus also suitable for drawing exponential decays in</span>
<span class="sd">        semilog plots, power laws in loglog plots, etc. However, *slope*</span>
<span class="sd">        should only be used with linear scales; It has no clear meaning for</span>
<span class="sd">        all other scales, and thus the behavior is undefined. Please specify</span>
<span class="sd">        the line using the points *xy1*, *xy2* for non-linear scales.</span>

<span class="sd">        The *transform* keyword argument only applies to the points *xy1*,</span>
<span class="sd">        *xy2*. The *slope* (if given) is always in data coordinates. This can</span>
<span class="sd">        be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed</span>
<span class="sd">        slope.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy1, xy2 : (float, float)</span>
<span class="sd">            Points for the line to pass through.</span>
<span class="sd">            Either *xy2* or *slope* has to be given.</span>
<span class="sd">        slope : float, optional</span>
<span class="sd">            The slope of the line. Either *xy2* or *slope* has to be given.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.Line2D`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Valid kwargs are `.Line2D` properties</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axhline : for horizontal lines</span>
<span class="sd">        axvline : for vertical lines</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Draw a thick red line passing through (0, 0) and (1, 1)::</span>

<span class="sd">            &gt;&gt;&gt; axline((0, 0), (1, 1), linewidth=4, color=&#39;r&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">slope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xscale</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;linear&#39;</span> <span class="ow">or</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">get_yscale</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;linear&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;slope&#39; cannot be used with non-linear scales&quot;</span><span class="p">)</span>

        <span class="n">datalim</span> <span class="o">=</span> <span class="p">[</span><span class="n">xy1</span><span class="p">]</span> <span class="k">if</span> <span class="n">xy2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">xy1</span><span class="p">,</span> <span class="n">xy2</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># if a transform is passed (i.e. line points not in data space),</span>
            <span class="c1"># data limits should not be adjusted.</span>
            <span class="n">datalim</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">_AxLine</span><span class="p">(</span><span class="n">xy1</span><span class="p">,</span> <span class="n">xy2</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Like add_line, but correctly handling data limits.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_artist_props</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">get_label</span><span class="p">():</span>
            <span class="n">line</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_child</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">line</span><span class="o">.</span><span class="n">_remove_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">remove</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">datalim</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">line</span></div>

<div class="viewcode-block" id="Axes.axhspan"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.axhspan">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axhspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a horizontal span (rectangle) across the Axes.</span>

<span class="sd">        The rectangle spans from *ymin* to *ymax* vertically, and, by default,</span>
<span class="sd">        the whole x-axis horizontally.  The x-span can be set using *xmin*</span>
<span class="sd">        (default: 0) and *xmax* (default: 1) which are in axis units; e.g.</span>
<span class="sd">        ``xmin = 0.5`` always refers to the middle of the x-axis regardless of</span>
<span class="sd">        the limits set by `~.Axes.set_xlim`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ymin : float</span>
<span class="sd">            Lower y-coordinate of the span, in data units.</span>
<span class="sd">        ymax : float</span>
<span class="sd">            Upper y-coordinate of the span, in data units.</span>
<span class="sd">        xmin : float, default: 0</span>
<span class="sd">            Lower x-coordinate of the span, in x-axis (0-1) units.</span>
<span class="sd">        xmax : float, default: 1</span>
<span class="sd">            Upper x-coordinate of the span, in x-axis (0-1) units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.patches.Polygon`</span>
<span class="sd">            Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.patches.Polygon` properties</span>

<span class="sd">        %(Polygon:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axvspan : Add a vertical span across the Axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Strip units away.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_no_units</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">,</span> <span class="s1">&#39;xmax&#39;</span><span class="p">])</span>
        <span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])],</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Axes.axvspan"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.axvspan">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axvspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertical span (rectangle) across the Axes.</span>

<span class="sd">        The rectangle spans from *xmin* to *xmax* horizontally, and, by</span>
<span class="sd">        default, the whole y-axis vertically.  The y-span can be set using</span>
<span class="sd">        *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;</span>
<span class="sd">        e.g. ``ymin = 0.5`` always refers to the middle of the y-axis</span>
<span class="sd">        regardless of the limits set by `~.Axes.set_ylim`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xmin : float</span>
<span class="sd">            Lower x-coordinate of the span, in data units.</span>
<span class="sd">        xmax : float</span>
<span class="sd">            Upper x-coordinate of the span, in data units.</span>
<span class="sd">        ymin : float, default: 0</span>
<span class="sd">            Lower y-coordinate of the span, in y-axis units (0-1).</span>
<span class="sd">        ymax : float, default: 1</span>
<span class="sd">            Upper y-coordinate of the span, in y-axis units (0-1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.patches.Polygon`</span>
<span class="sd">            Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.patches.Polygon` properties</span>

<span class="sd">        %(Polygon:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axhspan : Add a horizontal span across the Axes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Draw a vertical, green, translucent rectangle from x = 1.25 to</span>
<span class="sd">        x = 1.55 that spans the yrange of the Axes.</span>

<span class="sd">        &gt;&gt;&gt; axvspan(1.25, 1.55, facecolor=&#39;g&#39;, alpha=0.5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Strip units away.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_no_units</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">,</span> <span class="s1">&#39;ymax&#39;</span><span class="p">])</span>
        <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">),</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])],</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">_interpolation_steps</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Axes.hlines"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.hlines">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot horizontal lines at each *y* from *xmin* to *xmax*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : float or array-like</span>
<span class="sd">            y-indexes where to plot the lines.</span>

<span class="sd">        xmin, xmax : float or array-like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have the same length.</span>

<span class="sd">        colors : list of colors, default: :rc:`lines.color`</span>

<span class="sd">        linestyles : {&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;}, optional</span>

<span class="sd">        label : str, default: &#39;&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>
<span class="sd">        **kwargs :  `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        vlines : vertical lines</span>
<span class="sd">        axhline : horizontal line across the Axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">xmin</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">xmax</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">xmin</span><span class="p">):</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">xmax</span><span class="p">):</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmax</span><span class="p">]</span>

        <span class="c1"># Create and combine masked_arrays from input</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_combine_masks</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>

        <span class="n">masked_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmin</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                     <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Extreme values of xmin/xmax/y.  Using masked_verts here handles</span>
            <span class="c1"># the case of y being a masked *object* array (as can be generated</span>
            <span class="c1"># e.g. by errorbar()), which would make nanmin/nanmax stumble.</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="Axes.vlines"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.vlines">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">vlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot vertical lines at each *x* from *ymin* to *ymax*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float or array-like</span>
<span class="sd">            x-indexes where to plot the lines.</span>

<span class="sd">        ymin, ymax : float or array-like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have the same length.</span>

<span class="sd">        colors : list of colors, default: :rc:`lines.color`</span>

<span class="sd">        linestyles : {&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;}, optional</span>

<span class="sd">        label : str, default: &#39;&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>
<span class="sd">        **kwargs : `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hlines : horizontal lines</span>
<span class="sd">        axvline : vertical line across the Axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">ymin</span><span class="p">):</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">ymax</span><span class="p">):</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymax</span><span class="p">]</span>

        <span class="c1"># Create and combine masked_arrays from input</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_combine_masks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ymin</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ymax</span><span class="p">)</span>

        <span class="n">masked_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ymin</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">masked_verts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ymax</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                     <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Extreme values of x/ymin/ymax.  Using masked_verts here handles</span>
            <span class="c1"># the case of x being a masked *object* array (as can be generated</span>
            <span class="c1"># e.g. by errorbar()), which would make nanmin/nanmax stumble.</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">masked_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="Axes.eventplot"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.eventplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;positions&quot;</span><span class="p">,</span> <span class="s2">&quot;lineoffsets&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;linelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidths&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;colors&quot;</span><span class="p">,</span> <span class="s2">&quot;linestyles&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">eventplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">linelengths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot identical parallel lines at the given positions.</span>

<span class="sd">        This type of plot is commonly used in neuroscience for representing</span>
<span class="sd">        neural events, where it is usually called a spike raster, dot raster,</span>
<span class="sd">        or raster plot.</span>

<span class="sd">        However, it is useful in any situation where you wish to show the</span>
<span class="sd">        timing or position of multiple sets of discrete events, such as the</span>
<span class="sd">        arrival times of people to a business on each day of the month or the</span>
<span class="sd">        date of hurricanes each year of the last century.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions : array-like or list of array-like</span>
<span class="sd">            A 1D array-like defines the positions of one sequence of events.</span>

<span class="sd">            Multiple groups of events may be passed as a list of array-likes.</span>
<span class="sd">            Each group can be styled independently by passing lists of values</span>
<span class="sd">            to *lineoffsets*, *linelengths*, *linewidths*, *colors* and</span>
<span class="sd">            *linestyles*.</span>

<span class="sd">            Note that *positions* can be a 2D array, but in practice different</span>
<span class="sd">            event groups usually have different counts so that one will use a</span>
<span class="sd">            list of different-length arrays rather than a 2D array.</span>

<span class="sd">        orientation : {&#39;horizontal&#39;, &#39;vertical&#39;}, default: &#39;horizontal&#39;</span>
<span class="sd">            The direction of the event sequence:</span>

<span class="sd">            - &#39;horizontal&#39;: the events are arranged horizontally.</span>
<span class="sd">              The indicator lines are vertical.</span>
<span class="sd">            - &#39;vertical&#39;: the events are arranged vertically.</span>
<span class="sd">              The indicator lines are horizontal.</span>

<span class="sd">        lineoffsets : float or array-like, default: 1</span>
<span class="sd">            The offset of the center of the lines from the origin, in the</span>
<span class="sd">            direction orthogonal to *orientation*.</span>

<span class="sd">            If *positions* is 2D, this can be a sequence with length matching</span>
<span class="sd">            the length of *positions*.</span>

<span class="sd">        linelengths : float or array-like, default: 1</span>
<span class="sd">            The total height of the lines (i.e. the lines stretches from</span>
<span class="sd">            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).</span>

<span class="sd">            If *positions* is 2D, this can be a sequence with length matching</span>
<span class="sd">            the length of *positions*.</span>

<span class="sd">        linewidths : float or array-like, default: :rc:`lines.linewidth`</span>
<span class="sd">            The line width(s) of the event lines, in points.</span>

<span class="sd">            If *positions* is 2D, this can be a sequence with length matching</span>
<span class="sd">            the length of *positions*.</span>

<span class="sd">        colors : color or list of colors, default: :rc:`lines.color`</span>
<span class="sd">            The color(s) of the event lines.</span>

<span class="sd">            If *positions* is 2D, this can be a sequence with length matching</span>
<span class="sd">            the length of *positions*.</span>

<span class="sd">        linestyles : str or tuple or list of such values, default: &#39;solid&#39;</span>
<span class="sd">            Default is &#39;solid&#39;. Valid strings are [&#39;solid&#39;, &#39;dashed&#39;,</span>
<span class="sd">            &#39;dashdot&#39;, &#39;dotted&#39;, &#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;]. Dash tuples</span>
<span class="sd">            should be of the form::</span>

<span class="sd">                (offset, onoffseq),</span>

<span class="sd">            where *onoffseq* is an even length tuple of on and off ink</span>
<span class="sd">            in points.</span>

<span class="sd">            If *positions* is 2D, this can be a sequence with length matching</span>
<span class="sd">            the length of *positions*.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Other keyword arguments are line collection properties.  See</span>
<span class="sd">            `.LineCollection` for a list of the valid properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.EventCollection`</span>
<span class="sd">            The `.EventCollection` that were added.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For *linelengths*, *linewidths*, *colors*, and *linestyles*, if only</span>
<span class="sd">        a single value is given, that value is applied to all lines.  If an</span>
<span class="sd">        array-like is given, it must have the same length as *positions*, and</span>
<span class="sd">        each value will be applied to the corresponding row of the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
                <span class="p">[(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># fix positions, noting that it can be a list of lists:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">positions</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">positions</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">poss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
            <span class="n">poss</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">poss</span>

        <span class="c1"># prevent &#39;singular&#39; keys from **kwargs dict from overriding the effect</span>
        <span class="c1"># of &#39;plural&#39; keyword arguments (e.g. &#39;color&#39; overriding &#39;colors&#39;)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_local_over_kwdict</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_local_over_kwdict</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">)</span>
        <span class="n">linestyles</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_local_over_kwdict</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">):</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">lineoffsets</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linelengths</span><span class="p">):</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linelengths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linewidths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span>

        <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Early conversion of the colors into RGBA values to take care</span>
            <span class="c1"># of cases like colors=&#39;0.5&#39; or colors=&#39;C1&#39;.  (Issue #8193)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Will fail if any element of *colors* is None. But as long</span>
            <span class="c1"># as len(colors) == 1 or len(positions), the rest of the</span>
            <span class="c1"># code should process *colors* properly.</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
            <span class="n">lineoffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linelengths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;lineoffsets and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linelengths and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linewidths and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;colors and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linestyles and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>

        <span class="n">colls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">lineoffset</span><span class="p">,</span> <span class="n">linelength</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">linestyle</span> <span class="ow">in</span> \
                <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">,</span>
                    <span class="n">colors</span><span class="p">,</span> <span class="n">linestyles</span><span class="p">):</span>
            <span class="n">coll</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">EventCollection</span><span class="p">(</span><span class="n">position</span><span class="p">,</span>
                                         <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                                         <span class="n">lineoffset</span><span class="o">=</span><span class="n">lineoffset</span><span class="p">,</span>
                                         <span class="n">linelength</span><span class="o">=</span><span class="n">linelength</span><span class="p">,</span>
                                         <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                                         <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                         <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">coll</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">coll</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">colls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coll</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># try to get min/max</span>
            <span class="n">min_max</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_p</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_p</span><span class="p">))</span> <span class="k">for</span> <span class="n">_p</span> <span class="ow">in</span> <span class="n">positions</span>
                       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># if we have any non-empty positions, try to autoscale</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">min_max</span><span class="p">)</span>
                <span class="n">minpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span>
                <span class="n">maxpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">maxes</span><span class="p">)</span>

                <span class="n">minline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">-</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">+</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minline</span><span class="p">,</span> <span class="n">minpos</span><span class="p">),</span> <span class="p">(</span><span class="n">maxline</span><span class="p">,</span> <span class="n">maxpos</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;horizontal&quot;</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minpos</span><span class="p">,</span> <span class="n">minline</span><span class="p">),</span> <span class="p">(</span><span class="n">maxpos</span><span class="p">,</span> <span class="n">maxline</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">colls</span></div>

    <span class="c1">#### Basic plotting</span>

    <span class="c1"># Uses a custom implementation of data-kwarg handling in</span>
    <span class="c1"># _process_plot_var_args.</span>
<div class="viewcode-block" id="Axes.plot"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.plot">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scalex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot y versus x as lines and/or markers.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            plot([x], y, [fmt], *, data=None, **kwargs)</span>
<span class="sd">            plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        The coordinates of the points or line nodes are given by *x*, *y*.</span>

<span class="sd">        The optional parameter *fmt* is a convenient way for defining basic</span>
<span class="sd">        formatting like color, marker and linestyle. It&#39;s a shortcut string</span>
<span class="sd">        notation described in the *Notes* section below.</span>

<span class="sd">        &gt;&gt;&gt; plot(x, y)        # plot x and y using default line style and color</span>
<span class="sd">        &gt;&gt;&gt; plot(x, y, &#39;bo&#39;)  # plot x and y using blue circle markers</span>
<span class="sd">        &gt;&gt;&gt; plot(y)           # plot y using x as index array 0..N-1</span>
<span class="sd">        &gt;&gt;&gt; plot(y, &#39;r+&#39;)     # ditto, but with red plusses</span>

<span class="sd">        You can use `.Line2D` properties as keyword arguments for more</span>
<span class="sd">        control on the appearance. Line properties and *fmt* can be mixed.</span>
<span class="sd">        The following two calls yield identical results:</span>

<span class="sd">        &gt;&gt;&gt; plot(x, y, &#39;go--&#39;, linewidth=2, markersize=12)</span>
<span class="sd">        &gt;&gt;&gt; plot(x, y, color=&#39;green&#39;, marker=&#39;o&#39;, linestyle=&#39;dashed&#39;,</span>
<span class="sd">        ...      linewidth=2, markersize=12)</span>

<span class="sd">        When conflicting with *fmt*, keyword arguments take precedence.</span>


<span class="sd">        **Plotting labelled data**</span>

<span class="sd">        There&#39;s a convenient way for plotting objects with labelled data (i.e.</span>
<span class="sd">        data that can be accessed by index ``obj[&#39;y&#39;]``). Instead of giving</span>
<span class="sd">        the data in *x* and *y*, you can provide the object in the *data*</span>
<span class="sd">        parameter and just give the labels for *x* and *y*::</span>

<span class="sd">        &gt;&gt;&gt; plot(&#39;xlabel&#39;, &#39;ylabel&#39;, data=obj)</span>

<span class="sd">        All indexable objects are supported. This could e.g. be a `dict`, a</span>
<span class="sd">        `pandas.DataFrame` or a structured numpy array.</span>


<span class="sd">        **Plotting multiple sets of data**</span>

<span class="sd">        There are various ways to plot multiple sets of data.</span>

<span class="sd">        - The most straight forward way is just to call `plot` multiple times.</span>
<span class="sd">          Example:</span>

<span class="sd">          &gt;&gt;&gt; plot(x1, y1, &#39;bo&#39;)</span>
<span class="sd">          &gt;&gt;&gt; plot(x2, y2, &#39;go&#39;)</span>

<span class="sd">        - If *x* and/or *y* are 2D arrays a separate data set will be drawn</span>
<span class="sd">          for every column. If both *x* and *y* are 2D, they must have the</span>
<span class="sd">          same shape. If only one of them is 2D with shape (N, m) the other</span>
<span class="sd">          must have length N and will be used for every data set m.</span>

<span class="sd">          Example:</span>

<span class="sd">          &gt;&gt;&gt; x = [1, 2, 3]</span>
<span class="sd">          &gt;&gt;&gt; y = np.array([[1, 2], [3, 4], [5, 6]])</span>
<span class="sd">          &gt;&gt;&gt; plot(x, y)</span>

<span class="sd">          is equivalent to:</span>

<span class="sd">          &gt;&gt;&gt; for col in range(y.shape[1]):</span>
<span class="sd">          ...     plot(x, y[:, col])</span>

<span class="sd">        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*</span>
<span class="sd">          groups::</span>

<span class="sd">          &gt;&gt;&gt; plot(x1, y1, &#39;g^&#39;, x2, y2, &#39;g-&#39;)</span>

<span class="sd">          In this case, any additional keyword argument applies to all</span>
<span class="sd">          datasets. Also this syntax cannot be combined with the *data*</span>
<span class="sd">          parameter.</span>

<span class="sd">        By default, each line is assigned a different style specified by a</span>
<span class="sd">        &#39;style cycle&#39;. The *fmt* and line property parameters are only</span>
<span class="sd">        necessary if you want explicit deviations from these defaults.</span>
<span class="sd">        Alternatively, you can also change the style cycle using</span>
<span class="sd">        :rc:`axes.prop_cycle`.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like or scalar</span>
<span class="sd">            The horizontal / vertical coordinates of the data points.</span>
<span class="sd">            *x* values are optional and default to ``range(len(y))``.</span>

<span class="sd">            Commonly, these parameters are 1D arrays.</span>

<span class="sd">            They can also be scalars, or two-dimensional (in that case, the</span>
<span class="sd">            columns represent separate data sets).</span>

<span class="sd">            These arguments cannot be passed as keywords.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            A format string, e.g. &#39;ro&#39; for red circles. See the *Notes*</span>
<span class="sd">            section for a full description of the format strings.</span>

<span class="sd">            Format strings are just an abbreviation for quickly setting</span>
<span class="sd">            basic line properties. All of these and more can also be</span>
<span class="sd">            controlled by keyword arguments.</span>

<span class="sd">            This argument cannot be passed as keyword.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*.</span>

<span class="sd">            .. note::</span>
<span class="sd">                Technically there&#39;s a slight ambiguity in calls where the</span>
<span class="sd">                second label is a valid *fmt*. ``plot(&#39;n&#39;, &#39;o&#39;, data=obj)``</span>
<span class="sd">                could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,</span>
<span class="sd">                the former interpretation is chosen, but a warning is issued.</span>
<span class="sd">                You may suppress the warning by adding an empty format string</span>
<span class="sd">                ``plot(&#39;n&#39;, &#39;o&#39;, &#39;&#39;, data=obj)``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.Line2D`</span>
<span class="sd">            A list of lines representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        scalex, scaley : bool, default: True</span>
<span class="sd">            These parameters determine if the view limits are adapted to the</span>
<span class="sd">            data limits. The values are passed on to</span>
<span class="sd">            `~.axes.Axes.autoscale_view`.</span>

<span class="sd">        **kwargs : `.Line2D` properties, optional</span>
<span class="sd">            *kwargs* are used to specify properties like a line label (for</span>
<span class="sd">            auto legends), linewidth, antialiasing, marker face color.</span>
<span class="sd">            Example::</span>

<span class="sd">            &gt;&gt;&gt; plot([1, 2, 3], [1, 2, 3], &#39;go-&#39;, label=&#39;line 1&#39;, linewidth=2)</span>
<span class="sd">            &gt;&gt;&gt; plot([1, 2, 3], [1, 4, 9], &#39;rs&#39;, label=&#39;line 2&#39;)</span>

<span class="sd">            If you specify multiple lines with one plot call, the kwargs apply</span>
<span class="sd">            to all those lines. In case the label object is iterable, each</span>
<span class="sd">            element is used as labels for each set of data.</span>

<span class="sd">            Here is a list of available `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scatter : XY scatter plot with markers of varying size and/or color (</span>
<span class="sd">            sometimes also called bubble chart).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Format Strings**</span>

<span class="sd">        A format string consists of a part for color, marker and line::</span>

<span class="sd">            fmt = &#39;[marker][line][color]&#39;</span>

<span class="sd">        Each of them is optional. If not provided, the value from the style</span>
<span class="sd">        cycle is used. Exception: If ``line`` is given, but no ``marker``,</span>
<span class="sd">        the data will be a line without markers.</span>

<span class="sd">        Other combinations such as ``[color][marker][line]`` are also</span>
<span class="sd">        supported, but note that their parsing may be ambiguous.</span>

<span class="sd">        **Markers**</span>

<span class="sd">        =============   ===============================</span>
<span class="sd">        character       description</span>
<span class="sd">        =============   ===============================</span>
<span class="sd">        ``&#39;.&#39;``         point marker</span>
<span class="sd">        ``&#39;,&#39;``         pixel marker</span>
<span class="sd">        ``&#39;o&#39;``         circle marker</span>
<span class="sd">        ``&#39;v&#39;``         triangle_down marker</span>
<span class="sd">        ``&#39;^&#39;``         triangle_up marker</span>
<span class="sd">        ``&#39;&lt;&#39;``         triangle_left marker</span>
<span class="sd">        ``&#39;&gt;&#39;``         triangle_right marker</span>
<span class="sd">        ``&#39;1&#39;``         tri_down marker</span>
<span class="sd">        ``&#39;2&#39;``         tri_up marker</span>
<span class="sd">        ``&#39;3&#39;``         tri_left marker</span>
<span class="sd">        ``&#39;4&#39;``         tri_right marker</span>
<span class="sd">        ``&#39;8&#39;``         octagon marker</span>
<span class="sd">        ``&#39;s&#39;``         square marker</span>
<span class="sd">        ``&#39;p&#39;``         pentagon marker</span>
<span class="sd">        ``&#39;P&#39;``         plus (filled) marker</span>
<span class="sd">        ``&#39;*&#39;``         star marker</span>
<span class="sd">        ``&#39;h&#39;``         hexagon1 marker</span>
<span class="sd">        ``&#39;H&#39;``         hexagon2 marker</span>
<span class="sd">        ``&#39;+&#39;``         plus marker</span>
<span class="sd">        ``&#39;x&#39;``         x marker</span>
<span class="sd">        ``&#39;X&#39;``         x (filled) marker</span>
<span class="sd">        ``&#39;D&#39;``         diamond marker</span>
<span class="sd">        ``&#39;d&#39;``         thin_diamond marker</span>
<span class="sd">        ``&#39;|&#39;``         vline marker</span>
<span class="sd">        ``&#39;_&#39;``         hline marker</span>
<span class="sd">        =============   ===============================</span>

<span class="sd">        **Line Styles**</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        description</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``&#39;-&#39;``          solid line style</span>
<span class="sd">        ``&#39;--&#39;``         dashed line style</span>
<span class="sd">        ``&#39;-.&#39;``         dash-dot line style</span>
<span class="sd">        ``&#39;:&#39;``          dotted line style</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        Example format strings::</span>

<span class="sd">            &#39;b&#39;    # blue markers with default shape</span>
<span class="sd">            &#39;or&#39;   # red circles</span>
<span class="sd">            &#39;-g&#39;   # green solid line</span>
<span class="sd">            &#39;--&#39;   # dashed line with default color</span>
<span class="sd">            &#39;^k:&#39;  # black triangle_up markers connected by a dotted line</span>

<span class="sd">        **Colors**</span>

<span class="sd">        The supported color abbreviations are the single letter codes</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        color</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``&#39;b&#39;``          blue</span>
<span class="sd">        ``&#39;g&#39;``          green</span>
<span class="sd">        ``&#39;r&#39;``          red</span>
<span class="sd">        ``&#39;c&#39;``          cyan</span>
<span class="sd">        ``&#39;m&#39;``          magenta</span>
<span class="sd">        ``&#39;y&#39;``          yellow</span>
<span class="sd">        ``&#39;k&#39;``          black</span>
<span class="sd">        ``&#39;w&#39;``          white</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        and the ``&#39;CN&#39;`` colors that index into the default property cycle.</span>

<span class="sd">        If the color is the only part of the format string, you can</span>
<span class="sd">        additionally use any  `matplotlib.colors` spec, e.g. full names</span>
<span class="sd">        (``&#39;green&#39;``) or hex strings (``&#39;#008000&#39;``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scaley</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="Axes.plot_date"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.plot_date">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">plot_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xdate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ydate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [*Discouraged*] Plot coercing the axis to treat floats as dates.</span>

<span class="sd">        .. admonition:: Discouraged</span>

<span class="sd">            This method exists for historic reasons and will be deprecated in</span>
<span class="sd">            the future.</span>

<span class="sd">            - ``datetime``-like data should directly be plotted using</span>
<span class="sd">              `~.Axes.plot`.</span>
<span class="sd">            -  If you need to plot plain numeric data as :ref:`date-format` or</span>
<span class="sd">               need to set a timezone, call ``ax.xaxis.axis_date`` /</span>
<span class="sd">               ``ax.yaxis.axis_date`` before `~.Axes.plot`. See</span>
<span class="sd">               `.Axis.axis_date`.</span>

<span class="sd">        Similar to `.plot`, this plots *y* vs. *x* as lines or markers.</span>
<span class="sd">        However, the axis labels are formatted as dates depending on *xdate*</span>
<span class="sd">        and *ydate*.  Note that `.plot` will work with `datetime` and</span>
<span class="sd">        `numpy.datetime64` objects without resorting to this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like</span>
<span class="sd">            The coordinates of the data points. If *xdate* or *ydate* is</span>
<span class="sd">            *True*, the respective values *x* or *y* are interpreted as</span>
<span class="sd">            :ref:`Matplotlib dates &lt;date-format&gt;`.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            The plot format string. For details, see the corresponding</span>
<span class="sd">            parameter in `.plot`.</span>

<span class="sd">        tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            The time zone to use in labeling dates.</span>

<span class="sd">        xdate : bool, default: True</span>
<span class="sd">            If *True*, the *x*-axis will be interpreted as Matplotlib dates.</span>

<span class="sd">        ydate : bool, default: False</span>
<span class="sd">            If *True*, the *y*-axis will be interpreted as Matplotlib dates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.Line2D`</span>
<span class="sd">            Objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        matplotlib.dates : Helper functions on dates.</span>
<span class="sd">        matplotlib.dates.date2num : Convert dates to num.</span>
<span class="sd">        matplotlib.dates.num2date : Convert num to dates.</span>
<span class="sd">        matplotlib.dates.drange : Create an equally spaced sequence of dates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you are using custom date tickers and formatters, it may be</span>
<span class="sd">        necessary to set the formatters/locators after the call to</span>
<span class="sd">        `.plot_date`. `.plot_date` will set the default tick locator to</span>
<span class="sd">        `.AutoDateLocator` (if the tick locator is not already set to a</span>
<span class="sd">        `.DateLocator` instance) and the default tick formatter to</span>
<span class="sd">        `.AutoDateFormatter` (if the tick formatter is not already set to a</span>
<span class="sd">        `.DateFormatter` instance).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xdate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ydate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
<div class="viewcode-block" id="Axes.loglog"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.loglog">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">loglog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on both the x and y axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            loglog([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        both the x-axis and the y-axis to log scaling. All of the concepts and</span>
<span class="sd">        parameters of plot can be used here as well.</span>

<span class="sd">        The additional parameters *base*, *subs* and *nonpositive* control the</span>
<span class="sd">        x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and</span>
<span class="sd">        `.Axes.set_yscale`. To use different properties on the x-axis and the</span>
<span class="sd">        y-axis, use e.g.</span>
<span class="sd">        ``ax.set_xscale(&quot;log&quot;, base=10); ax.set_yscale(&quot;log&quot;, base=2)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : float, default: 10</span>
<span class="sd">            Base of the logarithm.</span>

<span class="sd">        subs : sequence, optional</span>
<span class="sd">            The location of the minor ticks. If *None*, reasonable locations</span>
<span class="sd">            are automatically chosen depending on the number of decades in the</span>
<span class="sd">            plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.</span>

<span class="sd">        nonpositive : {&#39;mask&#39;, &#39;clip&#39;}, default: &#39;mask&#39;</span>
<span class="sd">            Non-positive values can be masked as invalid, or clipped to a very</span>
<span class="sd">            small positive number.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.Line2D`</span>
<span class="sd">            Objects representing the plotted data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
              <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">,</span> <span class="s1">&#39;subs&#39;</span><span class="p">,</span> <span class="s1">&#39;nonpositive&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;basex&#39;</span><span class="p">,</span> <span class="s1">&#39;subsx&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposx&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
              <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">,</span> <span class="s1">&#39;subs&#39;</span><span class="p">,</span> <span class="s1">&#39;nonpositive&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;basey&#39;</span><span class="p">,</span> <span class="s1">&#39;subsy&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposy&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">dy</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="o">*</span><span class="n">dy</span><span class="p">}})</span></div>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
<div class="viewcode-block" id="Axes.semilogx"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.semilogx">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">semilogx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on the x axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            semilogx([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        the x-axis to log scaling. All of the concepts and parameters of plot</span>
<span class="sd">        can be used here as well.</span>

<span class="sd">        The additional parameters *base*, *subs*, and *nonpositive* control the</span>
<span class="sd">        x-axis properties. They are just forwarded to `.Axes.set_xscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : float, default: 10</span>
<span class="sd">            Base of the x logarithm.</span>

<span class="sd">        subs : array-like, optional</span>
<span class="sd">            The location of the minor xticks. If *None*, reasonable locations</span>
<span class="sd">            are automatically chosen depending on the number of decades in the</span>
<span class="sd">            plot. See `.Axes.set_xscale` for details.</span>

<span class="sd">        nonpositive : {&#39;mask&#39;, &#39;clip&#39;}, default: &#39;mask&#39;</span>
<span class="sd">            Non-positive values in x can be masked as invalid, or clipped to a</span>
<span class="sd">            very small positive number.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.Line2D`</span>
<span class="sd">            Objects representing the plotted data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
             <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">,</span> <span class="s1">&#39;subs&#39;</span><span class="p">,</span> <span class="s1">&#39;nonpositive&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;basex&#39;</span><span class="p">,</span> <span class="s1">&#39;subsx&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposx&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">})</span></div>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
<div class="viewcode-block" id="Axes.semilogy"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.semilogy">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">semilogy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on the y axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            semilogy([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        the y-axis to log scaling. All of the concepts and parameters of plot</span>
<span class="sd">        can be used here as well.</span>

<span class="sd">        The additional parameters *base*, *subs*, and *nonpositive* control the</span>
<span class="sd">        y-axis properties. They are just forwarded to `.Axes.set_yscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : float, default: 10</span>
<span class="sd">            Base of the y logarithm.</span>

<span class="sd">        subs : array-like, optional</span>
<span class="sd">            The location of the minor yticks. If *None*, reasonable locations</span>
<span class="sd">            are automatically chosen depending on the number of decades in the</span>
<span class="sd">            plot. See `.Axes.set_yscale` for details.</span>

<span class="sd">        nonpositive : {&#39;mask&#39;, &#39;clip&#39;}, default: &#39;mask&#39;</span>
<span class="sd">            Non-positive values in y can be masked as invalid, or clipped to a</span>
<span class="sd">            very small positive number.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.Line2D`</span>
<span class="sd">            Objects representing the plotted data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
             <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">,</span> <span class="s1">&#39;subs&#39;</span><span class="p">,</span> <span class="s1">&#39;nonpositive&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;basey&#39;</span><span class="p">,</span> <span class="s1">&#39;subsy&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposy&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">})</span></div>

<div class="viewcode-block" id="Axes.acorr"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.acorr">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the autocorrelation of *x*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>

<span class="sd">        detrend : callable, default: `.mlab.detrend_none` (no detrending)</span>
<span class="sd">            A detrending function applied to *x*.  It must have the</span>
<span class="sd">            signature ::</span>

<span class="sd">                detrend(x: np.ndarray) -&gt; np.ndarray</span>

<span class="sd">        normed : bool, default: True</span>
<span class="sd">            If ``True``, input vectors are normalised to unit length.</span>

<span class="sd">        usevlines : bool, default: True</span>
<span class="sd">            Determines the plot style.</span>

<span class="sd">            If ``True``, vertical lines are plotted from 0 to the acorr value</span>
<span class="sd">            using `.Axes.vlines`. Additionally, a horizontal line is plotted</span>
<span class="sd">            at y=0 using `.Axes.axhline`.</span>

<span class="sd">            If ``False``, markers are plotted at the acorr values using</span>
<span class="sd">            `.Axes.plot`.</span>

<span class="sd">        maxlags : int, default: 10</span>
<span class="sd">            Number of lags to show. If ``None``, will return all</span>
<span class="sd">            ``2 * len(x) - 1`` lags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags : array (length ``2*maxlags+1``)</span>
<span class="sd">            The lag vector.</span>
<span class="sd">        c : array  (length ``2*maxlags+1``)</span>
<span class="sd">            The auto correlation vector.</span>
<span class="sd">        line : `.LineCollection` or `.Line2D`</span>
<span class="sd">            `.Artist` added to the Axes of the correlation:</span>

<span class="sd">            - `.LineCollection` if *usevlines* is True.</span>
<span class="sd">            - `.Line2D` if *usevlines* is False.</span>
<span class="sd">        b : `.Line2D` or None</span>
<span class="sd">            Horizontal line at 0 if *usevlines* is True</span>
<span class="sd">            None *usevlines* is False.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        linestyle : `.Line2D` property, optional</span>
<span class="sd">            The linestyle for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        marker : str, default: &#39;o&#39;</span>
<span class="sd">            The marker for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional parameters are passed to `.Axes.vlines` and</span>
<span class="sd">            `.Axes.axhline` if *usevlines* is ``True``; otherwise they are</span>
<span class="sd">            passed to `.Axes.plot`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with `numpy.correlate` with</span>
<span class="sd">        ``mode = &quot;full&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.xcorr"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.xcorr">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
              <span class="n">usevlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxlags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the cross correlation between *x* and *y*.</span>

<span class="sd">        The correlation with lag k is defined as</span>
<span class="sd">        :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex</span>
<span class="sd">        conjugate of :math:`y`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like of length n</span>

<span class="sd">        detrend : callable, default: `.mlab.detrend_none` (no detrending)</span>
<span class="sd">            A detrending function applied to *x* and *y*.  It must have the</span>
<span class="sd">            signature ::</span>

<span class="sd">                detrend(x: np.ndarray) -&gt; np.ndarray</span>

<span class="sd">        normed : bool, default: True</span>
<span class="sd">            If ``True``, input vectors are normalised to unit length.</span>

<span class="sd">        usevlines : bool, default: True</span>
<span class="sd">            Determines the plot style.</span>

<span class="sd">            If ``True``, vertical lines are plotted from 0 to the xcorr value</span>
<span class="sd">            using `.Axes.vlines`. Additionally, a horizontal line is plotted</span>
<span class="sd">            at y=0 using `.Axes.axhline`.</span>

<span class="sd">            If ``False``, markers are plotted at the xcorr values using</span>
<span class="sd">            `.Axes.plot`.</span>

<span class="sd">        maxlags : int, default: 10</span>
<span class="sd">            Number of lags to show. If None, will return all ``2 * len(x) - 1``</span>
<span class="sd">            lags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags : array (length ``2*maxlags+1``)</span>
<span class="sd">            The lag vector.</span>
<span class="sd">        c : array  (length ``2*maxlags+1``)</span>
<span class="sd">            The auto correlation vector.</span>
<span class="sd">        line : `.LineCollection` or `.Line2D`</span>
<span class="sd">            `.Artist` added to the Axes of the correlation:</span>

<span class="sd">            - `.LineCollection` if *usevlines* is True.</span>
<span class="sd">            - `.Line2D` if *usevlines* is False.</span>
<span class="sd">        b : `.Line2D` or None</span>
<span class="sd">            Horizontal line at 0 if *usevlines* is True</span>
<span class="sd">            None *usevlines* is False.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        linestyle : `.Line2D` property, optional</span>
<span class="sd">            The linestyle for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        marker : str, default: &#39;o&#39;</span>
<span class="sd">            The marker for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional parameters are passed to `.Axes.vlines` and</span>
<span class="sd">            `.Axes.axhline` if *usevlines* is ``True``; otherwise they are</span>
<span class="sd">            passed to `.Axes.plot`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with `numpy.correlate` with</span>
<span class="sd">        ``mode = &quot;full&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nx</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x and y must be equal length&#39;</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">correls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
            <span class="n">correls</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxlags</span> <span class="o">=</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="o">&gt;=</span> <span class="n">Nx</span> <span class="ow">or</span> <span class="n">maxlags</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;maxlags must be None or strictly &#39;</span>
                             <span class="s1">&#39;positive &lt; </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Nx</span><span class="p">)</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxlags</span><span class="p">,</span> <span class="n">maxlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">correls</span> <span class="o">=</span> <span class="n">correls</span><span class="p">[</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlags</span><span class="p">:</span><span class="n">Nx</span> <span class="o">+</span> <span class="n">maxlags</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">usevlines</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">correls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Make label empty so only vertical lines get a legend entry</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">correls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">lags</span><span class="p">,</span> <span class="n">correls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>

    <span class="c1">#### Specialized plotting</span>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
<div class="viewcode-block" id="Axes.step"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a step plot.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            step(x, y, [fmt], *, data=None, where=&#39;pre&#39;, **kwargs)</span>
<span class="sd">            step(x, y, [fmt], x2, y2, [fmt2], ..., *, where=&#39;pre&#39;, **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which changes some</span>
<span class="sd">        formatting options. Most of the concepts and parameters of plot can be</span>
<span class="sd">        used here as well.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This method uses a standard plot with a step drawstyle: The *x*</span>
<span class="sd">            values are the reference positions and steps extend left/right/both</span>
<span class="sd">            directions depending on *where*.</span>

<span class="sd">            For the common case where you know the values and edges of the</span>
<span class="sd">            steps, use `~.Axes.stairs` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            1D sequence of x positions. It is assumed, but not checked, that</span>
<span class="sd">            it is uniformly increasing.</span>

<span class="sd">        y : array-like</span>
<span class="sd">            1D sequence of y levels.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            A format string, e.g. &#39;g&#39; for a green line. See `.plot` for a more</span>
<span class="sd">            detailed description.</span>

<span class="sd">            Note: While full format strings are accepted, it is recommended to</span>
<span class="sd">            only specify the color. Line styles are currently ignored (use</span>
<span class="sd">            the keyword argument *linestyle* instead). Markers are accepted</span>
<span class="sd">            and plotted on the given positions, however, this is a rarely</span>
<span class="sd">            needed feature for step plots.</span>

<span class="sd">        where : {&#39;pre&#39;, &#39;post&#39;, &#39;mid&#39;}, default: &#39;pre&#39;</span>
<span class="sd">            Define where the steps should be placed:</span>

<span class="sd">            - &#39;pre&#39;: The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;post&#39;: The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;mid&#39;: Steps occur half-way between the *x* positions.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional parameters are the same as those for `.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.Line2D`</span>
<span class="sd">            Objects representing the plotted data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">((</span><span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="s1">&#39;mid&#39;</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;drawstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;steps-&#39;</span> <span class="o">+</span> <span class="n">where</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_dx</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">xconv</span><span class="p">,</span> <span class="n">convert</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small helper to do logic of width conversion flexibly.</span>

<span class="sd">        *dx* and *x0* have units, but *xconv* has already been converted</span>
<span class="sd">        to unitless (and is an ndarray).  This allows the *dx* to have units</span>
<span class="sd">        that are different from *x0*, but are still accepted by the</span>
<span class="sd">        ``__add__`` operator of *x0*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># x should be an array...</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">xconv</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

        <span class="k">if</span> <span class="n">xconv</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># xconv has already been converted, but maybe empty...</span>
            <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># attempt to add the width to x0; this works for</span>
            <span class="c1"># datetime+timedelta, for instance</span>

            <span class="c1"># only use the first element of x and x0.  This saves</span>
            <span class="c1"># having to be sure addition works across the whole</span>
            <span class="c1"># vector.  This is particularly an issue if</span>
            <span class="c1"># x0 and dx are lists so x0 + dx just concatenates the lists.</span>
            <span class="c1"># We can&#39;t just cast x0 and dx to numpy arrays because that</span>
            <span class="c1"># removes the units from unit packages like `pint` that</span>
            <span class="c1"># wrap numpy arrays.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># this means we found no finite element, fall back to first</span>
                <span class="c1"># element unconditionally</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">xconv</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xconv</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># this means we found no finite element, fall back to first</span>
                <span class="c1"># element unconditionally</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">xconv</span><span class="p">)</span>

            <span class="n">delist</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">dx</span><span class="p">):</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="n">dx</span><span class="p">]</span>
                <span class="n">delist</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">ddx</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="k">for</span> <span class="n">ddx</span> <span class="ow">in</span> <span class="n">dx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">delist</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="c1"># if the above fails (for any reason) just fallback to what</span>
            <span class="c1"># we do by default and convert dx by itself.</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dx</span>

<div class="viewcode-block" id="Axes.bar"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.bar">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a bar plot.</span>

<span class="sd">        The bars are positioned at *x* with the given *align*\ment. Their</span>
<span class="sd">        dimensions are given by *height* and *width*. The vertical baseline</span>
<span class="sd">        is *bottom* (default 0).</span>

<span class="sd">        Many parameters can take either a single value applying to all bars</span>
<span class="sd">        or a sequence of values, one for each bar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float or array-like</span>
<span class="sd">            The x coordinates of the bars. See also *align* for the</span>
<span class="sd">            alignment of the bars to the coordinates.</span>

<span class="sd">        height : float or array-like</span>
<span class="sd">            The height(s) of the bars.</span>

<span class="sd">        width : float or array-like, default: 0.8</span>
<span class="sd">            The width(s) of the bars.</span>

<span class="sd">        bottom : float or array-like, default: 0</span>
<span class="sd">            The y coordinate(s) of the bottom side(s) of the bars.</span>

<span class="sd">        align : {&#39;center&#39;, &#39;edge&#39;}, default: &#39;center&#39;</span>
<span class="sd">            Alignment of the bars to the *x* coordinates:</span>

<span class="sd">            - &#39;center&#39;: Center the base on the *x* positions.</span>
<span class="sd">            - &#39;edge&#39;: Align the left edges of the bars with the *x* positions.</span>

<span class="sd">            To align the bars on the right edge pass a negative *width* and</span>
<span class="sd">            ``align=&#39;edge&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.BarContainer`</span>
<span class="sd">            Container with all the bars and optionally errorbars.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        color : color or list of color, optional</span>
<span class="sd">            The colors of the bar faces.</span>

<span class="sd">        edgecolor : color or list of color, optional</span>
<span class="sd">            The colors of the bar edges.</span>

<span class="sd">        linewidth : float or array-like, optional</span>
<span class="sd">            Width of the bar edge(s). If 0, don&#39;t draw edges.</span>

<span class="sd">        tick_label : str or list of str, optional</span>
<span class="sd">            The tick labels of the bars.</span>
<span class="sd">            Default: None (Use default numeric labels.)</span>

<span class="sd">        label : str or list of str, optional</span>
<span class="sd">            A single label is attached to the resulting `.BarContainer` as a</span>
<span class="sd">            label for the whole dataset.</span>
<span class="sd">            If a list is provided, it must be the same length as *x* and</span>
<span class="sd">            labels the individual bars. Repeated labels are not de-duplicated</span>
<span class="sd">            and will cause repeated label entries, so this is best used when</span>
<span class="sd">            bars also differ in style (e.g., by passing a list to *color*.)</span>

<span class="sd">        xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional</span>
<span class="sd">            If not *None*, add horizontal / vertical errorbars to the bar tips.</span>
<span class="sd">            The values are +/- sizes relative to the data:</span>

<span class="sd">            - scalar: symmetric +/- values for all bars</span>
<span class="sd">            - shape(N,): symmetric +/- values for each bar</span>
<span class="sd">            - shape(2, N): Separate - and + values for each bar. First row</span>
<span class="sd">              contains the lower errors, the second row contains the upper</span>
<span class="sd">              errors.</span>
<span class="sd">            - *None*: No errorbar. (Default)</span>

<span class="sd">            See :doc:`/gallery/statistics/errorbar_features` for an example on</span>
<span class="sd">            the usage of *xerr* and *yerr*.</span>

<span class="sd">        ecolor : color or list of color, default: &#39;black&#39;</span>
<span class="sd">            The line color of the errorbars.</span>

<span class="sd">        capsize : float, default: :rc:`errorbar.capsize`</span>
<span class="sd">           The length of the error bar caps in points.</span>

<span class="sd">        error_kw : dict, optional</span>
<span class="sd">            Dictionary of keyword arguments to be passed to the</span>
<span class="sd">            `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined</span>
<span class="sd">            here take precedence over the independent keyword arguments.</span>

<span class="sd">        log : bool, default: False</span>
<span class="sd">            If *True*, set the y-axis to be log scale.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs : `.Rectangle` properties</span>

<span class="sd">        %(Rectangle:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        barh : Plot a horizontal bar plot.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Stacked bars can be achieved by passing individual *bottom* values per</span>
<span class="sd">        bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>
        <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">hatch</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hatch&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Because xerr and yerr will be passed to errorbar, most dimension</span>
        <span class="c1"># checking and processing will be left to the errorbar method.</span>
        <span class="n">xerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xerr&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">yerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;yerr&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">error_kw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;error_kw&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">ezorder</span> <span class="o">=</span> <span class="n">error_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ezorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ezorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ezorder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If using the bar zorder, increment slightly to make sure</span>
                <span class="c1"># errorbars are drawn on top of bars</span>
                <span class="n">ezorder</span> <span class="o">+=</span> <span class="mf">0.01</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="n">ezorder</span><span class="p">)</span>
        <span class="n">ecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ecolor&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="n">capsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;capsize&#39;</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;errorbar.capsize&quot;</span><span class="p">])</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ecolor&#39;</span><span class="p">,</span> <span class="n">ecolor</span><span class="p">)</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;capsize&#39;</span><span class="p">,</span> <span class="n">capsize</span><span class="p">)</span>

        <span class="c1"># The keyword argument *orientation* is used by barh() to defer all</span>
        <span class="c1"># logic and drawing to bar(). It is considered internal and is</span>
        <span class="c1"># intentionally not mentioned in the docstring.</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;orientation&#39;</span><span class="p">,</span> <span class="s1">&#39;vertical&#39;</span><span class="p">)</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">],</span> <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">)</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tick_label&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">bottom</span>  <span class="c1"># Matches barh call signature.</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
                <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">height</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonpositive</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
                <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonpositive</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>

        <span class="c1"># lets do some conversions now since some types cannot be</span>
        <span class="c1"># subtracted uniformly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">xerr</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">hatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span>
            <span class="c1"># Make args iterable too.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">hatch</span><span class="p">)</span>

        <span class="c1"># Now that units have been converted, set the tick locations.</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">y</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">bar_container_label</span> <span class="o">=</span> <span class="s1">&#39;_nolegend_&#39;</span>
            <span class="n">patch_labels</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bar_container_label</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">patch_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">patch_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;number of labels (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">patch_labels</span><span class="p">)</span><span class="si">}</span><span class="s1">) &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;does not match number of bars (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>

        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">linewidth</span><span class="p">))</span>
        <span class="n">hatch</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">hatch</span><span class="p">))</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">)),</span>
                                <span class="c1"># Fallback if color == &quot;none&quot;.</span>
                                <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">edgecolor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">edgecolor</span><span class="p">)),</span>
                <span class="c1"># Fallback if edgecolor == &quot;none&quot;.</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">))</span>

        <span class="c1"># We will now resolve the alignment and really have</span>
        <span class="c1"># left, bottom, width, height vectors</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">],</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;the dtypes of parameters x (</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;and width (</span><span class="si">{</span><span class="n">width</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;are incompatible&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;the dtypes of parameters y (</span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;and height (</span><span class="si">{</span><span class="n">height</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;are incompatible&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># edge</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span>
                   <span class="n">hatch</span><span class="p">,</span> <span class="n">patch_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">htch</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                <span class="n">edgecolor</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">lbl</span><span class="p">,</span>
                <span class="n">hatch</span><span class="o">=</span><span class="n">htch</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">_interpolation_steps</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                <span class="n">r</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>

            <span class="n">errorbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span>
                                     <span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="n">xerr</span><span class="p">,</span>
                                     <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">error_kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errorbar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="n">datavalues</span> <span class="o">=</span> <span class="n">height</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
            <span class="n">datavalues</span> <span class="o">=</span> <span class="n">width</span>

        <span class="n">bar_container</span> <span class="o">=</span> <span class="n">BarContainer</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">errorbar</span><span class="p">,</span> <span class="n">datavalues</span><span class="o">=</span><span class="n">datavalues</span><span class="p">,</span>
                                     <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                                     <span class="n">label</span><span class="o">=</span><span class="n">bar_container_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">bar_container</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tick_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">patches</span><span class="p">))</span>
            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">tick_label_position</span><span class="p">)</span>
            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bar_container</span></div>

    <span class="c1"># @_preprocess_data() # let &#39;bar&#39; do the unpacking..</span>
<div class="viewcode-block" id="Axes.barh"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.barh">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
             <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a horizontal bar plot.</span>

<span class="sd">        The bars are positioned at *y* with the given *align*\ment. Their</span>
<span class="sd">        dimensions are given by *width* and *height*. The horizontal baseline</span>
<span class="sd">        is *left* (default 0).</span>

<span class="sd">        Many parameters can take either a single value applying to all bars</span>
<span class="sd">        or a sequence of values, one for each bar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : float or array-like</span>
<span class="sd">            The y coordinates of the bars. See also *align* for the</span>
<span class="sd">            alignment of the bars to the coordinates.</span>

<span class="sd">        width : float or array-like</span>
<span class="sd">            The width(s) of the bars.</span>

<span class="sd">        height : float or array-like, default: 0.8</span>
<span class="sd">            The heights of the bars.</span>

<span class="sd">        left : float or array-like, default: 0</span>
<span class="sd">            The x coordinates of the left side(s) of the bars.</span>

<span class="sd">        align : {&#39;center&#39;, &#39;edge&#39;}, default: &#39;center&#39;</span>
<span class="sd">            Alignment of the base to the *y* coordinates*:</span>

<span class="sd">            - &#39;center&#39;: Center the bars on the *y* positions.</span>
<span class="sd">            - &#39;edge&#39;: Align the bottom edges of the bars with the *y*</span>
<span class="sd">              positions.</span>

<span class="sd">            To align the bars on the top edge pass a negative *height* and</span>
<span class="sd">            ``align=&#39;edge&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.BarContainer`</span>
<span class="sd">            Container with all the bars and optionally errorbars.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        color : color or list of color, optional</span>
<span class="sd">            The colors of the bar faces.</span>

<span class="sd">        edgecolor : color or list of color, optional</span>
<span class="sd">            The colors of the bar edges.</span>

<span class="sd">        linewidth : float or array-like, optional</span>
<span class="sd">            Width of the bar edge(s). If 0, don&#39;t draw edges.</span>

<span class="sd">        tick_label : str or list of str, optional</span>
<span class="sd">            The tick labels of the bars.</span>
<span class="sd">            Default: None (Use default numeric labels.)</span>

<span class="sd">        label : str or list of str, optional</span>
<span class="sd">            A single label is attached to the resulting `.BarContainer` as a</span>
<span class="sd">            label for the whole dataset.</span>
<span class="sd">            If a list is provided, it must be the same length as *y* and</span>
<span class="sd">            labels the individual bars. Repeated labels are not de-duplicated</span>
<span class="sd">            and will cause repeated label entries, so this is best used when</span>
<span class="sd">            bars also differ in style (e.g., by passing a list to *color*.)</span>

<span class="sd">        xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional</span>
<span class="sd">            If not *None*, add horizontal / vertical errorbars to the bar tips.</span>
<span class="sd">            The values are +/- sizes relative to the data:</span>

<span class="sd">            - scalar: symmetric +/- values for all bars</span>
<span class="sd">            - shape(N,): symmetric +/- values for each bar</span>
<span class="sd">            - shape(2, N): Separate - and + values for each bar. First row</span>
<span class="sd">              contains the lower errors, the second row contains the upper</span>
<span class="sd">              errors.</span>
<span class="sd">            - *None*: No errorbar. (default)</span>

<span class="sd">            See :doc:`/gallery/statistics/errorbar_features` for an example on</span>
<span class="sd">            the usage of *xerr* and *yerr*.</span>

<span class="sd">        ecolor : color or list of color, default: &#39;black&#39;</span>
<span class="sd">            The line color of the errorbars.</span>

<span class="sd">        capsize : float, default: :rc:`errorbar.capsize`</span>
<span class="sd">           The length of the error bar caps in points.</span>

<span class="sd">        error_kw : dict, optional</span>
<span class="sd">            Dictionary of keyword arguments to be passed to the</span>
<span class="sd">            `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined</span>
<span class="sd">            here take precedence over the independent keyword arguments.</span>

<span class="sd">        log : bool, default: False</span>
<span class="sd">            If ``True``, set the x-axis to be log scale.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            If given, all parameters also accept a string ``s``, which is</span>
<span class="sd">            interpreted as ``data[s]`` (unless this raises an exception).</span>

<span class="sd">        **kwargs : `.Rectangle` properties</span>

<span class="sd">        %(Rectangle:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        bar : Plot a vertical bar plot.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Stacked bars can be achieved by passing individual *left* values per</span>
<span class="sd">        bar. See</span>
<span class="sd">        :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;orientation&#39;</span><span class="p">,</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                           <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">patches</span></div>

<div class="viewcode-block" id="Axes.bar_label"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.bar_label">[docs]</a>    <span class="k">def</span> <span class="nf">bar_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">label_type</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span>
                  <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Label a bar plot.</span>

<span class="sd">        Adds labels to bars in the given `.BarContainer`.</span>
<span class="sd">        You may need to adjust the axis limits to fit the labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        container : `.BarContainer`</span>
<span class="sd">            Container with all the bars and optionally errorbars, likely</span>
<span class="sd">            returned from `.bar` or `.barh`.</span>

<span class="sd">        labels : array-like, optional</span>
<span class="sd">            A list of label texts, that should be displayed. If not given, the</span>
<span class="sd">            label texts will be the data values formatted with *fmt*.</span>

<span class="sd">        fmt : str, default: &#39;%g&#39;</span>
<span class="sd">            A format string for the label.</span>

<span class="sd">        label_type : {&#39;edge&#39;, &#39;center&#39;}, default: &#39;edge&#39;</span>
<span class="sd">            The label type. Possible values:</span>

<span class="sd">            - &#39;edge&#39;: label placed at the end-point of the bar segment, and the</span>
<span class="sd">              value displayed will be the position of that end-point.</span>
<span class="sd">            - &#39;center&#39;: label placed in the center of the bar segment, and the</span>
<span class="sd">              value displayed will be the length of that segment.</span>
<span class="sd">              (useful for stacked bars, i.e.,</span>
<span class="sd">              :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)</span>

<span class="sd">        padding : float, default: 0</span>
<span class="sd">            Distance of label from the end of the bar, in points.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Any remaining keyword arguments are passed through to</span>
<span class="sd">            `.Axes.annotate`. The alignment parameters (</span>
<span class="sd">            *horizontalalignment* / *ha*, *verticalalignment* / *va*) are</span>
<span class="sd">            not supported because the labels are automatically aligned to</span>
<span class="sd">            the bars.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `.Text`</span>
<span class="sd">            A list of `.Text` instances for the labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;horizontalalignment&#39;</span><span class="p">,</span> <span class="s1">&#39;ha&#39;</span><span class="p">,</span> <span class="s1">&#39;verticalalignment&#39;</span><span class="p">,</span> <span class="s1">&#39;va&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Passing </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> to bar_label() is not supported.&quot;</span><span class="p">)</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_view_interval</span><span class="p">()</span>
        <span class="n">y_inverted</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_view_interval</span><span class="p">()</span>
        <span class="n">x_inverted</span> <span class="o">=</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">d</span>

        <span class="c1"># want to know whether to put label on positive or negative direction</span>
        <span class="c1"># cannot use np.sign here because it will return 0 if x == 0</span>
        <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">],</span> <span class="n">label_type</span><span class="o">=</span><span class="n">label_type</span><span class="p">)</span>

        <span class="n">bars</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">patches</span>
        <span class="n">errorbar</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">errorbar</span>
        <span class="n">datavalues</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">datavalues</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">orientation</span>

        <span class="k">if</span> <span class="n">errorbar</span><span class="p">:</span>
            <span class="c1"># check &quot;ErrorbarContainer&quot; for the definition of these elements</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">errorbar</span><span class="o">.</span><span class="n">lines</span>  <span class="c1"># attribute of &quot;ErrorbarContainer&quot; (tuple)</span>
            <span class="n">barlinecols</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># 0: data_line, 1: caplines, 2: barlinecols</span>
            <span class="n">barlinecol</span> <span class="o">=</span> <span class="n">barlinecols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># the &quot;LineCollection&quot; of error bars</span>
            <span class="n">errs</span> <span class="o">=</span> <span class="n">barlinecol</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">annotations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">bar</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span>
                <span class="n">bars</span><span class="p">,</span> <span class="n">errs</span><span class="p">,</span> <span class="n">datavalues</span><span class="p">,</span> <span class="n">labels</span>
        <span class="p">):</span>
            <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="n">bar</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
                <span class="n">extrema</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                <span class="n">extrema</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">endpt</span> <span class="o">=</span> <span class="n">extrema</span>
            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
                <span class="n">endpt</span> <span class="o">=</span> <span class="n">err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                <span class="n">endpt</span> <span class="o">=</span> <span class="n">err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">label_type</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># edge</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">extrema</span>

            <span class="k">if</span> <span class="n">label_type</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
                <span class="n">xy</span> <span class="o">=</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># edge</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
                    <span class="n">xy</span> <span class="o">=</span> <span class="n">xc</span><span class="p">,</span> <span class="n">endpt</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                    <span class="n">xy</span> <span class="o">=</span> <span class="n">endpt</span><span class="p">,</span> <span class="n">yc</span>

            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
                <span class="n">y_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">y_inverted</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="n">xytext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y_direction</span> <span class="o">*</span> <span class="n">sign</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="o">*</span> <span class="n">padding</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                <span class="n">x_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x_inverted</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="n">xytext</span> <span class="o">=</span> <span class="n">x_direction</span> <span class="o">*</span> <span class="n">sign</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="o">*</span> <span class="n">padding</span><span class="p">,</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">label_type</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
                <span class="n">ha</span><span class="p">,</span> <span class="n">va</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="s2">&quot;center&quot;</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># edge</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
                    <span class="n">ha</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>
                    <span class="k">if</span> <span class="n">y_inverted</span><span class="p">:</span>
                        <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;bottom&#39;</span>  <span class="c1"># also handles NaN</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;bottom&#39;</span>  <span class="c1"># also handles NaN</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
                    <span class="k">if</span> <span class="n">x_inverted</span><span class="p">:</span>
                        <span class="n">ha</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;left&#39;</span>  <span class="c1"># also handles NaN</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ha</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="n">dat</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;left&#39;</span>  <span class="c1"># also handles NaN</span>
                    <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dat</span><span class="p">):</span>
                <span class="n">lbl</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

            <span class="n">annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="n">value</span> <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lbl</span><span class="p">,</span>
                                       <span class="n">xy</span><span class="p">,</span> <span class="n">xytext</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                       <span class="n">ha</span><span class="o">=</span><span class="n">ha</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="n">va</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">annotations</span></div>

<div class="viewcode-block" id="Axes.broken_barh"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.broken_barh">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">broken_barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a horizontal sequence of rectangles.</span>

<span class="sd">        A rectangle is drawn for each element of *xranges*. All rectangles</span>
<span class="sd">        have the same vertical position and size defined by *yrange*.</span>

<span class="sd">        This is a convenience function for instantiating a</span>
<span class="sd">        `.BrokenBarHCollection`, adding it to the Axes and autoscaling the</span>
<span class="sd">        view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xranges : sequence of tuples (*xmin*, *xwidth*)</span>
<span class="sd">            The x-positions and extends of the rectangles. For each tuple</span>
<span class="sd">            (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +</span>
<span class="sd">            *xwidth*.</span>
<span class="sd">        yrange : (*ymin*, *yheight*)</span>
<span class="sd">            The y-position and extend for all the rectangles.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~.collections.BrokenBarHCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>
<span class="sd">        **kwargs : `.BrokenBarHCollection` properties</span>

<span class="sd">            Each *kwarg* can be either a single argument applying to all</span>
<span class="sd">            rectangles, e.g.::</span>

<span class="sd">                facecolors=&#39;black&#39;</span>

<span class="sd">            or a sequence of arguments over which is cycled, e.g.::</span>

<span class="sd">                facecolors=(&#39;black&#39;, &#39;blue&#39;)</span>

<span class="sd">            would create interleaving black and blue rectangles.</span>

<span class="sd">            Supported keywords:</span>

<span class="sd">            %(BrokenBarHCollection:kwdoc)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the unit information</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xranges</span><span class="p">):</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">xranges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yrange</span><span class="p">):</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">xdata</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">xranges_conv</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xr</span> <span class="ow">in</span> <span class="n">xranges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;each range in xrange must be a sequence &#39;</span>
                                 <span class="s1">&#39;with two elements (i.e. an Nx2 array)&#39;</span><span class="p">)</span>
            <span class="c1"># convert the absolute values, not the x and dx...</span>
            <span class="n">x_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">xr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">)</span>
            <span class="n">xranges_conv</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x_conv</span><span class="p">,</span> <span class="n">x1</span><span class="p">))</span>

        <span class="n">yrange_conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">BrokenBarHCollection</span><span class="p">(</span><span class="n">xranges_conv</span><span class="p">,</span> <span class="n">yrange_conv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">col</span></div>

<div class="viewcode-block" id="Axes.stem"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.stem">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_api</span><span class="o">.</span><span class="n">delete_parameter</span><span class="p">(</span><span class="s2">&quot;3.6&quot;</span><span class="p">,</span> <span class="s2">&quot;use_line_collection&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">linefmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">markerfmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basefmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_line_collection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a stem plot.</span>

<span class="sd">        A stem plot draws lines perpendicular to a baseline at each location</span>
<span class="sd">        *locs* from the baseline to *heads*, and places a marker there. For</span>
<span class="sd">        vertical stem plots (the default), the *locs* are *x* positions, and</span>
<span class="sd">        the *heads* are *y* values. For horizontal stem plots, the *locs* are</span>
<span class="sd">        *y* positions, and the *heads* are *x* values.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)</span>

<span class="sd">        The *locs*-positions are optional. The formats may be provided either</span>
<span class="sd">        as positional or as keyword-arguments.</span>
<span class="sd">        Passing *markerfmt* and *basefmt* positionally is deprecated since</span>
<span class="sd">        Matplotlib 3.5.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locs : array-like, default: (0, 1, ..., len(heads) - 1)</span>
<span class="sd">            For vertical stem plots, the x-positions of the stems.</span>
<span class="sd">            For horizontal stem plots, the y-positions of the stems.</span>

<span class="sd">        heads : array-like</span>
<span class="sd">            For vertical stem plots, the y-values of the stem heads.</span>
<span class="sd">            For horizontal stem plots, the x-values of the stem heads.</span>

<span class="sd">        linefmt : str, optional</span>
<span class="sd">            A string defining the color and/or linestyle of the vertical lines:</span>

<span class="sd">            =========  =============</span>
<span class="sd">            Character  Line Style</span>
<span class="sd">            =========  =============</span>
<span class="sd">            ``&#39;-&#39;``    solid line</span>
<span class="sd">            ``&#39;--&#39;``   dashed line</span>
<span class="sd">            ``&#39;-.&#39;``   dash-dot line</span>
<span class="sd">            ``&#39;:&#39;``    dotted line</span>
<span class="sd">            =========  =============</span>

<span class="sd">            Default: &#39;C0-&#39;, i.e. solid line with the first color of the color</span>
<span class="sd">            cycle.</span>

<span class="sd">            Note: Markers specified through this parameter (e.g. &#39;x&#39;) will be</span>
<span class="sd">            silently ignored (unless using ``use_line_collection=False``).</span>
<span class="sd">            Instead, markers should be specified using *markerfmt*.</span>

<span class="sd">        markerfmt : str, optional</span>
<span class="sd">            A string defining the color and/or shape of the markers at the stem</span>
<span class="sd">            heads. If the marker is not given, use the marker &#39;o&#39;, i.e. filled</span>
<span class="sd">            circles. If the color is not given, use the color from *linefmt*.</span>

<span class="sd">        basefmt : str, default: &#39;C3-&#39; (&#39;C2-&#39; in classic mode)</span>
<span class="sd">            A format string defining the properties of the baseline.</span>

<span class="sd">        orientation : str, default: &#39;vertical&#39;</span>
<span class="sd">            If &#39;vertical&#39;, will produce a plot with stems oriented vertically,</span>
<span class="sd">            otherwise the stems will be oriented horizontally.</span>

<span class="sd">        bottom : float, default: 0</span>
<span class="sd">            The y/x-position of the baseline (depending on orientation).</span>

<span class="sd">        label : str, default: None</span>
<span class="sd">            The label to use for the stems in legends.</span>

<span class="sd">        use_line_collection : bool, default: True</span>
<span class="sd">            *Deprecated since 3.6*</span>

<span class="sd">            If ``True``, store and plot the stem lines as a</span>
<span class="sd">            `~.collections.LineCollection` instead of individual lines, which</span>
<span class="sd">            significantly increases performance.  If ``False``, defaults to the</span>
<span class="sd">            old behavior of using a list of `.Line2D` objects.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.StemContainer`</span>
<span class="sd">            The container may be treated like a tuple</span>
<span class="sd">            (*markerline*, *stemlines*, *baseline*)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. seealso::</span>
<span class="sd">            The MATLAB function</span>
<span class="sd">            `stem &lt;https://www.mathworks.com/help/matlab/ref/stem.html&gt;`_</span>
<span class="sd">            which inspired this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;stem expected between 1 and 5 positional &#39;</span>
                            <span class="s1">&#39;arguments, got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="s1">&#39;vertical&#39;</span><span class="p">],</span> <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">heads</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">heads</span><span class="p">))</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">heads</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">heads</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">heads</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_api</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
                <span class="s2">&quot;3.5&quot;</span><span class="p">,</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Passing the markerfmt parameter positionally is &quot;</span>
                        <span class="s2">&quot;deprecated since Matplotlib </span><span class="si">%(since)s</span><span class="s2">; the &quot;</span>
                        <span class="s2">&quot;parameter will become keyword-only </span><span class="si">%(removal)s</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="n">locs</span><span class="p">,</span> <span class="n">heads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">locs</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">heads</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
            <span class="n">heads</span><span class="p">,</span> <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">heads</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">locs</span><span class="p">)])</span>

        <span class="c1"># resolve line format</span>
        <span class="k">if</span> <span class="n">linefmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linefmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;C0-&quot;</span>
        <span class="n">linestyle</span><span class="p">,</span> <span class="n">linemarker</span><span class="p">,</span> <span class="n">linecolor</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">linefmt</span><span class="p">)</span>

        <span class="c1"># resolve marker format</span>
        <span class="k">if</span> <span class="n">markerfmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if not given as kwarg, check for positional or fall back to &#39;o&#39;</span>
            <span class="n">markerfmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;o&quot;</span>
        <span class="k">if</span> <span class="n">markerfmt</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">markerfmt</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span>  <span class="c1"># = empty line style; &#39;&#39; would resolve rcParams</span>
        <span class="n">markerstyle</span><span class="p">,</span> <span class="n">markermarker</span><span class="p">,</span> <span class="n">markercolor</span> <span class="o">=</span> \
            <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">markerfmt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">markermarker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">markermarker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span>
        <span class="k">if</span> <span class="n">markerstyle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">markerstyle</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
        <span class="k">if</span> <span class="n">markercolor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">markercolor</span> <span class="o">=</span> <span class="n">linecolor</span>

        <span class="c1"># resolve baseline format</span>
        <span class="k">if</span> <span class="n">basefmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basefmt</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span>
                       <span class="s2">&quot;C2-&quot;</span> <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;_internal.classic_mode&quot;</span><span class="p">]</span> <span class="k">else</span>
                       <span class="s2">&quot;C3-&quot;</span><span class="p">)</span>
        <span class="n">basestyle</span><span class="p">,</span> <span class="n">basemarker</span><span class="p">,</span> <span class="n">basecolor</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">basefmt</span><span class="p">)</span>

        <span class="c1"># New behaviour in 3.1 is to use a LineCollection for the stemlines</span>
        <span class="k">if</span> <span class="n">use_line_collection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">linestyle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linestyle</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linestyle&#39;</span><span class="p">]</span>
            <span class="n">xlines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span> <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span>
            <span class="n">stemlines</span> <span class="o">=</span> <span class="n">xlines</span><span class="p">(</span>
                <span class="n">locs</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">heads</span><span class="p">,</span>
                <span class="n">colors</span><span class="o">=</span><span class="n">linecolor</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
        <span class="c1"># Old behaviour is to plot each of the lines individually</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stemlines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">loc</span><span class="p">,</span> <span class="n">head</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">heads</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">head</span><span class="p">]</span>
                    <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">,</span> <span class="n">loc</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">,</span> <span class="n">loc</span><span class="p">]</span>
                    <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">head</span><span class="p">]</span>
                <span class="n">l</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="n">linecolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                               <span class="n">marker</span><span class="o">=</span><span class="n">linemarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
                <span class="n">stemlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
            <span class="n">marker_x</span> <span class="o">=</span> <span class="n">heads</span>
            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">locs</span>
            <span class="n">baseline_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>
            <span class="n">baseline_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">locs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">locs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">marker_x</span> <span class="o">=</span> <span class="n">locs</span>
            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">heads</span>
            <span class="n">baseline_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">locs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">locs</span><span class="p">)]</span>
            <span class="n">baseline_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>

        <span class="n">markerline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">marker_x</span><span class="p">,</span> <span class="n">marker_y</span><span class="p">,</span>
                                <span class="n">color</span><span class="o">=</span><span class="n">markercolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">markerstyle</span><span class="p">,</span>
                                <span class="n">marker</span><span class="o">=</span><span class="n">markermarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>

        <span class="n">baseline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">baseline_x</span><span class="p">,</span> <span class="n">baseline_y</span><span class="p">,</span>
                              <span class="n">color</span><span class="o">=</span><span class="n">basecolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">basestyle</span><span class="p">,</span>
                              <span class="n">marker</span><span class="o">=</span><span class="n">basemarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>

        <span class="n">stem_container</span> <span class="o">=</span> <span class="n">StemContainer</span><span class="p">((</span><span class="n">markerline</span><span class="p">,</span> <span class="n">stemlines</span><span class="p">,</span> <span class="n">baseline</span><span class="p">),</span>
                                       <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">stem_container</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stem_container</span></div>

<div class="viewcode-block" id="Axes.pie"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.pie">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;explode&quot;</span><span class="p">,</span> <span class="s2">&quot;labels&quot;</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">explode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">autopct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pctdistance</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labeldistance</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
            <span class="n">startangle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">counterclock</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">wedgeprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">textprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">frame</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rotatelabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a pie chart.</span>

<span class="sd">        Make a pie chart of array *x*.  The fractional area of each wedge is</span>
<span class="sd">        given by ``x/sum(x)``.</span>

<span class="sd">        The wedges are plotted counterclockwise, by default starting from the</span>
<span class="sd">        x-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1D array-like</span>
<span class="sd">            The wedge sizes.</span>

<span class="sd">        explode : array-like, default: None</span>
<span class="sd">            If not *None*, is a ``len(x)`` array which specifies the fraction</span>
<span class="sd">            of the radius with which to offset each wedge.</span>

<span class="sd">        labels : list, default: None</span>
<span class="sd">            A sequence of strings providing the labels for each wedge</span>

<span class="sd">        colors : array-like, default: None</span>
<span class="sd">            A sequence of colors through which the pie chart will cycle.  If</span>
<span class="sd">            *None*, will use the colors in the currently active cycle.</span>

<span class="sd">        autopct : None or str or callable, default: None</span>
<span class="sd">            If not *None*, is a string or function used to label the wedges</span>
<span class="sd">            with their numeric value.  The label will be placed inside the</span>
<span class="sd">            wedge.  If it is a format string, the label will be ``fmt % pct``.</span>
<span class="sd">            If it is a function, it will be called.</span>

<span class="sd">        pctdistance : float, default: 0.6</span>
<span class="sd">            The ratio between the center of each pie slice and the start of</span>
<span class="sd">            the text generated by *autopct*.  Ignored if *autopct* is *None*.</span>

<span class="sd">        shadow : bool, default: False</span>
<span class="sd">            Draw a shadow beneath the pie.</span>

<span class="sd">        normalize : bool, default: True</span>
<span class="sd">            When *True*, always make a full pie by normalizing x so that</span>
<span class="sd">            ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) &lt;= 1``</span>
<span class="sd">            and raises a `ValueError` for ``sum(x) &gt; 1``.</span>

<span class="sd">        labeldistance : float or None, default: 1.1</span>
<span class="sd">            The radial distance at which the pie labels are drawn.</span>
<span class="sd">            If set to ``None``, label are not drawn, but are stored for use in</span>
<span class="sd">            ``legend()``</span>

<span class="sd">        startangle : float, default: 0 degrees</span>
<span class="sd">            The angle by which the start of the pie is rotated,</span>
<span class="sd">            counterclockwise from the x-axis.</span>

<span class="sd">        radius : float, default: 1</span>
<span class="sd">            The radius of the pie.</span>

<span class="sd">        counterclock : bool, default: True</span>
<span class="sd">            Specify fractions direction, clockwise or counterclockwise.</span>

<span class="sd">        wedgeprops : dict, default: None</span>
<span class="sd">            Dict of arguments passed to the wedge objects making the pie.</span>
<span class="sd">            For example, you can pass in ``wedgeprops = {&#39;linewidth&#39;: 3}``</span>
<span class="sd">            to set the width of the wedge border lines equal to 3.</span>
<span class="sd">            For more details, look at the doc/arguments of the wedge object.</span>
<span class="sd">            By default ``clip_on=False``.</span>

<span class="sd">        textprops : dict, default: None</span>
<span class="sd">            Dict of arguments to pass to the text objects.</span>

<span class="sd">        center : (float, float), default: (0, 0)</span>
<span class="sd">            The coordinates of the center of the chart.</span>

<span class="sd">        frame : bool, default: False</span>
<span class="sd">            Plot Axes frame with the chart if true.</span>

<span class="sd">        rotatelabels : bool, default: False</span>
<span class="sd">            Rotate each label to the angle of the corresponding slice if true.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        patches : list</span>
<span class="sd">            A sequence of `matplotlib.patches.Wedge` instances</span>

<span class="sd">        texts : list</span>
<span class="sd">            A list of the label `.Text` instances.</span>

<span class="sd">        autotexts : list</span>
<span class="sd">            A list of `.Text` instances for the numeric labels. This will only</span>
<span class="sd">            be returned if the parameter *autopct* is not *None*.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The pie chart will probably look best if the figure and Axes are</span>
<span class="sd">        square, or the Axes aspect is equal.</span>
<span class="sd">        This method sets the aspect ratio of the axis to &quot;equal&quot;.</span>
<span class="sd">        The Axes aspect ratio can be controlled with `.Axes.set_aspect`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="c1"># The use of float32 is &quot;historical&quot;, but can&#39;t be changed without</span>
        <span class="c1"># regenerating the test baselines.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be 1D&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wedge sizes &#39;x&#39; must be non negative values&quot;</span><span class="p">)</span>

        <span class="n">sx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">sx</span>
        <span class="k">elif</span> <span class="n">sx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot plot an unnormalized pie with sum(x) &gt; 1&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">explode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">explode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;label&#39; must be of length &#39;x&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">explode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;explode&#39; must be of length &#39;x&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">get_next_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color_cycle</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">get_next_color</span><span class="p">():</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">color_cycle</span><span class="p">)</span>

        <span class="n">_api</span><span class="o">.</span><span class="n">check_isinstance</span><span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">startangle</span><span class="o">=</span><span class="n">startangle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;radius must be a positive number, not </span><span class="si">{</span><span class="n">radius</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Starting theta1 is the start fraction of the circle</span>
        <span class="n">theta1</span> <span class="o">=</span> <span class="n">startangle</span> <span class="o">/</span> <span class="mi">360</span>

        <span class="k">if</span> <span class="n">wedgeprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wedgeprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">textprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">textprops</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">texts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">autotexts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">frac</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">expl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">explode</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">center</span>
            <span class="n">theta2</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">frac</span><span class="p">)</span> <span class="k">if</span> <span class="n">counterclock</span> <span class="k">else</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">-</span> <span class="n">frac</span><span class="p">)</span>
            <span class="n">thetam</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">theta2</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Wedge</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="mf">360.</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                               <span class="mf">360.</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                               <span class="n">facecolor</span><span class="o">=</span><span class="n">get_next_color</span><span class="p">(),</span>
                               <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">wedgeprops</span><span class="p">)</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shadow</span><span class="p">:</span>
                <span class="c1"># Make sure to add a shadow after the call to add_patch so the</span>
                <span class="c1"># figure and transform props will be set.</span>
                <span class="n">shad</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Shadow</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">shad</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">labeldistance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">label_alignment_h</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span> <span class="k">if</span> <span class="n">xt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;right&#39;</span>
                <span class="n">label_alignment_v</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>
                <span class="n">label_rotation</span> <span class="o">=</span> <span class="s1">&#39;horizontal&#39;</span>
                <span class="k">if</span> <span class="n">rotatelabels</span><span class="p">:</span>
                    <span class="n">label_alignment_v</span> <span class="o">=</span> <span class="s1">&#39;bottom&#39;</span> <span class="k">if</span> <span class="n">yt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;top&#39;</span>
                    <span class="n">label_rotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                                      <span class="o">+</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">xt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">180</span><span class="p">))</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
                              <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">horizontalalignment</span><span class="o">=</span><span class="n">label_alignment_h</span><span class="p">,</span>
                              <span class="n">verticalalignment</span><span class="o">=</span><span class="n">label_alignment_v</span><span class="p">,</span>
                              <span class="n">rotation</span><span class="o">=</span><span class="n">label_rotation</span><span class="p">,</span>
                              <span class="n">size</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;xtick.labelsize&#39;</span><span class="p">])</span>
                <span class="n">t</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">textprops</span><span class="p">)</span>
                <span class="n">texts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">autopct</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span> <span class="o">%</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">autopct</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span><span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;autopct must be callable or a format string&#39;</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
                              <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                              <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">textprops</span><span class="p">)</span>
                <span class="n">autotexts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">theta1</span> <span class="o">=</span> <span class="n">theta2</span>

        <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frame_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[],</span>
                     <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span><span class="p">,</span> <span class="n">autotexts</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_errorevery_to_mask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">errorevery</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize `errorbar`&#39;s *errorevery* to be a boolean mask for data *x*.</span>

<span class="sd">        This function is split out to be usable both by 2D and 3D errorbars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errorevery</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">errorevery</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">errorevery</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errorevery</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">errorevery</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">errorevery</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">errorevery</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)):</span>
                <span class="n">errorevery</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">errorevery</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">errorevery</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">errorevery</span><span class="si">=!r}</span><span class="s1"> is a not a tuple of two integers&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errorevery</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errorevery</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">errorevery</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[</span><span class="n">errorevery</span><span class="p">]</span>  <span class="c1"># fancy indexing</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">errorevery</span><span class="si">=!r}</span><span class="s2"> is iterable but not a valid NumPy fancy &quot;</span>
                    <span class="s2">&quot;index to match &#39;xerr&#39;/&#39;yerr&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">errorevery</span><span class="si">=!r}</span><span class="s2"> is not a recognized value&quot;</span><span class="p">)</span>
        <span class="n">everymask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="n">everymask</span><span class="p">[</span><span class="n">errorevery</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">everymask</span>

<div class="viewcode-block" id="Axes.errorbar"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.errorbar">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;xerr&quot;</span><span class="p">,</span> <span class="s2">&quot;yerr&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">errorbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">barsabove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lolims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">uplims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">xlolims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xuplims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">errorevery</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">capthick</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot y versus x as lines and/or markers with attached errorbars.</span>

<span class="sd">        *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar</span>
<span class="sd">        sizes. By default, this draws the data markers/lines as well the</span>
<span class="sd">        errorbars. Use fmt=&#39;none&#39; to draw errorbars without any data markers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : float or array-like</span>
<span class="sd">            The data positions.</span>

<span class="sd">        xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional</span>
<span class="sd">            The errorbar sizes:</span>

<span class="sd">            - scalar: Symmetric +/- values for all data points.</span>
<span class="sd">            - shape(N,): Symmetric +/-values for each data point.</span>
<span class="sd">            - shape(2, N): Separate - and + values for each bar. First row</span>
<span class="sd">              contains the lower errors, the second row contains the upper</span>
<span class="sd">              errors.</span>
<span class="sd">            - *None*: No errorbar.</span>

<span class="sd">            All values must be &gt;= 0.</span>

<span class="sd">            See :doc:`/gallery/statistics/errorbar_features`</span>
<span class="sd">            for an example on the usage of ``xerr`` and ``yerr``.</span>

<span class="sd">        fmt : str, default: &#39;&#39;</span>
<span class="sd">            The format for the data points / data lines. See `.plot` for</span>
<span class="sd">            details.</span>

<span class="sd">            Use &#39;none&#39; (case insensitive) to plot errorbars without any data</span>
<span class="sd">            markers.</span>

<span class="sd">        ecolor : color, default: None</span>
<span class="sd">            The color of the errorbar lines.  If None, use the color of the</span>
<span class="sd">            line connecting the markers.</span>

<span class="sd">        elinewidth : float, default: None</span>
<span class="sd">            The linewidth of the errorbar lines. If None, the linewidth of</span>
<span class="sd">            the current style is used.</span>

<span class="sd">        capsize : float, default: :rc:`errorbar.capsize`</span>
<span class="sd">            The length of the error bar caps in points.</span>

<span class="sd">        capthick : float, default: None</span>
<span class="sd">            An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).</span>
<span class="sd">            This setting is a more sensible name for the property that</span>
<span class="sd">            controls the thickness of the error bar cap in points. For</span>
<span class="sd">            backwards compatibility, if *mew* or *markeredgewidth* are given,</span>
<span class="sd">            then they will over-ride *capthick*. This may change in future</span>
<span class="sd">            releases.</span>

<span class="sd">        barsabove : bool, default: False</span>
<span class="sd">            If True, will plot the errorbars above the plot</span>
<span class="sd">            symbols. Default is below.</span>

<span class="sd">        lolims, uplims, xlolims, xuplims : bool, default: False</span>
<span class="sd">            These arguments can be used to indicate that a value gives only</span>
<span class="sd">            upper/lower limits.  In that case a caret symbol is used to</span>
<span class="sd">            indicate this. *lims*-arguments may be scalars, or array-likes of</span>
<span class="sd">            the same length as *xerr* and *yerr*.  To use limits with inverted</span>
<span class="sd">            axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before</span>
<span class="sd">            :meth:`errorbar`.  Note the tricky parameter names: setting e.g.</span>
<span class="sd">            *lolims* to True means that the y-value is a *lower* limit of the</span>
<span class="sd">            True value, so, only an *upward*-pointing arrow will be drawn!</span>

<span class="sd">        errorevery : int or (int, int), default: 1</span>
<span class="sd">            draws error bars on a subset of the data. *errorevery* =N draws</span>
<span class="sd">            error bars on the points (x[::N], y[::N]).</span>
<span class="sd">            *errorevery* =(start, N) draws error bars on the points</span>
<span class="sd">            (x[start::N], y[start::N]). e.g. errorevery=(6, 3)</span>
<span class="sd">            adds error bars to the data at (x[6], x[9], x[12], x[15], ...).</span>
<span class="sd">            Used to avoid overlapping error bars when two series share x-axis</span>
<span class="sd">            values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.ErrorbarContainer`</span>
<span class="sd">            The container contains:</span>

<span class="sd">            - plotline: `.Line2D` instance of x, y plot markers and/or line.</span>
<span class="sd">            - caplines: A tuple of `.Line2D` instances of the error bar caps.</span>
<span class="sd">            - barlinecols: A tuple of `.LineCollection` with the horizontal and</span>
<span class="sd">              vertical error ranges.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are passed on to the `~.Axes.plot` call</span>
<span class="sd">            drawing the markers. For example, this code makes big red squares</span>
<span class="sd">            with thick green edges::</span>

<span class="sd">                x, y, yerr = rand(3, 10)</span>
<span class="sd">                errorbar(x, y, yerr, marker=&#39;s&#39;, mfc=&#39;red&#39;,</span>
<span class="sd">                         mec=&#39;green&#39;, ms=20, mew=4)</span>

<span class="sd">            where *mfc*, *mec*, *ms* and *mew* are aliases for the longer</span>
<span class="sd">            property names, *markerfacecolor*, *markeredgecolor*, *markersize*</span>
<span class="sd">            and *markeredgewidth*.</span>

<span class="sd">            Valid kwargs for the marker properties are:</span>

<span class="sd">            - *dashes*</span>
<span class="sd">            - *dash_capstyle*</span>
<span class="sd">            - *dash_joinstyle*</span>
<span class="sd">            - *drawstyle*</span>
<span class="sd">            - *fillstyle*</span>
<span class="sd">            - *linestyle*</span>
<span class="sd">            - *marker*</span>
<span class="sd">            - *markeredgecolor*</span>
<span class="sd">            - *markeredgewidth*</span>
<span class="sd">            - *markerfacecolor*</span>
<span class="sd">            - *markerfacecoloralt*</span>
<span class="sd">            - *markersize*</span>
<span class="sd">            - *markevery*</span>
<span class="sd">            - *solid_capstyle*</span>
<span class="sd">            - *solid_joinstyle*</span>

<span class="sd">            Refer to the corresponding `.Line2D` property for more details:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">)</span>
        <span class="c1"># Drop anything that comes in as None to use the default instead.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Casting to object arrays preserves units.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_upcast_err</span><span class="p">(</span><span class="n">err</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Safely handle tuple of containers that carry units.</span>

<span class="sd">            This function covers the case where the input to the xerr/yerr is a</span>
<span class="sd">            length 2 tuple of equal length ndarray-subclasses that carry the</span>
<span class="sd">            unit information in the container.</span>

<span class="sd">            If we have a tuple of nested numpy array (subclasses), we defer</span>
<span class="sd">            coercing the units to be consistent to the underlying unit</span>
<span class="sd">            library (and implicitly the broadcasting).</span>

<span class="sd">            Otherwise, fallback to casting to an object array.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="p">(</span>
                    <span class="c1"># make sure it is not a scalar</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="c1"># and it is not empty</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span>
                    <span class="c1"># and the first element is an array sub-class use</span>
                    <span class="c1"># safe_first_element because getitem is index-first not</span>
                    <span class="c1"># location first on pandas objects so err[0] almost always</span>
                    <span class="c1"># fails.</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># Get the type of the first element</span>
                <span class="n">atype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
                <span class="c1"># Promote the outer container to match the inner container</span>
                <span class="k">if</span> <span class="n">atype</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                    <span class="c1"># Converts using np.asarray, because data cannot</span>
                    <span class="c1"># be directly passed to init of np.ndarray</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="c1"># If atype is not np.ndarray, directly pass data to init.</span>
                <span class="c1"># This works for types such as unyts and astropy units</span>
                <span class="k">return</span> <span class="n">atype</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="c1"># Otherwise wrap it in an object array</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xerr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">xerr</span> <span class="o">=</span> <span class="n">_upcast_err</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">yerr</span> <span class="o">=</span> <span class="n">_upcast_err</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># Make sure all the args are iterable.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;x&#39; and &#39;y&#39; must have the same size&quot;</span><span class="p">)</span>

        <span class="n">everymask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errorevery_to_mask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">errorevery</span><span class="p">)</span>

        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;_nolegend_&#39;</span>

        <span class="c1"># Create the main line and determine overall kwargs for child artists.</span>
        <span class="c1"># We avoid calling self.plot() directly, or self._get_lines(), because</span>
        <span class="c1"># that would call self._process_unit_info again, and do other indirect</span>
        <span class="c1"># data processing.</span>
        <span class="p">(</span><span class="n">data_line</span><span class="p">,</span> <span class="n">base_style</span><span class="p">),</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">_plot_args</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="p">),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">return_kwargs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Do this after creating `data_line` to avoid modifying `base_style`.</span>
        <span class="k">if</span> <span class="n">barsabove</span><span class="p">:</span>
            <span class="n">data_line</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;zorder&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">.1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_line</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;zorder&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">.1</span><span class="p">)</span>

        <span class="c1"># Add line to plot, or throw it away and use it to determine kwargs.</span>
        <span class="k">if</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">data_line</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_line</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Remove alpha=0 color that _get_lines._plot_args returns for</span>
            <span class="c1"># &#39;none&#39; format, and replace it with user-specified color, if</span>
            <span class="c1"># supplied.</span>
            <span class="n">base_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">base_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_style</span><span class="p">:</span>
            <span class="n">base_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;C0&#39;</span>
        <span class="k">if</span> <span class="n">ecolor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ecolor</span> <span class="o">=</span> <span class="n">base_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>

        <span class="c1"># Eject any line-specific information from format string, as it&#39;s not</span>
        <span class="c1"># needed for bars or caps.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="s1">&#39;markersize&#39;</span><span class="p">,</span> <span class="s1">&#39;markerfacecolor&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;markerfacecoloralt&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;markeredgewidth&#39;</span><span class="p">,</span> <span class="s1">&#39;markeredgecolor&#39;</span><span class="p">,</span> <span class="s1">&#39;markevery&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="s1">&#39;fillstyle&#39;</span><span class="p">,</span> <span class="s1">&#39;drawstyle&#39;</span><span class="p">,</span> <span class="s1">&#39;dash_capstyle&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;dash_joinstyle&#39;</span><span class="p">,</span> <span class="s1">&#39;solid_capstyle&#39;</span><span class="p">,</span> <span class="s1">&#39;solid_joinstyle&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;dashes&#39;</span><span class="p">]:</span>
            <span class="n">base_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Make the style dict for the line collections (the bars).</span>
        <span class="n">eb_lines_style</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">base_style</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="n">ecolor</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">elinewidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elinewidth</span>
        <span class="k">elif</span> <span class="s1">&#39;linewidth&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="s1">&#39;rasterized&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">eb_lines_style</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Make the style dict for caps (the &quot;hats&quot;).</span>
        <span class="n">eb_cap_style</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">base_style</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capsize</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;errorbar.capsize&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">&#39;markersize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">capsize</span>
        <span class="k">if</span> <span class="n">capthick</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">&#39;markeredgewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">capthick</span>

        <span class="c1"># For backwards-compat, allow explicit setting of</span>
        <span class="c1"># &#39;markeredgewidth&#39; to over-ride capthick.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;markeredgewidth&#39;</span><span class="p">,</span> <span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="s1">&#39;rasterized&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">eb_cap_style</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ecolor</span>

        <span class="n">barcols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caplines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Vectorized fancy-indexer.</span>
        <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>

        <span class="c1"># dep: dependent dataset, indep: independent dataset</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">dep_axis</span><span class="p">,</span> <span class="n">dep</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">lolims</span><span class="p">,</span> <span class="n">uplims</span><span class="p">,</span> <span class="n">indep</span><span class="p">,</span> <span class="n">lines_func</span><span class="p">,</span>
             <span class="n">marker</span><span class="p">,</span> <span class="n">lomarker</span><span class="p">,</span> <span class="n">himarker</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">xlolims</span><span class="p">,</span> <span class="n">xuplims</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">,</span>
                 <span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETRIGHTBASE</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETLEFTBASE</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">lolims</span><span class="p">,</span> <span class="n">uplims</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">,</span>
                 <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETUPBASE</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETDOWNBASE</span><span class="p">),</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">lolims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">lolims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dep</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">uplims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">uplims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dep</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dep</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">dep_axis</span><span class="si">}</span><span class="s2">err&#39; (shape: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2">) must be a &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;scalar or a 1D or (2, n) array-like whose shape matches &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">dep_axis</span><span class="si">}</span><span class="s2">&#39; (shape: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># Default in case of nan</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">-</span><span class="n">err</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">err</span><span class="p">))):</span>
                <span class="c1"># like err&lt;0, but also works for timedelta and nan.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">dep_axis</span><span class="si">}</span><span class="s2">err&#39; must not contain negative values&quot;</span><span class="p">)</span>
            <span class="c1"># This is like</span>
            <span class="c1">#     elow, ehigh = np.broadcast_to(...)</span>
            <span class="c1">#     return dep - elow * ~lolims, dep + ehigh * ~uplims</span>
            <span class="c1"># except that broadcast_to would strip units.</span>
            <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">dep</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">lolims</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">uplims</span><span class="p">])</span> <span class="o">*</span> <span class="n">err</span>

            <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lines_func</span><span class="p">(</span>
                <span class="o">*</span><span class="n">apply_mask</span><span class="p">([</span><span class="n">indep</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">],</span> <span class="n">everymask</span><span class="p">),</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
            <span class="c1"># Normal errorbars for points without upper/lower limits.</span>
            <span class="n">nolims</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">lolims</span> <span class="o">|</span> <span class="n">uplims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nolims</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">indep_masked</span><span class="p">,</span> <span class="n">lo_masked</span><span class="p">,</span> <span class="n">hi_masked</span> <span class="o">=</span> <span class="n">apply_mask</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">indep</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">],</span> <span class="n">nolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lh_masked</span> <span class="ow">in</span> <span class="p">[</span><span class="n">lo_masked</span><span class="p">,</span> <span class="n">hi_masked</span><span class="p">]:</span>
                    <span class="c1"># Since this has to work for x and y as dependent data, we</span>
                    <span class="c1"># first set both x and y to the independent variable and</span>
                    <span class="c1"># overwrite the respective dependent data in a second step.</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">indep_masked</span><span class="p">,</span> <span class="n">indep_masked</span><span class="p">,</span>
                                         <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">)</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dep_axis</span><span class="si">}</span><span class="s2">data&quot;</span><span class="p">:</span> <span class="n">lh_masked</span><span class="p">})</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">lims</span><span class="p">,</span> <span class="n">hl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([(</span><span class="n">lolims</span><span class="p">,</span> <span class="n">high</span><span class="p">),</span> <span class="p">(</span><span class="n">uplims</span><span class="p">,</span> <span class="n">low</span><span class="p">)]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="n">hlmarker</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">himarker</span>
                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dep_axis</span><span class="si">}</span><span class="s2">axis&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_inverted</span><span class="p">()</span> <span class="o">^</span> <span class="n">idx</span>
                    <span class="k">else</span> <span class="n">lomarker</span><span class="p">)</span>
                <span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">,</span> <span class="n">hl_masked</span> <span class="o">=</span> <span class="n">apply_mask</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hl</span><span class="p">],</span> <span class="n">lims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="c1"># As above, we set the dependent data in a second step.</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">,</span>
                                     <span class="n">marker</span><span class="o">=</span><span class="n">hlmarker</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">)</span>
                <span class="n">line</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dep_axis</span><span class="si">}</span><span class="s2">data&quot;</span><span class="p">:</span> <span class="n">hl_masked</span><span class="p">})</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span>
                        <span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">caplines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="n">errorbar_container</span> <span class="o">=</span> <span class="n">ErrorbarContainer</span><span class="p">(</span>
            <span class="p">(</span><span class="n">data_line</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">caplines</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">barcols</span><span class="p">)),</span>
            <span class="n">has_xerr</span><span class="o">=</span><span class="p">(</span><span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="n">has_yerr</span><span class="o">=</span><span class="p">(</span><span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errorbar_container</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">errorbar_container</span>  <span class="c1"># (l0, caplines, barcols)</span></div>

<div class="viewcode-block" id="Axes.boxplot"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.boxplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">boxplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">notch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usermedians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">meanline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showcaps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">showbox</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">boxprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">medianprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">meanprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">manage_ticks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">autorange</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">capwidths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw a box and whisker plot.</span>

<span class="sd">        The box extends from the first quartile (Q1) to the third</span>
<span class="sd">        quartile (Q3) of the data, with a line at the median.  The</span>
<span class="sd">        whiskers extend from the box by 1.5x the inter-quartile range</span>
<span class="sd">        (IQR).  Flier points are those past the end of the whiskers.</span>
<span class="sd">        See https://en.wikipedia.org/wiki/Box_plot for reference.</span>

<span class="sd">        .. code-block:: none</span>

<span class="sd">                  Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR</span>
<span class="sd">                               |-----:-----|</span>
<span class="sd">               o      |--------|     :     |--------|    o  o</span>
<span class="sd">                               |-----:-----|</span>
<span class="sd">             flier             &lt;-----------&gt;            fliers</span>
<span class="sd">                                    IQR</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : Array or a sequence of vectors.</span>
<span class="sd">            The input data.  If a 2D array, a boxplot is drawn for each column</span>
<span class="sd">            in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each</span>
<span class="sd">            array in *x*.</span>

<span class="sd">        notch : bool, default: False</span>
<span class="sd">            Whether to draw a notched boxplot (`True`), or a rectangular</span>
<span class="sd">            boxplot (`False`).  The notches represent the confidence interval</span>
<span class="sd">            (CI) around the median.  The documentation for *bootstrap*</span>
<span class="sd">            describes how the locations of the notches are computed by</span>
<span class="sd">            default, but their locations may also be overridden by setting the</span>
<span class="sd">            *conf_intervals* parameter.</span>

<span class="sd">            .. note::</span>

<span class="sd">                In cases where the values of the CI are less than the</span>
<span class="sd">                lower quartile or greater than the upper quartile, the</span>
<span class="sd">                notches will extend beyond the box, giving it a</span>
<span class="sd">                distinctive &quot;flipped&quot; appearance. This is expected</span>
<span class="sd">                behavior and consistent with other statistical</span>
<span class="sd">                visualization packages.</span>

<span class="sd">        sym : str, optional</span>
<span class="sd">            The default symbol for flier points.  An empty string (&#39;&#39;) hides</span>
<span class="sd">            the fliers.  If `None`, then the fliers default to &#39;b+&#39;.  More</span>
<span class="sd">            control is provided by the *flierprops* parameter.</span>

<span class="sd">        vert : bool, default: True</span>
<span class="sd">            If `True`, draws vertical boxes.</span>
<span class="sd">            If `False`, draw horizontal boxes.</span>

<span class="sd">        whis : float or (float, float), default: 1.5</span>
<span class="sd">            The position of the whiskers.</span>

<span class="sd">            If a float, the lower whisker is at the lowest datum above</span>
<span class="sd">            ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum</span>
<span class="sd">            below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and</span>
<span class="sd">            third quartiles.  The default value of ``whis = 1.5`` corresponds</span>
<span class="sd">            to Tukey&#39;s original definition of boxplots.</span>

<span class="sd">            If a pair of floats, they indicate the percentiles at which to</span>
<span class="sd">            draw the whiskers (e.g., (5, 95)).  In particular, setting this to</span>
<span class="sd">            (0, 100) results in whiskers covering the whole range of the data.</span>

<span class="sd">            In the edge case where ``Q1 == Q3``, *whis* is automatically set</span>
<span class="sd">            to (0, 100) (cover the whole range of the data) if *autorange* is</span>
<span class="sd">            True.</span>

<span class="sd">            Beyond the whiskers, data are considered outliers and are plotted</span>
<span class="sd">            as individual points.</span>

<span class="sd">        bootstrap : int, optional</span>
<span class="sd">            Specifies whether to bootstrap the confidence intervals</span>
<span class="sd">            around the median for notched boxplots. If *bootstrap* is</span>
<span class="sd">            None, no bootstrapping is performed, and notches are</span>
<span class="sd">            calculated using a Gaussian-based asymptotic approximation</span>
<span class="sd">            (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and</span>
<span class="sd">            Kendall and Stuart, 1967). Otherwise, bootstrap specifies</span>
<span class="sd">            the number of times to bootstrap the median to determine its</span>
<span class="sd">            95% confidence intervals. Values between 1000 and 10000 are</span>
<span class="sd">            recommended.</span>

<span class="sd">        usermedians : 1D array-like, optional</span>
<span class="sd">            A 1D array-like of length ``len(x)``.  Each entry that is not</span>
<span class="sd">            `None` forces the value of the median for the corresponding</span>
<span class="sd">            dataset.  For entries that are `None`, the medians are computed</span>
<span class="sd">            by Matplotlib as normal.</span>

<span class="sd">        conf_intervals : array-like, optional</span>
<span class="sd">            A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not</span>
<span class="sd">            None forces the location of the corresponding notch (which is</span>
<span class="sd">            only drawn if *notch* is `True`).  For entries that are `None`,</span>
<span class="sd">            the notches are computed by the method specified by the other</span>
<span class="sd">            parameters (e.g., *bootstrap*).</span>

<span class="sd">        positions : array-like, optional</span>
<span class="sd">            The positions of the boxes. The ticks and limits are</span>
<span class="sd">            automatically set to match the positions. Defaults to</span>
<span class="sd">            ``range(1, N+1)`` where N is the number of boxes to be drawn.</span>

<span class="sd">        widths : float or array-like</span>
<span class="sd">            The widths of the boxes.  The default is 0.5, or ``0.15*(distance</span>
<span class="sd">            between extreme positions)``, if that is smaller.</span>

<span class="sd">        patch_artist : bool, default: False</span>
<span class="sd">            If `False` produces boxes with the Line2D artist. Otherwise,</span>
<span class="sd">            boxes are drawn with Patch artists.</span>

<span class="sd">        labels : sequence, optional</span>
<span class="sd">            Labels for each dataset (one per dataset).</span>

<span class="sd">        manage_ticks : bool, default: True</span>
<span class="sd">            If True, the tick locations and labels will be adjusted to match</span>
<span class="sd">            the boxplot positions.</span>

<span class="sd">        autorange : bool, default: False</span>
<span class="sd">            When `True` and the data are distributed such that the 25th and</span>
<span class="sd">            75th percentiles are equal, *whis* is set to (0, 100) such</span>
<span class="sd">            that the whisker ends are at the minimum and maximum of the data.</span>

<span class="sd">        meanline : bool, default: False</span>
<span class="sd">            If `True` (and *showmeans* is `True`), will try to render the</span>
<span class="sd">            mean as a line spanning the full width of the box according to</span>
<span class="sd">            *meanprops* (see below).  Not recommended if *shownotches* is also</span>
<span class="sd">            True.  Otherwise, means will be shown as points.</span>

<span class="sd">        zorder : float, default: ``Line2D.zorder = 2``</span>
<span class="sd">            The zorder of the boxplot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          A dictionary mapping each component of the boxplot to a list</span>
<span class="sd">          of the `.Line2D` instances created. That dictionary has the</span>
<span class="sd">          following keys (assuming vertical boxplots):</span>

<span class="sd">          - ``boxes``: the main body of the boxplot showing the</span>
<span class="sd">            quartiles and the median&#39;s confidence intervals if</span>
<span class="sd">            enabled.</span>

<span class="sd">          - ``medians``: horizontal lines at the median of each box.</span>

<span class="sd">          - ``whiskers``: the vertical lines extending to the most</span>
<span class="sd">            extreme, non-outlier data points.</span>

<span class="sd">          - ``caps``: the horizontal lines at the ends of the</span>
<span class="sd">            whiskers.</span>

<span class="sd">          - ``fliers``: points representing data that extend beyond</span>
<span class="sd">            the whiskers (fliers).</span>

<span class="sd">          - ``means``: points or lines representing the means.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        showcaps : bool, default: True</span>
<span class="sd">            Show the caps on the ends of whiskers.</span>
<span class="sd">        showbox : bool, default: True</span>
<span class="sd">            Show the central box.</span>
<span class="sd">        showfliers : bool, default: True</span>
<span class="sd">            Show the outliers beyond the caps.</span>
<span class="sd">        showmeans : bool, default: False</span>
<span class="sd">            Show the arithmetic means.</span>
<span class="sd">        capprops : dict, default: None</span>
<span class="sd">            The style of the caps.</span>
<span class="sd">        capwidths : float or array, default: None</span>
<span class="sd">            The widths of the caps.</span>
<span class="sd">        boxprops : dict, default: None</span>
<span class="sd">            The style of the box.</span>
<span class="sd">        whiskerprops : dict, default: None</span>
<span class="sd">            The style of the whiskers.</span>
<span class="sd">        flierprops : dict, default: None</span>
<span class="sd">            The style of the fliers.</span>
<span class="sd">        medianprops : dict, default: None</span>
<span class="sd">            The style of the median.</span>
<span class="sd">        meanprops : dict, default: None</span>
<span class="sd">            The style of the mean.</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        violinplot : Draw an estimate of the probability density function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Missing arguments default to rcParams.</span>
        <span class="k">if</span> <span class="n">whis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whis</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.whiskers&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bootstrap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bootstrap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.bootstrap&#39;</span><span class="p">]</span>

        <span class="n">bxpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">boxplot_stats</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="n">whis</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="n">bootstrap</span><span class="p">,</span>
                                       <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">autorange</span><span class="o">=</span><span class="n">autorange</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">notch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">notch</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.notch&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vert</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vert</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.vertical&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">patch_artist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">patch_artist</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.patchartist&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">meanline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meanline</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.meanline&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showmeans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showmeans</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showmeans&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showcaps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showcaps</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showcaps&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showbox</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showbox&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showfliers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showfliers</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showfliers&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">boxprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">boxprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">whiskerprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whiskerprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">capprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">medianprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">medianprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">meanprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meanprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">flierprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flierprops</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
            <span class="n">boxprops</span><span class="p">[</span><span class="s1">&#39;linestyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;solid&#39;</span>  <span class="c1"># Not consistent with bxp.</span>
            <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">boxprops</span><span class="p">:</span>
                <span class="n">boxprops</span><span class="p">[</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boxprops</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>

        <span class="c1"># if non-default sym value, put it into the flier dictionary</span>
        <span class="c1"># the logic for providing the default symbol (&#39;b+&#39;) now lives</span>
        <span class="c1"># in bxp in the initial value of flierkw</span>
        <span class="c1"># handle all of the *sym* related logic here so we only have to pass</span>
        <span class="c1"># on the flierprops dict.</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no-flier case, which should really be done with</span>
            <span class="c1"># &#39;showfliers=False&#39; but none-the-less deal with it to keep back</span>
            <span class="c1"># compatibility</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># blow away existing dict and make one for invisible markers</span>
                <span class="n">flierprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
                <span class="c1"># turn the fliers off just to be safe</span>
                <span class="n">showfliers</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># now process the symbol string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># process the symbol string</span>
                <span class="c1"># discarded linestyle</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
                <span class="c1"># if we have a marker, use it</span>
                <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;marker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker</span>
                <span class="c1"># if we have a color, use it</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># assume that if color is passed in the user want</span>
                    <span class="c1"># filled symbol, if the users want more control use</span>
                    <span class="c1"># flierprops</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;markerfacecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;markeredgecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

        <span class="c1"># replace medians if necessary:</span>
        <span class="k">if</span> <span class="n">usermedians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">usermedians</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">usermedians</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;usermedians&#39; and &#39;x&#39; have different lengths&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># reassign medians as necessary</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">med</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">usermedians</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">med</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span>

        <span class="k">if</span> <span class="n">conf_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conf_intervals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;conf_intervals&#39; and &#39;x&#39; have different lengths&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ci</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;each confidence interval must &#39;</span>
                                             <span class="s1">&#39;have two values&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">artists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bxp</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span>
                           <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="n">patch_artist</span><span class="p">,</span>
                           <span class="n">shownotches</span><span class="o">=</span><span class="n">notch</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showcaps</span><span class="o">=</span><span class="n">showcaps</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="n">showbox</span><span class="p">,</span>
                           <span class="n">boxprops</span><span class="o">=</span><span class="n">boxprops</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="n">flierprops</span><span class="p">,</span>
                           <span class="n">medianprops</span><span class="o">=</span><span class="n">medianprops</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="n">meanprops</span><span class="p">,</span>
                           <span class="n">meanline</span><span class="o">=</span><span class="n">meanline</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="n">showfliers</span><span class="p">,</span>
                           <span class="n">capprops</span><span class="o">=</span><span class="n">capprops</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="n">whiskerprops</span><span class="p">,</span>
                           <span class="n">manage_ticks</span><span class="o">=</span><span class="n">manage_ticks</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
                           <span class="n">capwidths</span><span class="o">=</span><span class="n">capwidths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">artists</span></div>

<div class="viewcode-block" id="Axes.bxp"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.bxp">[docs]</a>    <span class="k">def</span> <span class="nf">bxp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">patch_artist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shownotches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">showcaps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">boxprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">medianprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">meanline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">manage_ticks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">capwidths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drawing function for box and whisker plots.</span>

<span class="sd">        Make a box and whisker plot for each column of *x* or each</span>
<span class="sd">        vector in sequence *x*.  The box extends from the lower to</span>
<span class="sd">        upper quartile values of the data, with a line at the median.</span>
<span class="sd">        The whiskers extend from the box to show the range of the</span>
<span class="sd">        data.  Flier points are those past the end of the whiskers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bxpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each boxplot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``med``: Median (scalar).</span>
<span class="sd">          - ``q1``, ``q3``: First &amp; third quartiles (scalars).</span>
<span class="sd">          - ``whislo``, ``whishi``: Lower &amp; upper whisker positions (scalars).</span>

<span class="sd">          Optional keys are:</span>

<span class="sd">          - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.</span>
<span class="sd">          - ``fliers``: Data beyond the whiskers (array-like).</span>
<span class="sd">            Needed if ``showfliers=True``.</span>
<span class="sd">          - ``cilo``, ``cihi``: Lower &amp; upper confidence intervals</span>
<span class="sd">            about the median. Needed if ``shownotches=True``.</span>
<span class="sd">          - ``label``: Name of the dataset (str).  If available,</span>
<span class="sd">            this will be used a tick label for the boxplot</span>

<span class="sd">        positions : array-like, default: [1, 2, ..., n]</span>
<span class="sd">          The positions of the boxes. The ticks and limits</span>
<span class="sd">          are automatically set to match the positions.</span>

<span class="sd">        widths : float or array-like, default: None</span>
<span class="sd">          The widths of the boxes.  The default is</span>
<span class="sd">          ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.</span>

<span class="sd">        capwidths : float or array-like, default: None</span>
<span class="sd">          Either a scalar or a vector and sets the width of each cap.</span>
<span class="sd">          The default is ``0.5*(with of the box)``, see *widths*.</span>

<span class="sd">        vert : bool, default: True</span>
<span class="sd">          If `True` (default), makes the boxes vertical.</span>
<span class="sd">          If `False`, makes horizontal boxes.</span>

<span class="sd">        patch_artist : bool, default: False</span>
<span class="sd">          If `False` produces boxes with the `.Line2D` artist.</span>
<span class="sd">          If `True` produces boxes with the `~matplotlib.patches.Patch` artist.</span>

<span class="sd">        shownotches, showmeans, showcaps, showbox, showfliers : bool</span>
<span class="sd">          Whether to draw the CI notches, the mean value (both default to</span>
<span class="sd">          False), the caps, the box, and the fliers (all three default to</span>
<span class="sd">          True).</span>

<span class="sd">        boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\</span>
<span class="sd"> dict, optional</span>
<span class="sd">          Artist properties for the boxes, whiskers, caps, fliers, medians, and</span>
<span class="sd">          means.</span>

<span class="sd">        meanline : bool, default: False</span>
<span class="sd">          If `True` (and *showmeans* is `True`), will try to render the mean</span>
<span class="sd">          as a line spanning the full width of the box according to</span>
<span class="sd">          *meanprops*. Not recommended if *shownotches* is also True.</span>
<span class="sd">          Otherwise, means will be shown as points.</span>

<span class="sd">        manage_ticks : bool, default: True</span>
<span class="sd">          If True, the tick locations and labels will be adjusted to match the</span>
<span class="sd">          boxplot positions.</span>

<span class="sd">        zorder : float, default: ``Line2D.zorder = 2``</span>
<span class="sd">          The zorder of the resulting boxplot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          A dictionary mapping each component of the boxplot to a list</span>
<span class="sd">          of the `.Line2D` instances created. That dictionary has the</span>
<span class="sd">          following keys (assuming vertical boxplots):</span>

<span class="sd">          - ``boxes``: main bodies of the boxplot showing the quartiles, and</span>
<span class="sd">            the median&#39;s confidence intervals if enabled.</span>
<span class="sd">          - ``medians``: horizontal lines at the median of each box.</span>
<span class="sd">          - ``whiskers``: vertical lines up to the last non-outlier data.</span>
<span class="sd">          - ``caps``: horizontal lines at the ends of the whiskers.</span>
<span class="sd">          - ``fliers``: points representing data beyond the whiskers (fliers).</span>
<span class="sd">          - ``means``: points or lines representing the means.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: gallery/statistics/bxp.py</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># lists of artists to be output</span>
        <span class="n">whiskers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fliers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># empty list of xticklabels</span>
        <span class="n">datalabels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Use default zorder if none specified</span>
        <span class="k">if</span> <span class="n">zorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zorder</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">zorder</span>

        <span class="n">zdelta</span> <span class="o">=</span> <span class="mf">0.1</span>

        <span class="k">def</span> <span class="nf">merge_kw_rc</span><span class="p">(</span><span class="n">subkey</span><span class="p">,</span> <span class="n">explicit</span><span class="p">,</span> <span class="n">zdelta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">usemarker</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                 <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;boxplot.</span><span class="si">{</span><span class="n">subkey</span><span class="si">}</span><span class="s1">props&#39;</span><span class="p">)}</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;zorder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span> <span class="o">+</span> <span class="n">zdelta</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">usemarker</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;marker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">explicit</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="n">box_kw</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.boxprops.linestyle&#39;</span><span class="p">],</span>
            <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.boxprops.linewidth&#39;</span><span class="p">],</span>
            <span class="s1">&#39;edgecolor&#39;</span><span class="p">:</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.boxprops.color&#39;</span><span class="p">],</span>
            <span class="s1">&#39;facecolor&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;white&#39;</span> <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]</span>
                          <span class="k">else</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;patch.facecolor&#39;</span><span class="p">]),</span>
            <span class="s1">&#39;zorder&#39;</span><span class="p">:</span> <span class="n">zorder</span><span class="p">,</span>
            <span class="o">**</span><span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">boxprops</span><span class="p">,</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">if</span> <span class="n">patch_artist</span> <span class="k">else</span> <span class="n">merge_kw_rc</span><span class="p">(</span><span class="s1">&#39;box&#39;</span><span class="p">,</span> <span class="n">boxprops</span><span class="p">,</span> <span class="n">usemarker</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">whisker_kw</span> <span class="o">=</span> <span class="n">merge_kw_rc</span><span class="p">(</span><span class="s1">&#39;whisker&#39;</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="p">,</span> <span class="n">usemarker</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cap_kw</span> <span class="o">=</span> <span class="n">merge_kw_rc</span><span class="p">(</span><span class="s1">&#39;cap&#39;</span><span class="p">,</span> <span class="n">capprops</span><span class="p">,</span> <span class="n">usemarker</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">flier_kw</span> <span class="o">=</span> <span class="n">merge_kw_rc</span><span class="p">(</span><span class="s1">&#39;flier&#39;</span><span class="p">,</span> <span class="n">flierprops</span><span class="p">)</span>
        <span class="n">median_kw</span> <span class="o">=</span> <span class="n">merge_kw_rc</span><span class="p">(</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">medianprops</span><span class="p">,</span> <span class="n">zdelta</span><span class="p">,</span> <span class="n">usemarker</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mean_kw</span> <span class="o">=</span> <span class="n">merge_kw_rc</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">meanprops</span><span class="p">,</span> <span class="n">zdelta</span><span class="p">)</span>
        <span class="n">removed_prop</span> <span class="o">=</span> <span class="s1">&#39;marker&#39;</span> <span class="k">if</span> <span class="n">meanline</span> <span class="k">else</span> <span class="s1">&#39;linestyle&#39;</span>
        <span class="c1"># Only remove the property if it&#39;s not set explicitly as a parameter.</span>
        <span class="k">if</span> <span class="n">meanprops</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">removed_prop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">meanprops</span><span class="p">:</span>
            <span class="n">mean_kw</span><span class="p">[</span><span class="n">removed_prop</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># vertical or horizontal plot?</span>
        <span class="n">maybe_swap</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">vert</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">do_plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">][</span><span class="n">maybe_swap</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">do_patch</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">_create_closed</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">][</span><span class="n">maybe_swap</span><span class="p">]))</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">patch</span>

        <span class="c1"># input validation</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;List of boxplot statistics and `</span><span class="si">{0}</span><span class="s2">` &quot;</span>
                             <span class="s2">&quot;values must have same the length&quot;</span><span class="p">)</span>
        <span class="c1"># check position</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;positions&quot;</span><span class="p">))</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;positions should be an iterable of numbers&quot;</span><span class="p">)</span>

        <span class="c1"># width</span>
        <span class="k">if</span> <span class="n">widths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.15</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;widths&quot;</span><span class="p">))</span>

        <span class="c1"># capwidth</span>
        <span class="k">if</span> <span class="n">capwidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capwidths</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">capwidths</span><span class="p">):</span>
            <span class="n">capwidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">capwidths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">capwidths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;capwidths&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">capwidth</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">,</span>
                                               <span class="n">capwidths</span><span class="p">):</span>
            <span class="c1"># try to find a new label</span>
            <span class="n">datalabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>

            <span class="c1"># whisker coords</span>
            <span class="n">whis_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span>
            <span class="n">whislo_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whislo&#39;</span><span class="p">]]</span>
            <span class="n">whishi_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whishi&#39;</span><span class="p">]]</span>
            <span class="c1"># cap coords</span>
            <span class="n">cap_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">capwidth</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">cap_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">capwidth</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">cap_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">cap_left</span><span class="p">,</span> <span class="n">cap_right</span><span class="p">]</span>
            <span class="n">cap_lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whislo&#39;</span><span class="p">])</span>
            <span class="n">cap_hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whishi&#39;</span><span class="p">])</span>
            <span class="c1"># box and median coords</span>
            <span class="n">box_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">box_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">med_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">]]</span>
            <span class="c1"># notched boxes</span>
            <span class="k">if</span> <span class="n">shownotches</span><span class="p">:</span>
                <span class="n">notch_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
                <span class="n">notch_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">notch_right</span><span class="p">,</span>
                         <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">notch_left</span><span class="p">,</span>
                         <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">notch_left</span><span class="p">,</span> <span class="n">notch_right</span><span class="p">]</span>
            <span class="c1"># plain boxes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">]</span>

            <span class="c1"># maybe draw the box</span>
            <span class="k">if</span> <span class="n">showbox</span><span class="p">:</span>
                <span class="n">do_box</span> <span class="o">=</span> <span class="n">do_patch</span> <span class="k">if</span> <span class="n">patch_artist</span> <span class="k">else</span> <span class="n">do_plot</span>
                <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_box</span><span class="p">(</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">,</span> <span class="o">**</span><span class="n">box_kw</span><span class="p">))</span>
            <span class="c1"># draw the whiskers</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">(</span><span class="n">whis_x</span><span class="p">,</span> <span class="n">whislo_y</span><span class="p">,</span> <span class="o">**</span><span class="n">whisker_kw</span><span class="p">))</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">(</span><span class="n">whis_x</span><span class="p">,</span> <span class="n">whishi_y</span><span class="p">,</span> <span class="o">**</span><span class="n">whisker_kw</span><span class="p">))</span>
            <span class="c1"># maybe draw the caps</span>
            <span class="k">if</span> <span class="n">showcaps</span><span class="p">:</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_lo</span><span class="p">,</span> <span class="o">**</span><span class="n">cap_kw</span><span class="p">))</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_hi</span><span class="p">,</span> <span class="o">**</span><span class="n">cap_kw</span><span class="p">))</span>
            <span class="c1"># draw the medians</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">(</span><span class="n">med_x</span><span class="p">,</span> <span class="n">med_y</span><span class="p">,</span> <span class="o">**</span><span class="n">median_kw</span><span class="p">))</span>
            <span class="c1"># maybe draw the means</span>
            <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">meanline</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]],</span>
                        <span class="o">**</span><span class="n">mean_kw</span>
                    <span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">([</span><span class="n">pos</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]],</span> <span class="o">**</span><span class="n">mean_kw</span><span class="p">))</span>
            <span class="c1"># maybe draw the fliers</span>
            <span class="k">if</span> <span class="n">showfliers</span><span class="p">:</span>
                <span class="n">flier_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fliers&#39;</span><span class="p">]),</span> <span class="n">pos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">flier_y</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fliers&#39;</span><span class="p">]</span>
                <span class="n">fliers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_plot</span><span class="p">(</span><span class="n">flier_x</span><span class="p">,</span> <span class="n">flier_y</span><span class="p">,</span> <span class="o">**</span><span class="n">flier_kw</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">manage_ticks</span><span class="p">:</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span> <span class="k">if</span> <span class="n">vert</span> <span class="k">else</span> <span class="s2">&quot;y&quot;</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;interval</span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s2">axis&quot;</span><span class="p">)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
            <span class="c1"># The 0.5 additional padding ensures reasonable-looking boxes</span>
            <span class="c1"># even when drawing a single box.  We set the sticky edge to</span>
            <span class="c1"># prevent margins expansion, in order to match old behavior (back</span>
            <span class="c1"># when separate calls to boxplot() would completely reset the axis</span>
            <span class="c1"># limits regardless of what was drawn before).  The sticky edges</span>
            <span class="c1"># are attached to the median lines, as they are always present.</span>
            <span class="n">interval</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">-</span> <span class="mf">.5</span><span class="p">),</span>
                           <span class="nb">max</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">+</span> <span class="mf">.5</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">median</span><span class="p">,</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">median</span><span class="o">.</span><span class="n">sticky_edges</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">position</span> <span class="o">-</span> <span class="mf">.5</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="mf">.5</span><span class="p">])</span>
            <span class="c1"># Modified from Axis.set_ticks and Axis.set_ticklabels.</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_major_locator</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">get_major_locator</span><span class="p">(),</span>
                              <span class="n">mticker</span><span class="o">.</span><span class="n">FixedLocator</span><span class="p">):</span>
                <span class="n">locator</span> <span class="o">=</span> <span class="n">mticker</span><span class="o">.</span><span class="n">FixedLocator</span><span class="p">([])</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
            <span class="n">locator</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">locator</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="o">*</span><span class="n">positions</span><span class="p">])</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_major_formatter</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">get_major_formatter</span><span class="p">(),</span>
                              <span class="n">mticker</span><span class="o">.</span><span class="n">FixedFormatter</span><span class="p">):</span>
                <span class="n">formatter</span> <span class="o">=</span> <span class="n">mticker</span><span class="o">.</span><span class="n">FixedFormatter</span><span class="p">([])</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
            <span class="n">formatter</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">formatter</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="o">*</span><span class="n">datalabels</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">whiskers</span><span class="o">=</span><span class="n">whiskers</span><span class="p">,</span> <span class="n">caps</span><span class="o">=</span><span class="n">caps</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="n">boxes</span><span class="p">,</span>
                    <span class="n">medians</span><span class="o">=</span><span class="n">medians</span><span class="p">,</span> <span class="n">fliers</span><span class="o">=</span><span class="n">fliers</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_scatter_color_args</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span>
                                  <span class="n">get_next_color_func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to process color related arguments of `.Axes.scatter`.</span>

<span class="sd">        Argument precedence for facecolors:</span>

<span class="sd">        - c (if not None)</span>
<span class="sd">        - kwargs[&#39;facecolor&#39;]</span>
<span class="sd">        - kwargs[&#39;facecolors&#39;]</span>
<span class="sd">        - kwargs[&#39;color&#39;] (==kwcolor)</span>
<span class="sd">        - &#39;b&#39; if in classic mode else the result of ``get_next_color_func()``</span>

<span class="sd">        Argument precedence for edgecolors:</span>

<span class="sd">        - kwargs[&#39;edgecolor&#39;]</span>
<span class="sd">        - edgecolors (is an explicit kw argument in scatter())</span>
<span class="sd">        - kwargs[&#39;color&#39;] (==kwcolor)</span>
<span class="sd">        - &#39;face&#39; if not in classic mode else None</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : color or sequence or sequence of color or None</span>
<span class="sd">            See argument description of `.Axes.scatter`.</span>
<span class="sd">        edgecolors : color or sequence of color or {&#39;face&#39;, &#39;none&#39;} or None</span>
<span class="sd">            See argument description of `.Axes.scatter`.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Additional kwargs. If these keys exist, we pop and process them:</span>
<span class="sd">            &#39;facecolors&#39;, &#39;facecolor&#39;, &#39;edgecolor&#39;, &#39;color&#39;</span>
<span class="sd">            Note: The dict is modified by this function.</span>
<span class="sd">        xsize : int</span>
<span class="sd">            The size of the x and y arrays passed to `.Axes.scatter`.</span>
<span class="sd">        get_next_color_func : callable</span>
<span class="sd">            A callable that returns a color. This color is used as facecolor</span>
<span class="sd">            if no other color is provided.</span>

<span class="sd">            Note, that this is a function rather than a fixed color value to</span>
<span class="sd">            support conditional evaluation of the next color.  As of the</span>
<span class="sd">            current implementation obtaining the next color from the</span>
<span class="sd">            property cycle advances the cycle. This must only happen if we</span>
<span class="sd">            actually use the color, which will only be decided within this</span>
<span class="sd">            method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c</span>
<span class="sd">            The input *c* if it was not *None*, else a color derived from the</span>
<span class="sd">            other inputs or defaults.</span>
<span class="sd">        colors : array(N, 4) or None</span>
<span class="sd">            The facecolors as RGBA values, or *None* if a colormap is used.</span>
<span class="sd">        edgecolors</span>
<span class="sd">            The edgecolor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">facecolors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;facecolors&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">facecolors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;facecolor&#39;</span><span class="p">,</span> <span class="n">facecolors</span><span class="p">)</span>
        <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">)</span>

        <span class="n">kwcolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwcolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Supply a &#39;c&#39; argument or a &#39;color&#39;&quot;</span>
                             <span class="s2">&quot; kwarg but not both; they differ but&quot;</span>
                             <span class="s2">&quot; their functionalities overlap.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwcolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">kwcolor</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;color&#39; kwarg must be a color or sequence of color &quot;</span>
                    <span class="s2">&quot;specs.  For a sequence of values to be color-mapped, use &quot;</span>
                    <span class="s2">&quot;the &#39;c&#39; argument instead.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">kwcolor</span>
            <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">facecolors</span> <span class="o">=</span> <span class="n">kwcolor</span>

        <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;scatter.edgecolors&#39;</span><span class="p">]</span>

        <span class="n">c_was_none</span> <span class="o">=</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">facecolors</span> <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                 <span class="k">else</span> <span class="s2">&quot;b&quot;</span> <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]</span>
                 <span class="k">else</span> <span class="n">get_next_color_func</span><span class="p">())</span>
        <span class="n">c_is_string_or_strings</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">_safe_first_finite</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">str</span><span class="p">)))</span>

        <span class="k">def</span> <span class="nf">invalid_shape_exception</span><span class="p">(</span><span class="n">csize</span><span class="p">,</span> <span class="n">xsize</span><span class="p">):</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;c&#39; argument has </span><span class="si">{</span><span class="n">csize</span><span class="si">}</span><span class="s2"> elements, which is inconsistent &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with &#39;x&#39; and &#39;y&#39; with size </span><span class="si">{</span><span class="n">xsize</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">c_is_mapped</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Unless proven otherwise below.</span>
        <span class="n">valid_shape</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Unless proven otherwise below.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c_was_none</span> <span class="ow">and</span> <span class="n">kwcolor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">c_is_string_or_strings</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># First, does &#39;c&#39; look suitable for value-mapping?</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># Failed to convert to float array; must be color specs.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># handle the documented special case of a 2D array with 1</span>
                <span class="c1"># row which as RGB(A) to broadcast.</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">c_is_mapped</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">xsize</span><span class="p">:</span>
                        <span class="n">valid_shape</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># If c can be either mapped values or a RGB(A) color, prefer</span>
                <span class="c1"># the former if shapes match, the latter otherwise.</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">xsize</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="n">c_is_mapped</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Wrong size; it must not be intended for mapping.</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">3</span><span class="p">,),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)):</span>
                        <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;*c* argument looks like a single numeric RGB or &quot;</span>
                            <span class="s2">&quot;RGBA sequence, which should be avoided as value-&quot;</span>
                            <span class="s2">&quot;mapping will have precedence in case its length &quot;</span>
                            <span class="s2">&quot;matches with *x* &amp; *y*.  Please use the *color* &quot;</span>
                            <span class="s2">&quot;keyword-argument or provide a 2D array &quot;</span>
                            <span class="s2">&quot;with a single row if you intend to specify &quot;</span>
                            <span class="s2">&quot;the same RGB or RGBA value for all points.&quot;</span><span class="p">)</span>
                    <span class="n">valid_shape</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c_is_mapped</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># Is &#39;c&#39; acceptable as PathCollection facecolors?</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;RGBA values should be within 0-1 range&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">):</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_shape</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">invalid_shape_exception</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">xsize</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
                    <span class="c1"># Both the mapping *and* the RGBA conversion failed: pretty</span>
                    <span class="c1"># severe failure =&gt; one may appreciate a verbose feedback.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;c&#39; argument must be a color, a sequence of colors, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;or a sequence of numbers, not </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xsize</span><span class="p">):</span>
                    <span class="c1"># NB: remember that a single color is also acceptable.</span>
                    <span class="c1"># Besides *colors* will be an empty array if c == &#39;none&#39;.</span>
                    <span class="k">raise</span> <span class="n">invalid_shape_exception</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">),</span> <span class="n">xsize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># use cmap, norm after collection is created</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span>

<div class="viewcode-block" id="Axes.scatter"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.scatter">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidths&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;edgecolors&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;facecolor&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;facecolors&quot;</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">interpd</span>
    <span class="k">def</span> <span class="nf">scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plotnonfinite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A scatter plot of *y* vs. *x* with varying marker size and/or color.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : float or array-like, shape (n, )</span>
<span class="sd">            The data positions.</span>

<span class="sd">        s : float or array-like, shape (n, ), optional</span>
<span class="sd">            The marker size in points**2 (typographic points are 1/72 in.).</span>
<span class="sd">            Default is ``rcParams[&#39;lines.markersize&#39;] ** 2``.</span>

<span class="sd">        c : array-like or list of colors or color, optional</span>
<span class="sd">            The marker colors. Possible values:</span>

<span class="sd">            - A scalar or sequence of n numbers to be mapped to colors using</span>
<span class="sd">              *cmap* and *norm*.</span>
<span class="sd">            - A 2D array in which the rows are RGB or RGBA.</span>
<span class="sd">            - A sequence of colors of length n.</span>
<span class="sd">            - A single color format string.</span>

<span class="sd">            Note that *c* should not be a single numeric RGB or RGBA sequence</span>
<span class="sd">            because that is indistinguishable from an array of values to be</span>
<span class="sd">            colormapped. If you want to specify the same RGB or RGBA value for</span>
<span class="sd">            all points, use a 2D array with a single row.  Otherwise, value-</span>
<span class="sd">            matching will have precedence in case of a size matching with *x*</span>
<span class="sd">            and *y*.</span>

<span class="sd">            If you wish to specify a single color for all points</span>
<span class="sd">            prefer the *color* keyword argument.</span>

<span class="sd">            Defaults to `None`. In that case the marker color is determined</span>
<span class="sd">            by the value of *color*, *facecolor* or *facecolors*. In case</span>
<span class="sd">            those are not specified or `None`, the marker color is determined</span>
<span class="sd">            by the next color of the ``Axes``&#39; current &quot;shape and fill&quot; color</span>
<span class="sd">            cycle. This cycle defaults to :rc:`axes.prop_cycle`.</span>

<span class="sd">        marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`</span>
<span class="sd">            The marker style. *marker* can be either an instance of the class</span>
<span class="sd">            or the text shorthand for a particular marker.</span>
<span class="sd">            See :mod:`matplotlib.markers` for more information about marker</span>
<span class="sd">            styles.</span>

<span class="sd">        %(cmap_doc)s</span>

<span class="sd">            This parameter is ignored if *c* is RGB(A).</span>

<span class="sd">        %(norm_doc)s</span>

<span class="sd">            This parameter is ignored if *c* is RGB(A).</span>

<span class="sd">        %(vmin_vmax_doc)s</span>

<span class="sd">            This parameter is ignored if *c* is RGB(A).</span>

<span class="sd">        alpha : float, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        linewidths : float or array-like, default: :rc:`lines.linewidth`</span>
<span class="sd">            The linewidth of the marker edges. Note: The default *edgecolors*</span>
<span class="sd">            is &#39;face&#39;. You may want to change this as well.</span>

<span class="sd">        edgecolors : {&#39;face&#39;, &#39;none&#39;, *None*} or color or sequence of color, \</span>
<span class="sd">default: :rc:`scatter.edgecolors`</span>
<span class="sd">            The edge color of the marker. Possible values:</span>

<span class="sd">            - &#39;face&#39;: The edge color will always be the same as the face color.</span>
<span class="sd">            - &#39;none&#39;: No patch boundary will be drawn.</span>
<span class="sd">            - A color or sequence of colors.</span>

<span class="sd">            For non-filled markers, *edgecolors* is ignored. Instead, the color</span>
<span class="sd">            is determined like with &#39;face&#39;, i.e. from *c*, *colors*, or</span>
<span class="sd">            *facecolors*.</span>

<span class="sd">        plotnonfinite : bool, default: False</span>
<span class="sd">            Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``</span>
<span class="sd">            or ``nan``). If ``True`` the points are drawn with the *bad*</span>
<span class="sd">            colormap color (see `.Colormap.set_bad`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.collections.PathCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>
<span class="sd">        **kwargs : `~matplotlib.collections.Collection` properties</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        plot : To plot scatter plots when markers are identical in size and</span>
<span class="sd">            color.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The `.plot` function will be faster for scatterplots where markers</span>
<span class="sd">          don&#39;t vary in size or color.</span>

<span class="sd">        * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which</span>
<span class="sd">          case all masks will be combined and only unmasked points will be</span>
<span class="sd">          plotted.</span>

<span class="sd">        * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*</span>
<span class="sd">          may be input as N-D arrays, but within scatter they will be</span>
<span class="sd">          flattened. The exception is *c*, which will be flattened only if its</span>
<span class="sd">          size matches the size of *x* and *y*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process **kwargs to handle aliases, conflicts with explicit kwargs:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># np.ma.ravel yields an ndarray, not a masked array,</span>
        <span class="c1"># unless its argument is a masked array.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be the same size&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span> <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]</span> <span class="k">else</span>
                 <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.markersize&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;s must be a scalar, &quot;</span>
                <span class="s2">&quot;or float array-like with the same size as x and y&quot;</span><span class="p">)</span>

        <span class="c1"># get the original edgecolor the user passed before we normalize</span>
        <span class="n">orig_edgecolor</span> <span class="o">=</span> <span class="n">edgecolors</span>
        <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orig_edgecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_scatter_color_args</span><span class="p">(</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">get_next_color_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plotnonfinite</span> <span class="ow">and</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span> <span class="o">=</span> \
                <span class="n">cbook</span><span class="o">.</span><span class="n">_combine_masks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span> <span class="o">=</span> \
                <span class="n">cbook</span><span class="o">.</span><span class="n">_combine_masks</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>
        <span class="c1"># Unmask edgecolors if it was actually a single RGB or RGBA.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">orig_edgecolor</span><span class="p">)):</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">edgecolors</span><span class="o">.</span><span class="n">data</span>

        <span class="n">scales</span> <span class="o">=</span> <span class="n">s</span>   <span class="c1"># Renamed for readability below.</span>

        <span class="c1"># load default marker from rcParams</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;scatter.marker&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">):</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">marker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span>
            <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_transform</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">is_filled</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">orig_edgecolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;You passed a edgecolor/edgecolors (</span><span class="si">{</span><span class="n">orig_edgecolor</span><span class="si">!r}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for an unfilled marker (</span><span class="si">{</span><span class="n">marker</span><span class="si">!r}</span><span class="s2">).  Matplotlib is &quot;</span>
                    <span class="s2">&quot;ignoring the edgecolor in favor of the facecolor.  This &quot;</span>
                    <span class="s2">&quot;behavior may change in the future.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># We need to handle markers that can not be filled (like</span>
            <span class="c1"># &#39;+&#39; and &#39;x&#39;) differently than markers that can be</span>
            <span class="c1"># filled, but have their fillstyle set to &#39;none&#39;.  This is</span>
            <span class="c1"># to get:</span>
            <span class="c1">#</span>
            <span class="c1">#  - respecting the fillestyle if set</span>
            <span class="c1">#  - maintaining back-compatibility for querying the facecolor of</span>
            <span class="c1">#    the un-fillable markers.</span>
            <span class="c1">#</span>
            <span class="c1"># While not an ideal situation, but is better than the</span>
            <span class="c1"># alternatives.</span>
            <span class="k">if</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_fillstyle</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="c1"># promote the facecolor to be the edgecolor</span>
                <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">colors</span>
                <span class="c1"># set the facecolor to &#39;none&#39; (at the last chance) because</span>
                <span class="c1"># we can not fill a path if the facecolor is non-null</span>
                <span class="c1"># (which is defendable at the renderer level).</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if we are not nulling the face color we can do this</span>
                <span class="c1"># simpler</span>
                <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;face&#39;</span>

            <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">lw</span> <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">lw</span> <span class="ow">in</span> <span class="n">linewidths</span><span class="p">]</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">(</span>
            <span class="p">(</span><span class="n">path</span><span class="p">,),</span> <span class="n">scales</span><span class="p">,</span>
            <span class="n">facecolors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
            <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
            <span class="n">offset_transform</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">),</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">_scale_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extra_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="n">cmap</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span> <span class="s1">&#39;vmin&#39;</span><span class="p">:</span> <span class="n">vmin</span><span class="p">,</span> <span class="s1">&#39;vmax&#39;</span><span class="p">:</span> <span class="n">vmax</span>
                    <span class="p">}</span>
            <span class="n">extra_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">extra_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">extra_keys</span><span class="p">):</span>
                <span class="n">keys_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_keys</span><span class="p">)</span>
                <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span>
                    <span class="s2">&quot;No data for colormapping provided via &#39;c&#39;. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameters </span><span class="si">{</span><span class="n">keys_str</span><span class="si">}</span><span class="s2"> will be ignored&quot;</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Classic mode only:</span>
        <span class="c1"># ensure there are margins to allow for the</span>
        <span class="c1"># finite size of the symbols.  In v2.x, margins</span>
        <span class="c1"># are present by default, so we disable this</span>
        <span class="c1"># scatter-specific override.</span>
        <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xmargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ymargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_ymargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.hexbin"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.hexbin">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gridsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">xscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">yscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span>
               <span class="n">reduce_C_function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">mincnt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marginals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a 2D hexagonal binning plot of points *x*, *y*.</span>

<span class="sd">        If *C* is *None*, the value of the hexagon is determined by the number</span>
<span class="sd">        of points in the hexagon. Otherwise, *C* specifies values at the</span>
<span class="sd">        coordinate (x[i], y[i]). For each hexagon, these values are reduced</span>
<span class="sd">        using *reduce_C_function*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like</span>
<span class="sd">            The data positions. *x* and *y* must be of the same length.</span>

<span class="sd">        C : array-like, optional</span>
<span class="sd">            If given, these values are accumulated in the bins. Otherwise,</span>
<span class="sd">            every point has a value of 1. Must be of the same length as *x*</span>
<span class="sd">            and *y*.</span>

<span class="sd">        gridsize : int or (int, int), default: 100</span>
<span class="sd">            If a single int, the number of hexagons in the *x*-direction.</span>
<span class="sd">            The number of hexagons in the *y*-direction is chosen such that</span>
<span class="sd">            the hexagons are approximately regular.</span>

<span class="sd">            Alternatively, if a tuple (*nx*, *ny*), the number of hexagons</span>
<span class="sd">            in the *x*-direction and the *y*-direction. In the</span>
<span class="sd">            *y*-direction, counting is done along vertically aligned</span>
<span class="sd">            hexagons, not along the zig-zag chains of hexagons; see the</span>
<span class="sd">            following illustration.</span>

<span class="sd">            .. plot::</span>

<span class="sd">               import numpy</span>
<span class="sd">               import matplotlib.pyplot as plt</span>

<span class="sd">               np.random.seed(19680801)</span>
<span class="sd">               n= 300</span>
<span class="sd">               x = np.random.standard_normal(n)</span>
<span class="sd">               y = np.random.standard_normal(n)</span>

<span class="sd">               fig, ax = plt.subplots(figsize=(4, 4))</span>
<span class="sd">               h = ax.hexbin(x, y, gridsize=(5, 3))</span>
<span class="sd">               hx, hy = h.get_offsets().T</span>
<span class="sd">               ax.plot(hx[24::3], hy[24::3], &#39;ro-&#39;)</span>
<span class="sd">               ax.plot(hx[-3:], hy[-3:], &#39;ro-&#39;)</span>
<span class="sd">               ax.set_title(&#39;gridsize=(5, 3)&#39;)</span>
<span class="sd">               ax.axis(&#39;off&#39;)</span>

<span class="sd">            To get approximately regular hexagons, choose</span>
<span class="sd">            :math:`n_x = \\sqrt{3}\\,n_y`.</span>

<span class="sd">        bins : &#39;log&#39; or int or sequence, default: None</span>
<span class="sd">            Discretization of the hexagon values.</span>

<span class="sd">            - If *None*, no binning is applied; the color of each hexagon</span>
<span class="sd">              directly corresponds to its count value.</span>
<span class="sd">            - If &#39;log&#39;, use a logarithmic scale for the colormap.</span>
<span class="sd">              Internally, :math:`log_{10}(i+1)` is used to determine the</span>
<span class="sd">              hexagon color. This is equivalent to ``norm=LogNorm()``.</span>
<span class="sd">            - If an integer, divide the counts in the specified number</span>
<span class="sd">              of bins, and color the hexagons accordingly.</span>
<span class="sd">            - If a sequence of values, the values of the lower bound of</span>
<span class="sd">              the bins to be used.</span>

<span class="sd">        xscale : {&#39;linear&#39;, &#39;log&#39;}, default: &#39;linear&#39;</span>
<span class="sd">            Use a linear or log10 scale on the horizontal axis.</span>

<span class="sd">        yscale : {&#39;linear&#39;, &#39;log&#39;}, default: &#39;linear&#39;</span>
<span class="sd">            Use a linear or log10 scale on the vertical axis.</span>

<span class="sd">        mincnt : int &gt; 0, default: *None*</span>
<span class="sd">            If not *None*, only display cells with more than *mincnt*</span>
<span class="sd">            number of points in the cell.</span>

<span class="sd">        marginals : bool, default: *False*</span>
<span class="sd">            If marginals is *True*, plot the marginal density as</span>
<span class="sd">            colormapped rectangles along the bottom of the x-axis and</span>
<span class="sd">            left of the y-axis.</span>

<span class="sd">        extent : 4-tuple of float, default: *None*</span>
<span class="sd">            The limits of the bins (xmin, xmax, ymin, ymax).</span>
<span class="sd">            The default assigns the limits based on</span>
<span class="sd">            *gridsize*, *x*, *y*, *xscale* and *yscale*.</span>

<span class="sd">            If *xscale* or *yscale* is set to &#39;log&#39;, the limits are</span>
<span class="sd">            expected to be the exponent for a power of 10. E.g. for</span>
<span class="sd">            x-limits of 1 and 50 in &#39;linear&#39; scale and y-limits</span>
<span class="sd">            of 10 and 1000 in &#39;log&#39; scale, enter (1, 50, 1, 3).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.collections.PolyCollection`</span>
<span class="sd">            A `.PolyCollection` defining the hexagonal bins.</span>

<span class="sd">            - `.PolyCollection.get_offsets` contains a Mx2 array containing</span>
<span class="sd">              the x, y positions of the M hexagon centers.</span>
<span class="sd">            - `.PolyCollection.get_array` contains the values of the M</span>
<span class="sd">              hexagons.</span>

<span class="sd">            If *marginals* is *True*, horizontal</span>
<span class="sd">            bar and vertical bar (both PolyCollections) will be attached</span>
<span class="sd">            to the return collection as attributes *hbar* and *vbar*.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        %(cmap_doc)s</span>

<span class="sd">        %(norm_doc)s</span>

<span class="sd">        %(vmin_vmax_doc)s</span>

<span class="sd">        alpha : float between 0 and 1, optional</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        linewidths : float, default: *None*</span>
<span class="sd">            If *None*, defaults to 1.0.</span>

<span class="sd">        edgecolors : {&#39;face&#39;, &#39;none&#39;, *None*} or color, default: &#39;face&#39;</span>
<span class="sd">            The color of the hexagon edges. Possible values are:</span>

<span class="sd">            - &#39;face&#39;: Draw the edges in the same color as the fill color.</span>
<span class="sd">            - &#39;none&#39;: No edges are drawn. This can sometimes lead to unsightly</span>
<span class="sd">              unpainted pixels between the hexagons.</span>
<span class="sd">            - *None*: Draw outlines in the default color.</span>
<span class="sd">            - An explicit color.</span>

<span class="sd">        reduce_C_function : callable, default: `numpy.mean`</span>
<span class="sd">            The function to aggregate *C* within the bins. It is ignored if</span>
<span class="sd">            *C* is not given. This must have the signature::</span>

<span class="sd">                def reduce_C_function(C: array) -&gt; float</span>

<span class="sd">            Commonly used functions are:</span>

<span class="sd">            - `numpy.mean`: average of the points</span>
<span class="sd">            - `numpy.sum`: integral of the point values</span>
<span class="sd">            - `numpy.amax`: value taken from the largest point</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs : `~matplotlib.collections.PolyCollection` properties</span>
<span class="sd">            All other keyword arguments are passed on to `.PolyCollection`:</span>

<span class="sd">            %(PolyCollection:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hist2d : 2D histogram rectangular bins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

        <span class="c1"># Set the size of the hexagon grid</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">gridsize</span><span class="p">):</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">gridsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">gridsize</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Count the number of data in each hexagon</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Will be log()&#39;d if necessary, and then rescaled.</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="n">y</span>

        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x contains non-positive values, so can not &quot;</span>
                                 <span class="s2">&quot;be log-scaled&quot;</span><span class="p">)</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y contains non-positive values, so can not &quot;</span>
                                 <span class="s2">&quot;be log-scaled&quot;</span><span class="p">)</span>
            <span class="n">ty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">tx</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="p">(</span><span class="n">ty</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ty</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># to avoid issues with singular data, expand the min/max pairs</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="n">nx1</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ny1</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nx2</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="n">ny2</span> <span class="o">=</span> <span class="n">ny</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span> <span class="o">+</span> <span class="n">nx2</span> <span class="o">*</span> <span class="n">ny2</span>

        <span class="c1"># In the x-direction, the hexagons exactly cover the region from</span>
        <span class="c1"># xmin to xmax. Need some padding to avoid roundoff errors.</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="mf">1.e-9</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">-=</span> <span class="n">padding</span>
        <span class="n">xmax</span> <span class="o">+=</span> <span class="n">padding</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">ny</span>
        <span class="c1"># Positions in hexagon index coordinates.</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sx</span>
        <span class="n">iy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ty</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sy</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">iy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">iy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># flat indices, plus one so that out-of-range points go to position 0.</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ix1</span> <span class="o">&lt;</span> <span class="n">nx1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">iy1</span> <span class="o">&lt;</span> <span class="n">ny1</span><span class="p">),</span>
                      <span class="n">ix1</span> <span class="o">*</span> <span class="n">ny1</span> <span class="o">+</span> <span class="n">iy1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ix2</span> <span class="o">&lt;</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">iy2</span> <span class="o">&lt;</span> <span class="n">ny2</span><span class="p">),</span>
                      <span class="n">ix2</span> <span class="o">*</span> <span class="n">ny2</span> <span class="o">+</span> <span class="n">iy2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">d1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="n">ix1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">iy</span> <span class="o">-</span> <span class="n">iy1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="n">ix2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">iy</span> <span class="o">-</span> <span class="n">iy2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">bdist</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># [1:] drops out-of-range points.</span>
            <span class="n">counts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">i1</span><span class="p">[</span><span class="n">bdist</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">counts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">i2</span><span class="p">[</span><span class="o">~</span><span class="n">bdist</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nx2</span> <span class="o">*</span> <span class="n">ny2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">counts1</span><span class="p">,</span> <span class="n">counts2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">accum</span><span class="p">[</span><span class="n">accum</span> <span class="o">&lt;</span> <span class="n">mincnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># store the C values in a list per hexagon index</span>
            <span class="n">Cs_at_i1</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">)]</span>
            <span class="n">Cs_at_i2</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nx2</span> <span class="o">*</span> <span class="n">ny2</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bdist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">Cs_at_i1</span><span class="p">[</span><span class="n">i1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Cs_at_i2</span><span class="p">[</span><span class="n">i2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mincnt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">reduce_C_function</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mincnt</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                 <span class="k">for</span> <span class="n">Cs_at_i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Cs_at_i1</span><span class="p">,</span> <span class="n">Cs_at_i2</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="n">Cs_at_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>  <span class="c1"># [1:] drops out-of-range points.</span>
                <span class="nb">float</span><span class="p">)</span>

        <span class="n">good_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx1</span><span class="p">),</span> <span class="n">ny1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny1</span><span class="p">),</span> <span class="n">nx1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ny2</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny2</span><span class="p">),</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sx</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sy</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xmin</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ymin</span>
        <span class="c1"># remove accumulation bins with no data</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="n">accum</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">]</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="p">[</span><span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span> <span class="ow">or</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmin</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="n">xscale</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymin</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">yscale</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="n">polygons</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="p">[</span><span class="n">polygon</span><span class="p">],</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
                <span class="n">offset_transform</span><span class="o">=</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">AffineDeltaTransform</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># Set normalizer if bins is &#39;log&#39;</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span><span class="s2">&quot;Only one of &#39;bins&#39; and &#39;norm&#39; arguments &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;can be supplied, ignoring bins=</span><span class="si">{</span><span class="n">bins</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># autoscale the norm with current accum values if it hasn&#39;t been set</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">norm</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
                <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">accum</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
                <span class="n">bins</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># one less edge than bins</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">minimum</span> <span class="o">+</span> <span class="p">(</span><span class="n">maximum</span> <span class="o">-</span> <span class="n">minimum</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">bins</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">_scale_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="p">((</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># add the collection last</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marginals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collection</span>

        <span class="c1"># Process marginals</span>
        <span class="n">bars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">zname</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zscale</span><span class="p">,</span> <span class="n">nbins</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xscale</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">yscale</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ny</span><span class="p">),</span>
        <span class="p">]:</span>

            <span class="k">if</span> <span class="n">zscale</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
                <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nbins</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">verts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">verts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">verts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">.00</span>
            <span class="n">verts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">.05</span>
            <span class="k">if</span> <span class="n">zname</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="n">verts</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Swap x and y.</span>

            <span class="c1"># Sort z-values into bins defined by bin_edges.</span>
            <span class="n">bin_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbins</span><span class="p">):</span>
                <span class="c1"># Get C-values for each bin, and compute bin value with</span>
                <span class="c1"># reduce_C_function.</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">bin_idxs</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">trans</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;get_</span><span class="si">{</span><span class="n">zname</span><span class="si">}</span><span class="s2">axis_transform&quot;</span><span class="p">)(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">)</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="n">verts</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">)</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">bars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">hbar</span><span class="p">,</span> <span class="n">collection</span><span class="o">.</span><span class="n">vbar</span> <span class="o">=</span> <span class="n">bars</span>

        <span class="k">def</span> <span class="nf">on_changed</span><span class="p">(</span><span class="n">collection</span><span class="p">):</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">vbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">vbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span> <span class="n">on_changed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.arrow"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.arrow">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">arrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an arrow to the Axes.</span>

<span class="sd">        This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(FancyArrow)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.FancyArrow`</span>
<span class="sd">            The created `.FancyArrow` object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The resulting arrow is affected by the Axes aspect ratio and limits.</span>
<span class="sd">        This may produce an arrow whose head is not square with its stem. To</span>
<span class="sd">        create an arrow whose head is square with its stem,</span>
<span class="sd">        use :meth:`annotate` for example:</span>

<span class="sd">        &gt;&gt;&gt; ax.annotate(&quot;&quot;, xy=(0.5, 0.5), xytext=(0, 0),</span>
<span class="sd">        ...             arrowprops=dict(arrowstyle=&quot;-&gt;&quot;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Strip away units for the underlying patch since units</span>
        <span class="c1"># do not make sense to most patch-like code</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">FancyArrow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Axes.quiverkey"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.quiverkey">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">quiverkey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qk</span></div>

    <span class="c1"># Handle units for x and y, if they&#39;ve been passed</span>
    <span class="k">def</span> <span class="nf">_quiver_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="c1"># args can by a combination if X, Y, U, V, C and all should be replaced</span>
<div class="viewcode-block" id="Axes.quiver"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.quiver">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;%(quiver_doc)s&quot;&quot;&quot;</span>
        <span class="c1"># Make sure units are handled for x and y values</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quiver_units</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span></div>

    <span class="c1"># args can be some combination of X, Y, U, V, C and all should be replaced</span>
<div class="viewcode-block" id="Axes.barbs"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.barbs">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;%(barbs_doc)s&quot;&quot;&quot;</span>
        <span class="c1"># Make sure units are handled for x and y values</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quiver_units</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">b</span></div>

    <span class="c1"># Uses a custom implementation of data-kwarg handling in</span>
    <span class="c1"># _process_plot_var_args.</span>
<div class="viewcode-block" id="Axes.fill"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.fill">[docs]</a>    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot filled polygons.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : sequence of x, y, [color]</span>
<span class="sd">            Each polygon is defined by the lists of *x* and *y* positions of</span>
<span class="sd">            its nodes, optionally followed by a *color* specifier. See</span>
<span class="sd">            :mod:`matplotlib.colors` for supported color specifiers. The</span>
<span class="sd">            standard color cycle is used for polygons without a color</span>
<span class="sd">            specifier.</span>

<span class="sd">            You can plot multiple polygons by providing multiple *x*, *y*,</span>
<span class="sd">            *[color]* groups.</span>

<span class="sd">            For example, each of the following is legal::</span>

<span class="sd">                ax.fill(x, y)                    # a polygon with default color</span>
<span class="sd">                ax.fill(x, y, &quot;b&quot;)               # a blue polygon</span>
<span class="sd">                ax.fill(x, y, x2, y2)            # two polygons</span>
<span class="sd">                ax.fill(x, y, &quot;b&quot;, x2, y2, &quot;r&quot;)  # a blue and a red polygon</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*, e.g.::</span>

<span class="sd">                ax.fill(&quot;time&quot;, &quot;signal&quot;,</span>
<span class="sd">                        data={&quot;time&quot;: [0, 1, 2], &quot;signal&quot;: [0, 1, 0]})</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of `~matplotlib.patches.Polygon`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.patches.Polygon` properties</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Use :meth:`fill_between` if you would like to fill the region between</span>
<span class="sd">        two curves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For compatibility(!), get aliases from Line2D rather than Patch.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">)</span>
        <span class="c1"># _get_patches_for_fill returns a generator, convert it to a list.</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">patches</span></div>

    <span class="k">def</span> <span class="nf">_fill_between_x_or_y</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">ind_dir</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">dep1</span><span class="p">,</span> <span class="n">dep2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Common implementation between fill_between (*ind_dir*=&quot;x&quot;) and</span>
        <span class="c1"># fill_betweenx (*ind_dir*=&quot;y&quot;).  *ind* is the independent variable,</span>
        <span class="c1"># *dep* the dependent variable.  The docstring below is interpolated</span>
        <span class="c1"># to generate both methods&#39; docstrings.</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill the area between two {dir} curves.</span>

<span class="sd">        The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,</span>
<span class="sd">        *{dep}2*).  This creates one or multiple polygons describing the filled</span>
<span class="sd">        area.</span>

<span class="sd">        You may exclude some {dir} sections from filling using *where*.</span>

<span class="sd">        By default, the edges connect the given points directly.  Use *step*</span>
<span class="sd">        if the filling should be a step function, i.e. constant in between</span>
<span class="sd">        *{ind}*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        {ind} : array (length N)</span>
<span class="sd">            The {ind} coordinates of the nodes defining the curves.</span>

<span class="sd">        {dep}1 : array (length N) or scalar</span>
<span class="sd">            The {dep} coordinates of the nodes defining the first curve.</span>

<span class="sd">        {dep}2 : array (length N) or scalar, default: 0</span>
<span class="sd">            The {dep} coordinates of the nodes defining the second curve.</span>

<span class="sd">        where : array of bool (length N), optional</span>
<span class="sd">            Define *where* to exclude some {dir} regions from being filled.</span>
<span class="sd">            The filled regions are defined by the coordinates ``{ind}[where]``.</span>
<span class="sd">            More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if</span>
<span class="sd">            ``where[i] and where[i+1]``.  Note that this definition implies</span>
<span class="sd">            that an isolated *True* value between two *False* values in *where*</span>
<span class="sd">            will not result in filling.  Both sides of the *True* position</span>
<span class="sd">            remain unfilled due to the adjacent *False* values.</span>

<span class="sd">        interpolate : bool, default: False</span>
<span class="sd">            This option is only relevant if *where* is used and the two curves</span>
<span class="sd">            are crossing each other.</span>

<span class="sd">            Semantically, *where* is often used for *{dep}1* &gt; *{dep}2* or</span>
<span class="sd">            similar.  By default, the nodes of the polygon defining the filled</span>
<span class="sd">            region will only be placed at the positions in the *{ind}* array.</span>
<span class="sd">            Such a polygon cannot describe the above semantics close to the</span>
<span class="sd">            intersection.  The {ind}-sections containing the intersection are</span>
<span class="sd">            simply clipped.</span>

<span class="sd">            Setting *interpolate* to *True* will calculate the actual</span>
<span class="sd">            intersection point and extend the filled region up to this point.</span>

<span class="sd">        step : {{&#39;pre&#39;, &#39;post&#39;, &#39;mid&#39;}}, optional</span>
<span class="sd">            Define *step* if the filling should be a step function,</span>
<span class="sd">            i.e. constant in between *{ind}*.  The value determines where the</span>
<span class="sd">            step will occur:</span>

<span class="sd">            - &#39;pre&#39;: The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;post&#39;: The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;mid&#39;: Steps occur half-way between the *x* positions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.PolyCollection`</span>
<span class="sd">            A `.PolyCollection` containing the plotted polygons.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are passed on to `.PolyCollection`.</span>
<span class="sd">            They control the `.Polygon` properties:</span>

<span class="sd">            %(PolyCollection:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fill_between : Fill between two sets of y-values.</span>
<span class="sd">        fill_betweenx : Fill between two sets of x-values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dep_dir</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">}[</span><span class="n">ind_dir</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;_internal.classic_mode&quot;</span><span class="p">]:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">Collection</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;facecolor&quot;</span><span class="p">)):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;facecolor&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>

        <span class="c1"># Handle united data, such as dates</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">dep1</span><span class="p">,</span> <span class="n">dep2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">ind_dir</span><span class="p">,</span> <span class="n">ind</span><span class="p">),</span> <span class="p">(</span><span class="n">dep_dir</span><span class="p">,</span> <span class="n">dep1</span><span class="p">),</span> <span class="p">(</span><span class="n">dep_dir</span><span class="p">,</span> <span class="n">dep2</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">ind_dir</span><span class="p">,</span> <span class="n">ind</span><span class="p">),</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dep_dir</span><span class="si">}</span><span class="s2">1&quot;</span><span class="p">,</span> <span class="n">dep1</span><span class="p">),</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dep_dir</span><span class="si">}</span><span class="s2">2&quot;</span><span class="p">,</span> <span class="n">dep2</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is not 1-dimensional&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">where</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;where size (</span><span class="si">{</span><span class="n">where</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">) does not match &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ind_dir</span><span class="si">}</span><span class="s2"> size (</span><span class="si">{</span><span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">where</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">,</span> <span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">dep1</span><span class="p">,</span> <span class="n">dep2</span><span class="p">]))</span>

        <span class="n">ind</span><span class="p">,</span> <span class="n">dep1</span><span class="p">,</span> <span class="n">dep2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">dep1</span><span class="p">,</span> <span class="n">dep2</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">indslice</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">dep1slice</span> <span class="o">=</span> <span class="n">dep1</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">dep2slice</span> <span class="o">=</span> <span class="n">dep2</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">step_func</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">STEP_LOOKUP_MAP</span><span class="p">[</span><span class="s2">&quot;steps-&quot;</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span>
                <span class="n">indslice</span><span class="p">,</span> <span class="n">dep1slice</span><span class="p">,</span> <span class="n">dep2slice</span> <span class="o">=</span> \
                    <span class="n">step_func</span><span class="p">(</span><span class="n">indslice</span><span class="p">,</span> <span class="n">dep1slice</span><span class="p">,</span> <span class="n">dep2slice</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">indslice</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indslice</span><span class="p">)</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">get_interp_point</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                    <span class="n">im1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">ind_values</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">diff_values</span> <span class="o">=</span> <span class="n">dep1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dep2</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dep1_values</span> <span class="o">=</span> <span class="n">dep1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">ind</span><span class="p">[</span><span class="n">im1</span><span class="p">],</span> <span class="n">dep1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dep1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                    <span class="n">diff_order</span> <span class="o">=</span> <span class="n">diff_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">diff_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">],</span> <span class="n">ind_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">])</span>
                    <span class="n">ind_order</span> <span class="o">=</span> <span class="n">ind_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_dep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="n">diff_root_ind</span><span class="p">,</span>
                        <span class="n">ind_values</span><span class="p">[</span><span class="n">ind_order</span><span class="p">],</span> <span class="n">dep1_values</span><span class="p">[</span><span class="n">ind_order</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">diff_root_ind</span><span class="p">,</span> <span class="n">diff_root_dep</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">idx0</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Handle scalar dep2 (e.g. 0): the fill should go all</span>
                <span class="c1"># the way down to 0 even if none of the dep1 sample points do.</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">indslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dep2slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">indslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dep2slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">pts</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>

            <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">indslice</span>
            <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dep1slice</span>
            <span class="n">pts</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">indslice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">pts</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dep2slice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ind_dir</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now update the datalim and autoscale</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">ind</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">dep1</span><span class="p">[</span><span class="n">where</span><span class="p">]]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">ind</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">dep2</span><span class="p">[</span><span class="n">where</span><span class="p">]])])</span>
        <span class="k">if</span> <span class="n">ind_dir</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span>

<div class="viewcode-block" id="Axes.fill_between"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.fill_between">[docs]</a>    <span class="k">def</span> <span class="nf">fill_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_between_x_or_y</span><span class="p">(</span>
            <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">if</span> <span class="n">_fill_between_x_or_y</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">:</span>
        <span class="n">fill_between</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_fill_between_x_or_y</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;horizontal&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">dep</span><span class="o">=</span><span class="s2">&quot;y&quot;</span>
        <span class="p">)</span>
    <span class="n">fill_between</span> <span class="o">=</span> <span class="n">_preprocess_data</span><span class="p">(</span>
        <span class="n">_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span><span class="p">(</span><span class="n">fill_between</span><span class="p">),</span>
        <span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y1&quot;</span><span class="p">,</span> <span class="s2">&quot;y2&quot;</span><span class="p">,</span> <span class="s2">&quot;where&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="Axes.fill_betweenx"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.fill_betweenx">[docs]</a>    <span class="k">def</span> <span class="nf">fill_betweenx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_between_x_or_y</span><span class="p">(</span>
            <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">if</span> <span class="n">_fill_between_x_or_y</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">:</span>
        <span class="n">fill_betweenx</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_fill_between_x_or_y</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">dep</span><span class="o">=</span><span class="s2">&quot;x&quot;</span>
        <span class="p">)</span>
    <span class="n">fill_betweenx</span> <span class="o">=</span> <span class="n">_preprocess_data</span><span class="p">(</span>
        <span class="n">_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span><span class="p">(</span><span class="n">fill_betweenx</span><span class="p">),</span>
        <span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">,</span> <span class="s2">&quot;where&quot;</span><span class="p">])</span>

    <span class="c1">#### plotting z(x, y): imshow, pcolor and relatives, contour</span>

    <span class="c1"># Once this deprecation elapses, also move vmin, vmax right after norm, to</span>
    <span class="c1"># match the signature of other methods returning ScalarMappables and keep</span>
    <span class="c1"># the documentation for *norm*, *vmax* and *vmin* together.</span>
<div class="viewcode-block" id="Axes.imshow"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.imshow">[docs]</a>    <span class="nd">@_api</span><span class="o">.</span><span class="n">make_keyword_only</span><span class="p">(</span><span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="s2">&quot;aspect&quot;</span><span class="p">)</span>
    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">interpd</span>
    <span class="k">def</span> <span class="nf">imshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
               <span class="n">interpolation_stage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filternorm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filterrad</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
               <span class="n">resample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display data as an image, i.e., on a 2D regular raster.</span>

<span class="sd">        The input may either be actual RGB(A) data, or 2D scalar data, which</span>
<span class="sd">        will be rendered as a pseudocolor image. For displaying a grayscale</span>
<span class="sd">        image set up the colormapping using the parameters</span>
<span class="sd">        ``cmap=&#39;gray&#39;, vmin=0, vmax=255``.</span>

<span class="sd">        The number of pixels used to render an image is set by the Axes size</span>
<span class="sd">        and the *dpi* of the figure. This can lead to aliasing artifacts when</span>
<span class="sd">        the image is resampled because the displayed image size will usually</span>
<span class="sd">        not match the size of *X* (see</span>
<span class="sd">        :doc:`/gallery/images_contours_and_fields/image_antialiasing`).</span>
<span class="sd">        The resampling can be controlled via the *interpolation* parameter</span>
<span class="sd">        and/or :rc:`image.interpolation`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like or PIL image</span>
<span class="sd">            The image data. Supported array shapes are:</span>

<span class="sd">            - (M, N): an image with scalar data. The values are mapped to</span>
<span class="sd">              colors using normalization and a colormap. See parameters *norm*,</span>
<span class="sd">              *cmap*, *vmin*, *vmax*.</span>
<span class="sd">            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).</span>
<span class="sd">            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),</span>
<span class="sd">              i.e. including transparency.</span>

<span class="sd">            The first two dimensions (M, N) define the rows and columns of</span>
<span class="sd">            the image.</span>

<span class="sd">            Out-of-range RGB(A) values are clipped.</span>

<span class="sd">        %(cmap_doc)s</span>

<span class="sd">            This parameter is ignored if *X* is RGB(A).</span>

<span class="sd">        %(norm_doc)s</span>

<span class="sd">            This parameter is ignored if *X* is RGB(A).</span>

<span class="sd">        %(vmin_vmax_doc)s</span>

<span class="sd">            This parameter is ignored if *X* is RGB(A).</span>

<span class="sd">        aspect : {&#39;equal&#39;, &#39;auto&#39;} or float, default: :rc:`image.aspect`</span>
<span class="sd">            The aspect ratio of the Axes.  This parameter is particularly</span>
<span class="sd">            relevant for images since it determines whether data pixels are</span>
<span class="sd">            square.</span>

<span class="sd">            This parameter is a shortcut for explicitly calling</span>
<span class="sd">            `.Axes.set_aspect`. See there for further details.</span>

<span class="sd">            - &#39;equal&#39;: Ensures an aspect ratio of 1. Pixels will be square</span>
<span class="sd">              (unless pixel sizes are explicitly made non-square in data</span>
<span class="sd">              coordinates using *extent*).</span>
<span class="sd">            - &#39;auto&#39;: The Axes is kept fixed and the aspect is adjusted so</span>
<span class="sd">              that the data fit in the Axes. In general, this will result in</span>
<span class="sd">              non-square pixels.</span>

<span class="sd">        interpolation : str, default: :rc:`image.interpolation`</span>
<span class="sd">            The interpolation method used.</span>

<span class="sd">            Supported values are &#39;none&#39;, &#39;antialiased&#39;, &#39;nearest&#39;, &#39;bilinear&#39;,</span>
<span class="sd">            &#39;bicubic&#39;, &#39;spline16&#39;, &#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;,</span>
<span class="sd">            &#39;kaiser&#39;, &#39;quadric&#39;, &#39;catrom&#39;, &#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;,</span>
<span class="sd">            &#39;sinc&#39;, &#39;lanczos&#39;, &#39;blackman&#39;.</span>

<span class="sd">            If *interpolation* is &#39;none&#39;, then no interpolation is performed</span>
<span class="sd">            on the Agg, ps, pdf and svg backends. Other backends will fall back</span>
<span class="sd">            to &#39;nearest&#39;. Note that most SVG renderers perform interpolation at</span>
<span class="sd">            rendering and that the default interpolation method they implement</span>
<span class="sd">            may differ.</span>

<span class="sd">            If *interpolation* is the default &#39;antialiased&#39;, then &#39;nearest&#39;</span>
<span class="sd">            interpolation is used if the image is upsampled by more than a</span>
<span class="sd">            factor of three (i.e. the number of display pixels is at least</span>
<span class="sd">            three times the size of the data array).  If the upsampling rate is</span>
<span class="sd">            smaller than 3, or the image is downsampled, then &#39;hanning&#39;</span>
<span class="sd">            interpolation is used to act as an anti-aliasing filter, unless the</span>
<span class="sd">            image happens to be upsampled by exactly a factor of two or one.</span>

<span class="sd">            See</span>
<span class="sd">            :doc:`/gallery/images_contours_and_fields/interpolation_methods`</span>
<span class="sd">            for an overview of the supported interpolation methods, and</span>
<span class="sd">            :doc:`/gallery/images_contours_and_fields/image_antialiasing` for</span>
<span class="sd">            a discussion of image antialiasing.</span>

<span class="sd">            Some interpolation methods require an additional radius parameter,</span>
<span class="sd">            which can be set by *filterrad*. Additionally, the antigrain image</span>
<span class="sd">            resize filter is controlled by the parameter *filternorm*.</span>

<span class="sd">        interpolation_stage : {&#39;data&#39;, &#39;rgba&#39;}, default: &#39;data&#39;</span>
<span class="sd">            If &#39;data&#39;, interpolation</span>
<span class="sd">            is carried out on the data provided by the user.  If &#39;rgba&#39;, the</span>
<span class="sd">            interpolation is carried out after the colormapping has been</span>
<span class="sd">            applied (visual interpolation).</span>

<span class="sd">        alpha : float or array-like, optional</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>
<span class="sd">            If *alpha* is an array, the alpha blending values are applied pixel</span>
<span class="sd">            by pixel, and *alpha* must have the same shape as *X*.</span>

<span class="sd">        origin : {&#39;upper&#39;, &#39;lower&#39;}, default: :rc:`image.origin`</span>
<span class="sd">            Place the [0, 0] index of the array in the upper left or lower</span>
<span class="sd">            left corner of the Axes. The convention (the default) &#39;upper&#39; is</span>
<span class="sd">            typically used for matrices and images.</span>

<span class="sd">            Note that the vertical axis points upward for &#39;lower&#39;</span>
<span class="sd">            but downward for &#39;upper&#39;.</span>

<span class="sd">            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for</span>
<span class="sd">            examples and a more detailed description.</span>

<span class="sd">        extent : floats (left, right, bottom, top), optional</span>
<span class="sd">            The bounding box in data coordinates that the image will fill.</span>
<span class="sd">            The image is stretched individually along x and y to fill the box.</span>

<span class="sd">            The default extent is determined by the following conditions.</span>
<span class="sd">            Pixels have unit size in data coordinates. Their centers are on</span>
<span class="sd">            integer coordinates, and their center coordinates range from 0 to</span>
<span class="sd">            columns-1 horizontally and from 0 to rows-1 vertically.</span>

<span class="sd">            Note that the direction of the vertical axis and thus the default</span>
<span class="sd">            values for top and bottom depend on *origin*:</span>

<span class="sd">            - For ``origin == &#39;upper&#39;`` the default is</span>
<span class="sd">              ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.</span>
<span class="sd">            - For ``origin == &#39;lower&#39;`` the default is</span>
<span class="sd">              ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.</span>

<span class="sd">            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for</span>
<span class="sd">            examples and a more detailed description.</span>

<span class="sd">        filternorm : bool, default: True</span>
<span class="sd">            A parameter for the antigrain image resize filter (see the</span>
<span class="sd">            antigrain documentation).  If *filternorm* is set, the filter</span>
<span class="sd">            normalizes integer values and corrects the rounding errors. It</span>
<span class="sd">            doesn&#39;t do anything with the source floating point values, it</span>
<span class="sd">            corrects only integers according to the rule of 1.0 which means</span>
<span class="sd">            that any sum of pixel weights must be equal to 1.0.  So, the</span>
<span class="sd">            filter function must produce a graph of the proper shape.</span>

<span class="sd">        filterrad : float &gt; 0, default: 4.0</span>
<span class="sd">            The filter radius for filters that have a radius parameter, i.e.</span>
<span class="sd">            when interpolation is one of: &#39;sinc&#39;, &#39;lanczos&#39; or &#39;blackman&#39;.</span>

<span class="sd">        resample : bool, default: :rc:`image.resample`</span>
<span class="sd">            When *True*, use a full resampling method.  When *False*, only</span>
<span class="sd">            resample when the output image is larger than the input image.</span>

<span class="sd">        url : str, optional</span>
<span class="sd">            Set the url of the created `.AxesImage`. See `.Artist.set_url`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs : `~matplotlib.artist.Artist` properties</span>
<span class="sd">            These parameters are passed on to the constructor of the</span>
<span class="sd">            `.AxesImage` artist.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        matshow : Plot a matrix or an array as an image.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unless *extent* is used, pixel centers will be located at integer</span>
<span class="sd">        coordinates. In other words: the origin will coincide with the center</span>
<span class="sd">        of pixel (0, 0).</span>

<span class="sd">        There are two common representations for RGB images with an alpha</span>
<span class="sd">        channel:</span>

<span class="sd">        -   Straight (unassociated) alpha: R, G, and B channels represent the</span>
<span class="sd">            color of the pixel, disregarding its opacity.</span>
<span class="sd">        -   Premultiplied (associated) alpha: R, G, and B channels represent</span>
<span class="sd">            the color of the pixel, adjusted for its opacity by multiplication.</span>

<span class="sd">        `~matplotlib.pyplot.imshow` expects RGB images adopting the straight</span>
<span class="sd">        (unassociated) alpha representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">aspect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aspect</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.aspect&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                              <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                              <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">filternorm</span><span class="o">=</span><span class="n">filternorm</span><span class="p">,</span>
                              <span class="n">filterrad</span><span class="o">=</span><span class="n">filterrad</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
                              <span class="n">interpolation_stage</span><span class="o">=</span><span class="n">interpolation_stage</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># image does not already have clipping set, clip to axes patch</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">_scale_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

        <span class="c1"># update ax.dataLim, and, if autoscaling, set viewLim</span>
        <span class="c1"># to tightly fit the image, regardless of dataLim.</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_extent</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_extent</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span></div>

    <span class="k">def</span> <span class="nf">_pcolorargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># - create X and Y if not present;</span>
        <span class="c1"># - reshape X and Y as needed if they are 1-D;</span>
        <span class="c1"># - check for proper sizes based on `shading` kwarg;</span>
        <span class="c1"># - reset shading if shading=&#39;auto&#39; to flat or nearest</span>
        <span class="c1">#   depending on size;</span>

        <span class="n">_valid_shading</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gouraud&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">(</span><span class="n">_valid_shading</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="n">shading</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shading value &#39;</span><span class="si">{</span><span class="n">shading</span><span class="si">}</span><span class="s2">&#39; not in list of &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;valid values </span><span class="si">{</span><span class="n">_valid_shading</span><span class="si">}</span><span class="s2">. Setting &quot;</span>
                               <span class="s2">&quot;shading=&#39;auto&#39;.&quot;</span><span class="p">)</span>
            <span class="n">shading</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">shading</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gouraud&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">]:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrows</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">shading</span> <span class="o">=</span> <span class="s1">&#39;flat&#39;</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">shading</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Check x and y for bad data...</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="c1"># unit conversion allows e.g. datetime objects as axis values</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">Y</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">funcname</span> <span class="o">==</span> <span class="s1">&#39;pcolormesh&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;x and y arguments to pcolormesh cannot have &#39;</span>
                        <span class="s1">&#39;non-finite values or be of type &#39;</span>
                        <span class="s1">&#39;numpy.ma.core.MaskedArray with masked values&#39;</span><span class="p">)</span>
                <span class="c1"># safe_masked_invalid() returns an ndarray for dtypes other</span>
                <span class="c1"># than floating point.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># strip mask as downstream doesn&#39;t like it...</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">data</span>
            <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">funcname</span><span class="si">}</span><span class="s1">() takes 1 or 3 positional arguments &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s1"> were given&#39;</span><span class="p">)</span>

        <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Incompatible X, Y inputs to </span><span class="si">{</span><span class="n">funcname</span><span class="si">}</span><span class="s1">; &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;see help(</span><span class="si">{</span><span class="n">funcname</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shading</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ncols</span> <span class="o">==</span> <span class="n">Nx</span> <span class="ow">and</span> <span class="n">nrows</span> <span class="o">==</span> <span class="n">Ny</span><span class="p">:</span>
                <span class="n">shading</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shading</span> <span class="o">=</span> <span class="s1">&#39;flat&#39;</span>

        <span class="k">if</span> <span class="n">shading</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with&#39;</span>
                                <span class="s1">&#39; X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>    <span class="c1"># [&#39;nearest&#39;, &#39;gouraud&#39;]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ncols</span><span class="p">,</span> <span class="n">nrows</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with&#39;</span>
                                <span class="s1">&#39; X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">shading</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
                <span class="c1"># grid is specified at the center, so define corners</span>
                <span class="c1"># at the midpoints between the grid centers and then use the</span>
                <span class="c1"># flat algorithm.</span>
                <span class="k">def</span> <span class="nf">_interp_grid</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                    <span class="c1"># helper for below</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dX</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dX</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
                            <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;The input coordinates to </span><span class="si">{</span><span class="n">funcname</span><span class="si">}</span><span class="s2"> are &quot;</span>
                                <span class="s2">&quot;interpreted as cell centers, but are not &quot;</span>
                                <span class="s2">&quot;monotonically increasing or decreasing. &quot;</span>
                                <span class="s2">&quot;This may lead to incorrectly calculated cell &quot;</span>
                                <span class="s2">&quot;edges, in which case, please supply &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;explicit cell edges to </span><span class="si">{</span><span class="n">funcname</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">dX</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                       <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dX</span><span class="p">,</span>
                                       <span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">dX</span><span class="p">[:,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># This is just degenerate, but we can&#39;t reliably guess</span>
                        <span class="c1"># a dX if there is just one value.</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">X</span>

                <span class="k">if</span> <span class="n">ncols</span> <span class="o">==</span> <span class="n">Nx</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">_interp_grid</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">_interp_grid</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nrows</span> <span class="o">==</span> <span class="n">Ny</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">_interp_grid</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">_interp_grid</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">shading</span> <span class="o">=</span> <span class="s1">&#39;flat&#39;</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">shading</span>

    <span class="k">def</span> <span class="nf">_pcolor_grid_deprecation_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">grid_active</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">_major_tick_kw</span><span class="p">[</span><span class="s2">&quot;gridOn&quot;</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># explicit is-True check because get_axisbelow() can also be &#39;line&#39;</span>
        <span class="n">grid_hidden_by_pcolor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_axisbelow</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">grid_active</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">grid_hidden_by_pcolor</span><span class="p">:</span>
            <span class="n">_api</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
                <span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Auto-removal of grids by pcolor() and &quot;</span>
                <span class="s2">&quot;pcolormesh() is deprecated since </span><span class="si">%(since)s</span><span class="s2"> and will be &quot;</span>
                <span class="s2">&quot;removed </span><span class="si">%(removal)s</span><span class="s2">; please call grid(False) first.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="Axes.pcolor"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.pcolor">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pseudocolor plot with a non-regular rectangular grid.</span>

<span class="sd">        Call signature::</span>

<span class="sd">            pcolor([X, Y,] C, **kwargs)</span>

<span class="sd">        *X* and *Y* can be used to specify the corners of the quadrilaterals.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            ``pcolor()`` can be very slow for large arrays. In most</span>
<span class="sd">            cases you should use the similar but much faster</span>
<span class="sd">            `~.Axes.pcolormesh` instead. See</span>
<span class="sd">            :ref:`Differences between pcolor() and pcolormesh()</span>
<span class="sd">            &lt;differences-pcolor-pcolormesh&gt;` for a discussion of the</span>
<span class="sd">            differences.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C : 2D array-like</span>
<span class="sd">            The color-mapped values.  Color-mapping is controlled by *cmap*,</span>
<span class="sd">            *norm*, *vmin*, and *vmax*.</span>

<span class="sd">        X, Y : array-like, optional</span>
<span class="sd">            The coordinates of the corners of quadrilaterals of a pcolormesh::</span>

<span class="sd">                (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])</span>
<span class="sd">                                      +-----+</span>
<span class="sd">                                      |     |</span>
<span class="sd">                                      +-----+</span>
<span class="sd">                    (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])</span>

<span class="sd">            Note that the column index corresponds to the x-coordinate, and</span>
<span class="sd">            the row index corresponds to y. For details, see the</span>
<span class="sd">            :ref:`Notes &lt;axes-pcolormesh-grid-orientation&gt;` section below.</span>

<span class="sd">            If ``shading=&#39;flat&#39;`` the dimensions of *X* and *Y* should be one</span>
<span class="sd">            greater than those of *C*, and the quadrilateral is colored due</span>
<span class="sd">            to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal</span>
<span class="sd">            dimensions, a warning will be raised and the last row and column</span>
<span class="sd">            of *C* will be ignored.</span>

<span class="sd">            If ``shading=&#39;nearest&#39;``, the dimensions of *X* and *Y* should be</span>
<span class="sd">            the same as those of *C* (if not, a ValueError will be raised). The</span>
<span class="sd">            color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.</span>

<span class="sd">            If *X* and/or *Y* are 1-D arrays or column vectors they will be</span>
<span class="sd">            expanded as needed into the appropriate 2D arrays, making a</span>
<span class="sd">            rectangular grid.</span>

<span class="sd">        shading : {&#39;flat&#39;, &#39;nearest&#39;, &#39;auto&#39;}, default: :rc:`pcolor.shading`</span>
<span class="sd">            The fill style for the quadrilateral. Possible values:</span>

<span class="sd">            - &#39;flat&#39;: A solid color is used for each quad. The color of the</span>
<span class="sd">              quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by</span>
<span class="sd">              ``C[i, j]``. The dimensions of *X* and *Y* should be</span>
<span class="sd">              one greater than those of *C*; if they are the same as *C*,</span>
<span class="sd">              then a deprecation warning is raised, and the last row</span>
<span class="sd">              and column of *C* are dropped.</span>
<span class="sd">            - &#39;nearest&#39;: Each grid point will have a color centered on it,</span>
<span class="sd">              extending halfway between the adjacent grid centers.  The</span>
<span class="sd">              dimensions of *X* and *Y* must be the same as *C*.</span>
<span class="sd">            - &#39;auto&#39;: Choose &#39;flat&#39; if dimensions of *X* and *Y* are one</span>
<span class="sd">              larger than *C*.  Choose &#39;nearest&#39; if dimensions are the same.</span>

<span class="sd">            See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`</span>
<span class="sd">            for more description.</span>

<span class="sd">        %(cmap_doc)s</span>

<span class="sd">        %(norm_doc)s</span>

<span class="sd">        %(vmin_vmax_doc)s</span>

<span class="sd">        edgecolors : {&#39;none&#39;, None, &#39;face&#39;, color, color sequence}, optional</span>
<span class="sd">            The color of the edges. Defaults to &#39;none&#39;. Possible values:</span>

<span class="sd">            - &#39;none&#39; or &#39;&#39;: No edge.</span>
<span class="sd">            - *None*: :rc:`patch.edgecolor` will be used. Note that currently</span>
<span class="sd">              :rc:`patch.force_edgecolor` has to be True for this to work.</span>
<span class="sd">            - &#39;face&#39;: Use the adjacent face color.</span>
<span class="sd">            - A color or sequence of colors will set the edge color.</span>

<span class="sd">            The singular form *edgecolor* works as an alias.</span>

<span class="sd">        alpha : float, default: None</span>
<span class="sd">            The alpha blending value of the face color, between 0 (transparent)</span>
<span class="sd">            and 1 (opaque). Note: The edgecolor is currently not affected by</span>
<span class="sd">            this.</span>

<span class="sd">        snap : bool, default: False</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `matplotlib.collections.Collection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        antialiaseds : bool, default: False</span>
<span class="sd">            The default *antialiaseds* is False if the default</span>
<span class="sd">            *edgecolors*\ =&quot;none&quot; is used.  This eliminates artificial lines</span>
<span class="sd">            at patch boundaries, and works regardless of the value of alpha.</span>
<span class="sd">            If *edgecolors* is not &quot;none&quot;, then the default *antialiaseds*</span>
<span class="sd">            is taken from :rc:`patch.antialiased`.</span>
<span class="sd">            Stroking the edges may be preferred if *alpha* is 1, but will</span>
<span class="sd">            cause artifacts otherwise.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additionally, the following arguments are allowed. They are passed</span>
<span class="sd">            along to the `~matplotlib.collections.PolyCollection` constructor:</span>

<span class="sd">        %(PolyCollection:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pcolormesh : for an explanation of the differences between</span>
<span class="sd">            pcolor and pcolormesh.</span>
<span class="sd">        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a</span>
<span class="sd">            faster alternative.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Masked arrays**</span>

<span class="sd">        *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one</span>
<span class="sd">        of the vertices surrounding ``C[i, j]`` (*X* or *Y* at</span>
<span class="sd">        ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is</span>
<span class="sd">        plotted.</span>

<span class="sd">        .. _axes-pcolor-grid-orientation:</span>

<span class="sd">        **Grid orientation**</span>

<span class="sd">        The grid orientation follows the standard matrix convention: An array</span>
<span class="sd">        *C* with shape (nrows, ncolumns) is plotted with the column number as</span>
<span class="sd">        *X* and the row number as *Y*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">shading</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shading</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;pcolor.shading&#39;</span><span class="p">]</span>
        <span class="n">shading</span> <span class="o">=</span> <span class="n">shading</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">shading</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">&#39;pcolor&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="n">shading</span><span class="p">,</span>
                                            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># convert to MA, if necessary.</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">xymask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span>
                  <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># don&#39;t plot if C or any of the surrounding vertices are masked.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="n">xymask</span>

        <span class="n">unmask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span>
        <span class="n">X1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">X2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">X3</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y3</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">X4</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y4</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">npoly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">Y2</span><span class="p">,</span> <span class="n">X3</span><span class="p">,</span> <span class="n">Y3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="n">Y4</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">npoly</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>

        <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,)</span>
        <span class="k">if</span> <span class="s1">&#39;linewidth&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linewidths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linewidths&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;edgecolor&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">)</span>
        <span class="n">ec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="c1"># aa setting will default via collections to patch.antialiased</span>
        <span class="c1"># unless the boundary is not stroked, in which case the</span>
        <span class="c1"># default will be False; with unstroked boundaries, aa</span>
        <span class="c1"># makes artifacts that are often disturbing.</span>
        <span class="k">if</span> <span class="s1">&#39;antialiased&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;antialiaseds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;antialiased&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;antialiaseds&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_str_lower_equal</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;antialiaseds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snap&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
            <span class="n">verts</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">_scale_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pcolor_grid_deprecation_helper</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.pcolormesh"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.pcolormesh">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolormesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pseudocolor plot with a non-regular rectangular grid.</span>

<span class="sd">        Call signature::</span>

<span class="sd">            pcolormesh([X, Y,] C, **kwargs)</span>

<span class="sd">        *X* and *Y* can be used to specify the corners of the quadrilaterals.</span>

<span class="sd">        .. hint::</span>

<span class="sd">           `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster</span>
<span class="sd">           and preferred in most cases. For a detailed discussion on the</span>
<span class="sd">           differences see :ref:`Differences between pcolor() and pcolormesh()</span>
<span class="sd">           &lt;differences-pcolor-pcolormesh&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C : 2D array-like</span>
<span class="sd">            The color-mapped values.  Color-mapping is controlled by *cmap*,</span>
<span class="sd">            *norm*, *vmin*, and *vmax*.</span>

<span class="sd">        X, Y : array-like, optional</span>
<span class="sd">            The coordinates of the corners of quadrilaterals of a pcolormesh::</span>

<span class="sd">                (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])</span>
<span class="sd">                                      +-----+</span>
<span class="sd">                                      |     |</span>
<span class="sd">                                      +-----+</span>
<span class="sd">                    (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])</span>

<span class="sd">            Note that the column index corresponds to the x-coordinate, and</span>
<span class="sd">            the row index corresponds to y. For details, see the</span>
<span class="sd">            :ref:`Notes &lt;axes-pcolormesh-grid-orientation&gt;` section below.</span>

<span class="sd">            If ``shading=&#39;flat&#39;`` the dimensions of *X* and *Y* should be one</span>
<span class="sd">            greater than those of *C*, and the quadrilateral is colored due</span>
<span class="sd">            to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal</span>
<span class="sd">            dimensions, a warning will be raised and the last row and column</span>
<span class="sd">            of *C* will be ignored.</span>

<span class="sd">            If ``shading=&#39;nearest&#39;`` or ``&#39;gouraud&#39;``, the dimensions of *X*</span>
<span class="sd">            and *Y* should be the same as those of *C* (if not, a ValueError</span>
<span class="sd">            will be raised).  For ``&#39;nearest&#39;`` the color ``C[i, j]`` is</span>
<span class="sd">            centered on ``(X[i, j], Y[i, j])``.  For ``&#39;gouraud&#39;``, a smooth</span>
<span class="sd">            interpolation is caried out between the quadrilateral corners.</span>

<span class="sd">            If *X* and/or *Y* are 1-D arrays or column vectors they will be</span>
<span class="sd">            expanded as needed into the appropriate 2D arrays, making a</span>
<span class="sd">            rectangular grid.</span>

<span class="sd">        %(cmap_doc)s</span>

<span class="sd">        %(norm_doc)s</span>

<span class="sd">        %(vmin_vmax_doc)s</span>

<span class="sd">        edgecolors : {&#39;none&#39;, None, &#39;face&#39;, color, color sequence}, optional</span>
<span class="sd">            The color of the edges. Defaults to &#39;none&#39;. Possible values:</span>

<span class="sd">            - &#39;none&#39; or &#39;&#39;: No edge.</span>
<span class="sd">            - *None*: :rc:`patch.edgecolor` will be used. Note that currently</span>
<span class="sd">              :rc:`patch.force_edgecolor` has to be True for this to work.</span>
<span class="sd">            - &#39;face&#39;: Use the adjacent face color.</span>
<span class="sd">            - A color or sequence of colors will set the edge color.</span>

<span class="sd">            The singular form *edgecolor* works as an alias.</span>

<span class="sd">        alpha : float, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        shading : {&#39;flat&#39;, &#39;nearest&#39;, &#39;gouraud&#39;, &#39;auto&#39;}, optional</span>
<span class="sd">            The fill style for the quadrilateral; defaults to</span>
<span class="sd">            &#39;flat&#39; or :rc:`pcolor.shading`. Possible values:</span>

<span class="sd">            - &#39;flat&#39;: A solid color is used for each quad. The color of the</span>
<span class="sd">              quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by</span>
<span class="sd">              ``C[i, j]``. The dimensions of *X* and *Y* should be</span>
<span class="sd">              one greater than those of *C*; if they are the same as *C*,</span>
<span class="sd">              then a deprecation warning is raised, and the last row</span>
<span class="sd">              and column of *C* are dropped.</span>
<span class="sd">            - &#39;nearest&#39;: Each grid point will have a color centered on it,</span>
<span class="sd">              extending halfway between the adjacent grid centers.  The</span>
<span class="sd">              dimensions of *X* and *Y* must be the same as *C*.</span>
<span class="sd">            - &#39;gouraud&#39;: Each quad will be Gouraud shaded: The color of the</span>
<span class="sd">              corners (i&#39;, j&#39;) are given by ``C[i&#39;, j&#39;]``. The color values of</span>
<span class="sd">              the area in between is interpolated from the corner values.</span>
<span class="sd">              The dimensions of *X* and *Y* must be the same as *C*. When</span>
<span class="sd">              Gouraud shading is used, *edgecolors* is ignored.</span>
<span class="sd">            - &#39;auto&#39;: Choose &#39;flat&#39; if dimensions of *X* and *Y* are one</span>
<span class="sd">              larger than *C*.  Choose &#39;nearest&#39; if dimensions are the same.</span>

<span class="sd">            See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`</span>
<span class="sd">            for more description.</span>

<span class="sd">        snap : bool, default: False</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        rasterized : bool, optional</span>
<span class="sd">            Rasterize the pcolormesh when drawing vector graphics.  This can</span>
<span class="sd">            speed up rendering and produce smaller files for large data sets.</span>
<span class="sd">            See also :doc:`/gallery/misc/rasterization_demo`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `matplotlib.collections.QuadMesh`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additionally, the following arguments are allowed. They are passed</span>
<span class="sd">            along to the `~matplotlib.collections.QuadMesh` constructor:</span>

<span class="sd">        %(QuadMesh:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pcolor : An alternative implementation with slightly different</span>
<span class="sd">            features. For a detailed discussion on the differences see</span>
<span class="sd">            :ref:`Differences between pcolor() and pcolormesh()</span>
<span class="sd">            &lt;differences-pcolor-pcolormesh&gt;`.</span>
<span class="sd">        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a</span>
<span class="sd">            faster alternative.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Masked arrays**</span>

<span class="sd">        *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding</span>
<span class="sd">        quadrilateral will be transparent. Masking of *X* and *Y* is not</span>
<span class="sd">        supported. Use `~.Axes.pcolor` if you need this functionality.</span>

<span class="sd">        .. _axes-pcolormesh-grid-orientation:</span>

<span class="sd">        **Grid orientation**</span>

<span class="sd">        The grid orientation follows the standard matrix convention: An array</span>
<span class="sd">        *C* with shape (nrows, ncolumns) is plotted with the column number as</span>
<span class="sd">        *X* and the row number as *Y*.</span>

<span class="sd">        .. _differences-pcolor-pcolormesh:</span>

<span class="sd">        **Differences between pcolor() and pcolormesh()**</span>

<span class="sd">        Both methods are used to create a pseudocolor plot of a 2D array</span>
<span class="sd">        using quadrilaterals.</span>

<span class="sd">        The main difference lies in the created object and internal data</span>
<span class="sd">        handling:</span>
<span class="sd">        While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`</span>
<span class="sd">        returns a `.QuadMesh`. The latter is more specialized for the given</span>
<span class="sd">        purpose and thus is faster. It should almost always be preferred.</span>

<span class="sd">        There is also a slight difference in the handling of masked arrays.</span>
<span class="sd">        Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays</span>
<span class="sd">        for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*</span>
<span class="sd">        and *Y*. The reason lies in the internal handling of the masked values.</span>
<span class="sd">        `~.Axes.pcolor` leaves out the respective polygons from the</span>
<span class="sd">        PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked</span>
<span class="sd">        elements to transparent. You can see the difference when using</span>
<span class="sd">        edgecolors. While all edges are drawn irrespective of masking in a</span>
<span class="sd">        QuadMesh, the edge between two adjacent masked quadrilaterals in</span>
<span class="sd">        `~.Axes.pcolor` is not drawn as the corresponding polygons do not</span>
<span class="sd">        exist in the PolyCollection.</span>

<span class="sd">        Another difference is the support of Gouraud shading in</span>
<span class="sd">        `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shading</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shading</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;pcolor.shading&#39;</span><span class="p">]</span>
        <span class="n">shading</span> <span class="o">=</span> <span class="n">shading</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">shading</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">&#39;pcolormesh&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                            <span class="n">shading</span><span class="o">=</span><span class="n">shading</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># convert to one dimensional array</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snap&#39;</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;pcolormesh.snap&#39;</span><span class="p">])</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span>
            <span class="n">coords</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="n">antialiased</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="n">shading</span><span class="p">,</span>
            <span class="n">array</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">_scale_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pcolor_grid_deprecation_helper</span><span class="p">()</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># flatten the grid structure; keep x, y</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="Axes.pcolorfast"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.pcolorfast">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolorfast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pseudocolor plot with a non-regular rectangular grid.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          ax.pcolorfast([X, Y], C, /, **kwargs)</span>

<span class="sd">        This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.</span>
<span class="sd">        It&#39;s designed to provide the fastest pcolor-type plotting with the</span>
<span class="sd">        Agg backend. To achieve this, it uses different algorithms internally</span>
<span class="sd">        depending on the complexity of the input grid (regular rectangular,</span>
<span class="sd">        non-regular rectangular or arbitrary quadrilateral).</span>

<span class="sd">        .. warning::</span>

<span class="sd">           This method is experimental. Compared to `~.Axes.pcolor` or</span>
<span class="sd">           `~.Axes.pcolormesh` it has some limitations:</span>

<span class="sd">           - It supports only flat shading (no outlines)</span>
<span class="sd">           - It lacks support for log scaling of the axes.</span>
<span class="sd">           - It does not have a have a pyplot wrapper.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C : array-like</span>
<span class="sd">            The image data. Supported array shapes are:</span>

<span class="sd">            - (M, N): an image with scalar data.  Color-mapping is controlled</span>
<span class="sd">              by *cmap*, *norm*, *vmin*, and *vmax*.</span>
<span class="sd">            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).</span>
<span class="sd">            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),</span>
<span class="sd">              i.e. including transparency.</span>

<span class="sd">            The first two dimensions (M, N) define the rows and columns of</span>
<span class="sd">            the image.</span>

<span class="sd">            This parameter can only be passed positionally.</span>

<span class="sd">        X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``</span>
<span class="sd">            *X* and *Y* are used to specify the coordinates of the</span>
<span class="sd">            quadrilaterals. There are different ways to do this:</span>

<span class="sd">            - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define</span>
<span class="sd">              a *uniform rectangular grid*.</span>

<span class="sd">              The tuples define the outer edges of the grid. All individual</span>
<span class="sd">              quadrilaterals will be of the same size. This is the fastest</span>
<span class="sd">              version.</span>

<span class="sd">            - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular</span>
<span class="sd">              grid*.</span>

<span class="sd">              In this case *X* and *Y* have to be monotonic 1D arrays of length</span>
<span class="sd">              *N+1* and *M+1*, specifying the x and y boundaries of the cells.</span>

<span class="sd">              The speed is intermediate. Note: The grid is checked, and if</span>
<span class="sd">              found to be uniform the fast version is used.</span>

<span class="sd">            - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral</span>
<span class="sd">              grid* (i.e. if the quadrilaterals are not rectangular).</span>

<span class="sd">              In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),</span>
<span class="sd">              specifying the x and y coordinates of the corners of the colored</span>
<span class="sd">              quadrilaterals.</span>

<span class="sd">              This is the most general, but the slowest to render.  It may</span>
<span class="sd">              produce faster and more compact output using ps, pdf, and</span>
<span class="sd">              svg backends, however.</span>

<span class="sd">            These arguments can only be passed positionally.</span>

<span class="sd">        %(cmap_doc)s</span>

<span class="sd">            This parameter is ignored if *C* is RGB(A).</span>

<span class="sd">        %(norm_doc)s</span>

<span class="sd">            This parameter is ignored if *C* is RGB(A).</span>

<span class="sd">        %(vmin_vmax_doc)s</span>

<span class="sd">            This parameter is ignored if *C* is RGB(A).</span>

<span class="sd">        alpha : float, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        snap : bool, default: False</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.AxesImage` or `.PcolorImage` or `.QuadMesh`</span>
<span class="sd">            The return type depends on the type of grid:</span>

<span class="sd">            - `.AxesImage` for a regular rectangular grid.</span>
<span class="sd">            - `.PcolorImage` for a non-regular rectangular grid.</span>
<span class="sd">            - `.QuadMesh` for a non-rectangular grid.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Supported additional parameters depend on the type of grid.</span>
<span class="sd">            See return types of *image* for further description.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">C</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="ow">and</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy</span><span class="o">.</span><span class="n">mean</span><span class="p">())):</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;pcolorimage&quot;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;quadmesh&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments do not match valid signatures&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;need 1 argument or 3 arguments&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;quadmesh&quot;</span><span class="p">:</span>
            <span class="c1"># data point in each cell is value at lower left corner</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">qm_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;array&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">C</span><span class="p">)}</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">qm_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;C must be 2D or 3D&quot;</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">qm_kwargs</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">collection</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># It&#39;s one of the two image styles.</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
                    <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;pcolorimage&quot;</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">PcolorImage</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
                    <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">im</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># C.ndim == 3 is RGB(A) so doesn&#39;t need scaling.</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_scale_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># image does not already have clipping set, clip to axes patch</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">]</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xl</span><span class="p">,</span> <span class="n">yb</span><span class="p">],</span> <span class="p">[</span><span class="n">xr</span><span class="p">,</span> <span class="n">yt</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Axes.contour"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.contour">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot contour lines.</span>

<span class="sd">        Call signature::</span>

<span class="sd">            contour([X, Y,] Z, [levels], **kwargs)</span>
<span class="sd">        %(contour_doc)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contours</span></div>

<div class="viewcode-block" id="Axes.contourf"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.contourf">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">contourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot filled contours.</span>

<span class="sd">        Call signature::</span>

<span class="sd">            contourf([X, Y,] Z, [levels], **kwargs)</span>
<span class="sd">        %(contour_doc)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contours</span></div>

<div class="viewcode-block" id="Axes.clabel"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.clabel">[docs]</a>    <span class="k">def</span> <span class="nf">clabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CS</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Label a contour plot.</span>

<span class="sd">        Adds labels to line contours in given `.ContourSet`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        CS : `.ContourSet` instance</span>
<span class="sd">            Line contours to label.</span>

<span class="sd">        levels : array-like, optional</span>
<span class="sd">            A list of level values, that should be labeled. The list must be</span>
<span class="sd">            a subset of ``CS.levels``. If not given, all levels are labeled.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            All other parameters are documented in `~.ContourLabeler.clabel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CS</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">#### Data analysis</span>

<div class="viewcode-block" id="Axes.hist"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.hist">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span>
             <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">rwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stacked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute and plot a histogram.</span>

<span class="sd">        This method uses `numpy.histogram` to bin the data in *x* and count the</span>
<span class="sd">        number of values in each bin, then draws the distribution either as a</span>
<span class="sd">        `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and</span>
<span class="sd">        *weights* parameters are forwarded to `numpy.histogram`.</span>

<span class="sd">        If the data has already been binned and counted, use `~.bar` or</span>
<span class="sd">        `~.stairs` to plot the distribution::</span>

<span class="sd">            counts, bins = np.histogram(x)</span>
<span class="sd">            plt.stairs(counts, bins)</span>

<span class="sd">        Alternatively, plot pre-computed bins and counts using ``hist()`` by</span>
<span class="sd">        treating each bin as a single point with a weight equal to its count::</span>

<span class="sd">            plt.hist(bins[:-1], bins, weights=counts)</span>

<span class="sd">        The data input *x* can be a singular array, a list of datasets of</span>
<span class="sd">        potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in</span>
<span class="sd">        which each column is a dataset. Note that the ndarray form is</span>
<span class="sd">        transposed relative to the list form. If the input is an array, then</span>
<span class="sd">        the return value is a tuple (*n*, *bins*, *patches*); if the input is a</span>
<span class="sd">        sequence of arrays, then the return value is a tuple</span>
<span class="sd">        ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).</span>

<span class="sd">        Masked arrays are not supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : (n,) array or sequence of (n,) arrays</span>
<span class="sd">            Input values, this takes either a single array or a sequence of</span>
<span class="sd">            arrays which are not required to be of the same length.</span>

<span class="sd">        bins : int or sequence or str, default: :rc:`hist.bins`</span>
<span class="sd">            If *bins* is an integer, it defines the number of equal-width bins</span>
<span class="sd">            in the range.</span>

<span class="sd">            If *bins* is a sequence, it defines the bin edges, including the</span>
<span class="sd">            left edge of the first bin and the right edge of the last bin;</span>
<span class="sd">            in this case, bins may be unequally spaced.  All but the last</span>
<span class="sd">            (righthand-most) bin is half-open.  In other words, if *bins* is::</span>

<span class="sd">                [1, 2, 3, 4]</span>

<span class="sd">            then the first bin is ``[1, 2)`` (including 1, but excluding 2) and</span>
<span class="sd">            the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which</span>
<span class="sd">            *includes* 4.</span>

<span class="sd">            If *bins* is a string, it is one of the binning strategies</span>
<span class="sd">            supported by `numpy.histogram_bin_edges`: &#39;auto&#39;, &#39;fd&#39;, &#39;doane&#39;,</span>
<span class="sd">            &#39;scott&#39;, &#39;stone&#39;, &#39;rice&#39;, &#39;sturges&#39;, or &#39;sqrt&#39;.</span>

<span class="sd">        range : tuple or None, default: None</span>
<span class="sd">            The lower and upper range of the bins. Lower and upper outliers</span>
<span class="sd">            are ignored. If not provided, *range* is ``(x.min(), x.max())``.</span>
<span class="sd">            Range has no effect if *bins* is a sequence.</span>

<span class="sd">            If *bins* is a sequence or *range* is specified, autoscaling</span>
<span class="sd">            is based on the specified bin range instead of the</span>
<span class="sd">            range of x.</span>

<span class="sd">        density : bool, default: False</span>
<span class="sd">            If ``True``, draw and return a probability density: each bin</span>
<span class="sd">            will display the bin&#39;s raw count divided by the total number of</span>
<span class="sd">            counts *and the bin width*</span>
<span class="sd">            (``density = counts / (sum(counts) * np.diff(bins))``),</span>
<span class="sd">            so that the area under the histogram integrates to 1</span>
<span class="sd">            (``np.sum(density * np.diff(bins)) == 1``).</span>

<span class="sd">            If *stacked* is also ``True``, the sum of the histograms is</span>
<span class="sd">            normalized to 1.</span>

<span class="sd">        weights : (n,) array-like or None, default: None</span>
<span class="sd">            An array of weights, of the same shape as *x*.  Each value in</span>
<span class="sd">            *x* only contributes its associated weight towards the bin count</span>
<span class="sd">            (instead of 1).  If *density* is ``True``, the weights are</span>
<span class="sd">            normalized, so that the integral of the density over the range</span>
<span class="sd">            remains 1.</span>

<span class="sd">        cumulative : bool or -1, default: False</span>
<span class="sd">            If ``True``, then a histogram is computed where each bin gives the</span>
<span class="sd">            counts in that bin plus all bins for smaller values. The last bin</span>
<span class="sd">            gives the total number of datapoints.</span>

<span class="sd">            If *density* is also ``True`` then the histogram is normalized such</span>
<span class="sd">            that the last bin equals 1.</span>

<span class="sd">            If *cumulative* is a number less than 0 (e.g., -1), the direction</span>
<span class="sd">            of accumulation is reversed.  In this case, if *density* is also</span>
<span class="sd">            ``True``, then the histogram is normalized such that the first bin</span>
<span class="sd">            equals 1.</span>

<span class="sd">        bottom : array-like, scalar, or None, default: None</span>
<span class="sd">            Location of the bottom of each bin, ie. bins are drawn from</span>
<span class="sd">            ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom</span>
<span class="sd">            of each bin is shifted by the same amount. If an array, each bin</span>
<span class="sd">            is shifted independently and the length of bottom must match the</span>
<span class="sd">            number of bins. If None, defaults to 0.</span>

<span class="sd">        histtype : {&#39;bar&#39;, &#39;barstacked&#39;, &#39;step&#39;, &#39;stepfilled&#39;}, default: &#39;bar&#39;</span>
<span class="sd">            The type of histogram to draw.</span>

<span class="sd">            - &#39;bar&#39; is a traditional bar-type histogram.  If multiple data</span>
<span class="sd">              are given the bars are arranged side by side.</span>
<span class="sd">            - &#39;barstacked&#39; is a bar-type histogram where multiple</span>
<span class="sd">              data are stacked on top of each other.</span>
<span class="sd">            - &#39;step&#39; generates a lineplot that is by default unfilled.</span>
<span class="sd">            - &#39;stepfilled&#39; generates a lineplot that is by default filled.</span>

<span class="sd">        align : {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;}, default: &#39;mid&#39;</span>
<span class="sd">            The horizontal alignment of the histogram bars.</span>

<span class="sd">            - &#39;left&#39;: bars are centered on the left bin edges.</span>
<span class="sd">            - &#39;mid&#39;: bars are centered between the bin edges.</span>
<span class="sd">            - &#39;right&#39;: bars are centered on the right bin edges.</span>

<span class="sd">        orientation : {&#39;vertical&#39;, &#39;horizontal&#39;}, default: &#39;vertical&#39;</span>
<span class="sd">            If &#39;horizontal&#39;, `~.Axes.barh` will be used for bar-type histograms</span>
<span class="sd">            and the *bottom* kwarg will be the left edges.</span>

<span class="sd">        rwidth : float or None, default: None</span>
<span class="sd">            The relative width of the bars as a fraction of the bin width.  If</span>
<span class="sd">            ``None``, automatically compute the width.</span>

<span class="sd">            Ignored if *histtype* is &#39;step&#39; or &#39;stepfilled&#39;.</span>

<span class="sd">        log : bool, default: False</span>
<span class="sd">            If ``True``, the histogram axis will be set to a log scale.</span>

<span class="sd">        color : color or array-like of colors or None, default: None</span>
<span class="sd">            Color or sequence of colors, one per dataset.  Default (``None``)</span>
<span class="sd">            uses the standard line color sequence.</span>

<span class="sd">        label : str or None, default: None</span>
<span class="sd">            String, or sequence of strings to match multiple datasets.  Bar</span>
<span class="sd">            charts yield multiple patches per dataset, but only the first gets</span>
<span class="sd">            the label, so that `~.Axes.legend` will work as expected.</span>

<span class="sd">        stacked : bool, default: False</span>
<span class="sd">            If ``True``, multiple data are stacked on top of each other If</span>
<span class="sd">            ``False`` multiple data are arranged side by side if histtype is</span>
<span class="sd">            &#39;bar&#39; or on top of each other if histtype is &#39;step&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : array or list of arrays</span>
<span class="sd">            The values of the histogram bins. See *density* and *weights* for a</span>
<span class="sd">            description of the possible semantics.  If input *x* is an array,</span>
<span class="sd">            then this is an array of length *nbins*. If input is a sequence of</span>
<span class="sd">            arrays ``[data1, data2, ...]``, then this is a list of arrays with</span>
<span class="sd">            the values of the histograms for each of the arrays in the same</span>
<span class="sd">            order.  The dtype of the array *n* (or of its element arrays) will</span>
<span class="sd">            always be float even if no weighting or normalization is used.</span>

<span class="sd">        bins : array</span>
<span class="sd">            The edges of the bins. Length nbins + 1 (nbins left edges and right</span>
<span class="sd">            edge of last bin).  Always a single array even when multiple data</span>
<span class="sd">            sets are passed in.</span>

<span class="sd">        patches : `.BarContainer` or list of a single `.Polygon` or list of \</span>
<span class="sd">such objects</span>
<span class="sd">            Container of individual artists used to create the histogram</span>
<span class="sd">            or list of such containers if there are multiple input datasets.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            `~matplotlib.patches.Patch` properties</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hist2d : 2D histogram with rectangular bins</span>
<span class="sd">        hexbin : 2D histogram with hexagonal bins</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For large numbers of bins (&gt;1000), plotting can be significantly faster</span>
<span class="sd">        if *histtype* is set to &#39;step&#39; or &#39;stepfilled&#39; rather than &#39;bar&#39; or</span>
<span class="sd">        &#39;barstacked&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid shadowing the builtin.</span>
        <span class="n">bin_range</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">range</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;hist.bins&#39;</span><span class="p">]</span>

        <span class="c1"># Validate string inputs here to avoid cluttering subsequent code.</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;barstacked&#39;</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="s1">&#39;stepfilled&#39;</span><span class="p">],</span>
                           <span class="n">histtype</span><span class="o">=</span><span class="n">histtype</span><span class="p">)</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">)</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="s1">&#39;vertical&#39;</span><span class="p">],</span> <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;barstacked&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">stacked</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Massage &#39;x&#39; for processing.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_reshape_2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># number of datasets</span>

        <span class="c1"># Process unit information.  _process_unit_info sets the unit and</span>
        <span class="c1"># converts the first dataset; then we convert each following dataset</span>
        <span class="c1"># one at a time.</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
            <span class="n">convert_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="n">kwargs</span><span class="p">),</span>
                 <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">convert_units</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># horizontal</span>
            <span class="n">convert_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="n">kwargs</span><span class="p">),</span>
                 <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">convert_units</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

        <span class="k">if</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_range</span> <span class="o">=</span> <span class="n">convert_units</span><span class="p">(</span><span class="n">bin_range</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_scalar_or_string</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">convert_units</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

        <span class="c1"># We need to do to &#39;weights&#39; what was done to &#39;x&#39;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_reshape_2D</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nx</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weights should have the same shape as x&#39;</span><span class="p">)</span>

        <span class="n">input_empty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
            <span class="n">len_xi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span> <span class="o">!=</span> <span class="n">len_xi</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weights should have the same shape as x&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">len_xi</span><span class="p">:</span>
                <span class="n">input_empty</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The &#39;color&#39; keyword argument must have one &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;color per dataset, but </span><span class="si">{</span><span class="n">nx</span><span class="si">}</span><span class="s2"> datasets and &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span><span class="si">}</span><span class="s2"> colors were provided&quot;</span><span class="p">)</span>

        <span class="n">hist_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># if the bin_range is not given, compute without nan numpy</span>
        <span class="c1"># does not do this for us when guessing the range (but will</span>
        <span class="c1"># happily ignore nans when computing the histogram).</span>
        <span class="k">if</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
                    <span class="c1"># python&#39;s min/max ignore nan,</span>
                    <span class="c1"># np.minnan returns nan for all nan input</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
                    <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">xmin</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">:</span>  <span class="c1"># Only happens if we have seen a finite value.</span>
                <span class="n">bin_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="c1"># If bins are not specified either explicitly or via range,</span>
        <span class="c1"># we need to figure out the range required for all datasets,</span>
        <span class="c1"># and supply that to np.histogram.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_empty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_w</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bins</span><span class="p">,</span> <span class="n">bin_range</span><span class="p">,</span> <span class="n">_w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hist_kwargs</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_range</span>

        <span class="n">density</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">density</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">hist_kwargs</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span>

        <span class="c1"># List to store all the top coordinates of the histograms</span>
        <span class="n">tops</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Will have shape (n_datasets, n_bins).</span>
        <span class="c1"># Loop through datasets</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="c1"># this will automatically overwrite bins,</span>
            <span class="c1"># so that each histogram uses the same bins</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">hist_kwargs</span><span class="p">)</span>
            <span class="n">tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">tops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tops</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>  <span class="c1"># causes problems later if it&#39;s an int</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>  <span class="c1"># causes problems if float16</span>
        <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">tops</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># If a stacked density plot, normalize so the area of all the</span>
            <span class="c1"># stacked histograms together is 1</span>
            <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">=</span> <span class="p">(</span><span class="n">tops</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span> <span class="o">/</span> <span class="n">tops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cumulative</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cumulative</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">=</span> <span class="p">(</span><span class="n">tops</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">))[:,</span> <span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">slc</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">=</span> <span class="n">tops</span><span class="p">[:,</span> <span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">slc</span><span class="p">]</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">):</span>

            <span class="n">totwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">rwidth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                  <span class="p">((</span><span class="ow">not</span> <span class="n">stacked</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">])):</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">0.8</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span> <span class="o">/</span> <span class="n">nx</span>
                <span class="n">dw</span> <span class="o">=</span> <span class="n">width</span>
                <span class="n">boffset</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;barstacked&#39;</span> <span class="ow">or</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span>
                <span class="n">boffset</span><span class="p">,</span> <span class="n">dw</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;mid&#39;</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">totwidth</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">totwidth</span>

            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">barh</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == &#39;vertical&#39;</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">&#39;bottom&#39;</span>

            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tops</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">bottom</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">bars</span> <span class="o">=</span> <span class="n">_barfunc</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">boffset</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span>
                                <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">bottom_kwarg</span><span class="p">:</span> <span class="n">bottom</span><span class="p">})</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bars</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">dw</span>
            <span class="c1"># Remove stickies from all bars but the lowest ones, as otherwise</span>
            <span class="c1"># margin expansion would be unable to cross the stickies in the</span>
            <span class="c1"># middle of the bars.</span>
            <span class="k">for</span> <span class="n">bars</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">bars</span><span class="p">:</span>
                    <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">elif</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">):</span>
            <span class="c1"># these define the perimeter of the polygon</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">,</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bottom</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonpositive</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == &#39;vertical&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonpositive</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">-=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># If fill kwarg is set, it will be passed to the patch collection,</span>
            <span class="c1"># overriding this</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="p">(</span><span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>

            <span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="c1"># top of the previous polygon becomes the bottom</span>
                    <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># set the top of this polygon</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">bottom</span>

                <span class="c1"># The starting point of the polygon has not yet been</span>
                <span class="c1"># updated. So far only the endpoint was adjusted. This</span>
                <span class="c1"># assignment closes the polygon. The redundant endpoint is</span>
                <span class="c1"># later discarded (for step and stepfilled).</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="c1"># stepfill is closed, step is not</span>
            <span class="n">split</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="c1"># add patches in reverse order so that when stacking,</span>
            <span class="c1"># items lower in the stack are plotted on top of</span>
            <span class="c1"># items higher in the stack</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">color</span><span class="p">))):</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span>
                    <span class="n">closed</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                    <span class="n">edgecolor</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="n">c</span><span class="p">,</span>
                    <span class="n">fill</span><span class="o">=</span><span class="n">fill</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">zorder</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">patch_list</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">patch_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># we return patches, so put it back in the expected order</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="c1"># If None, make all labels None (via zip_longest below); otherwise,</span>
        <span class="c1"># cast each element to str, but keep a single str as it.</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">patch</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">patch</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">patch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patch</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">_internal_update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">patches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">patch_type</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;BarContainer&quot;</span> <span class="k">if</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
                          <span class="k">else</span> <span class="s2">&quot;list[Polygon]&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tops</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="n">patch_type</span><span class="p">,</span> <span class="n">patches</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.stairs"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.stairs">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">stairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
               <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A stepwise constant function as a line with bounding edges</span>
<span class="sd">        or a filled plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : array-like</span>
<span class="sd">            The step heights.</span>

<span class="sd">        edges : array-like</span>
<span class="sd">            The edge positions, with ``len(edges) == len(vals) + 1``,</span>
<span class="sd">            between which the curve takes on vals values.</span>

<span class="sd">        orientation : {&#39;vertical&#39;, &#39;horizontal&#39;}, default: &#39;vertical&#39;</span>
<span class="sd">            The direction of the steps. Vertical means that *values* are along</span>
<span class="sd">            the y-axis, and edges are along the x-axis.</span>

<span class="sd">        baseline : float, array-like or None, default: 0</span>
<span class="sd">            The bottom value of the bounding edges or when</span>
<span class="sd">            ``fill=True``, position of lower edge. If *fill* is</span>
<span class="sd">            True or an array is passed to *baseline*, a closed</span>
<span class="sd">            path is drawn.</span>

<span class="sd">        fill : bool, default: False</span>
<span class="sd">            Whether the area under the step curve should be filled.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        StepPatch : `matplotlib.patches.StepPatch`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            `~matplotlib.patches.StepPatch` properties</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">_color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fill</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;facecolor&#39;</span><span class="p">,</span> <span class="n">_color</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="n">_color</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">edges</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">edges</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)],</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">StepPatch</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">edges</span><span class="p">,</span>
                                   <span class="n">baseline</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
                                   <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                                   <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">baseline</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">([(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">baseline</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">baseline</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">baseline</span><span class="p">),</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">patch</span></div>

<div class="viewcode-block" id="Axes.hist2d"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.hist2d">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;weights&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">hist2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">cmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a 2D histogram plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like, shape (n, )</span>
<span class="sd">            Input values</span>

<span class="sd">        bins : None or int or [int, int] or array-like or [array, array]</span>

<span class="sd">            The bin specification:</span>

<span class="sd">            - If int, the number of bins for the two dimensions</span>
<span class="sd">              (nx=ny=bins).</span>
<span class="sd">            - If ``[int, int]``, the number of bins in each dimension</span>
<span class="sd">              (nx, ny = bins).</span>
<span class="sd">            - If array-like, the bin edges for the two dimensions</span>
<span class="sd">              (x_edges=y_edges=bins).</span>
<span class="sd">            - If ``[array, array]``, the bin edges in each dimension</span>
<span class="sd">              (x_edges, y_edges = bins).</span>

<span class="sd">            The default value is 10.</span>

<span class="sd">        range : array-like shape(2, 2), optional</span>
<span class="sd">            The leftmost and rightmost edges of the bins along each dimension</span>
<span class="sd">            (if not specified explicitly in the bins parameters): ``[[xmin,</span>
<span class="sd">            xmax], [ymin, ymax]]``. All values outside of this range will be</span>
<span class="sd">            considered outliers and not tallied in the histogram.</span>

<span class="sd">        density : bool, default: False</span>
<span class="sd">            Normalize histogram.  See the documentation for the *density*</span>
<span class="sd">            parameter of `~.Axes.hist` for more details.</span>

<span class="sd">        weights : array-like, shape (n, ), optional</span>
<span class="sd">            An array of values w_i weighing each sample (x_i, y_i).</span>

<span class="sd">        cmin, cmax : float, default: None</span>
<span class="sd">            All bins that has count less than *cmin* or more than *cmax* will</span>
<span class="sd">            not be displayed (set to NaN before passing to imshow) and these</span>
<span class="sd">            count values in the return value count histogram will also be set</span>
<span class="sd">            to nan upon return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : 2D array</span>
<span class="sd">            The bi-dimensional histogram of samples x and y. Values in x are</span>
<span class="sd">            histogrammed along the first dimension and values in y are</span>
<span class="sd">            histogrammed along the second dimension.</span>
<span class="sd">        xedges : 1D array</span>
<span class="sd">            The bin edges along the x axis.</span>
<span class="sd">        yedges : 1D array</span>
<span class="sd">            The bin edges along the y axis.</span>
<span class="sd">        image : `~.matplotlib.collections.QuadMesh`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        %(cmap_doc)s</span>

<span class="sd">        %(norm_doc)s</span>

<span class="sd">        %(vmin_vmax_doc)s</span>

<span class="sd">        alpha : ``0 &lt;= scalar &lt;= 1`` or ``None``, optional</span>
<span class="sd">            The alpha blending value.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional parameters are passed along to the</span>
<span class="sd">            `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`</span>
<span class="sd">            constructor.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hist : 1D histogram plotting</span>
<span class="sd">        hexbin : 2D histogram with hexagonal bins</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Currently ``hist2d`` calculates its own axis limits, and any limits</span>
<span class="sd">          previously set are ignored.</span>
<span class="sd">        - Rendering the histogram with a logarithmic color scale is</span>
<span class="sd">          accomplished by passing a `.colors.LogNorm` instance to the *norm*</span>
<span class="sd">          keyword argument. Likewise, power-law normalization (similar</span>
<span class="sd">          in effect to gamma correction) can be accomplished with</span>
<span class="sd">          `.colors.PowerNorm`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span>
                                           <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">cmax</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">yedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">pc</span></div>

<div class="viewcode-block" id="Axes.psd"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.psd">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the power spectral density.</span>

<span class="sd">        The power spectral density :math:`P_{xx}` by Welch&#39;s average</span>
<span class="sd">        periodogram method.  The vector *x* is divided into *NFFT* length</span>
<span class="sd">        segments.  Each segment is detrended by function *detrend* and</span>
<span class="sd">        windowed by function *window*.  *noverlap* gives the length of</span>
<span class="sd">        the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`</span>
<span class="sd">        of each segment :math:`i` are averaged to compute :math:`P_{xx}`,</span>
<span class="sd">        with a scaling to correct for power loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : int, default: 0 (no overlap)</span>
<span class="sd">            The number of points of overlap between segments.</span>

<span class="sd">        Fc : int, default: 0</span>
<span class="sd">            The center frequency of *x*, which offsets the x extents of the</span>
<span class="sd">            plot to reflect the frequency range used when a signal is acquired</span>
<span class="sd">            and then filtered and downsampled to baseband.</span>

<span class="sd">        return_line : bool, default: False</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pxx : 1-D array</span>
<span class="sd">            The values for the power spectrum :math:`P_{xx}` before scaling</span>
<span class="sd">            (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxx*.</span>

<span class="sd">        line : `~matplotlib.lines.Line2D`</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returned if *return_line* is True.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        specgram</span>
<span class="sd">            Differs in the default overlap; in not returning the mean of the</span>
<span class="sd">            segment periodograms; in returning the times of the segments; and</span>
<span class="sd">            in plotting a colormap instead of a line.</span>
<span class="sd">        magnitude_spectrum</span>
<span class="sd">            Plots the magnitude spectrum.</span>
<span class="sd">        csd</span>
<span class="sd">            Plots the spectral density between two signals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="k">if</span> <span class="n">scale_by_freq</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">&#39;dB/Hz&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pxx</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Power Spectral Density (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">psd_units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ybound</span><span class="p">()</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span></div>

<div class="viewcode-block" id="Axes.csd"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.csd">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">csd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the cross-spectral density.</span>

<span class="sd">        The cross spectral density :math:`P_{xy}` by Welch&#39;s average</span>
<span class="sd">        periodogram method.  The vectors *x* and *y* are divided into</span>
<span class="sd">        *NFFT* length segments.  Each segment is detrended by function</span>
<span class="sd">        *detrend* and windowed by function *window*.  *noverlap* gives</span>
<span class="sd">        the length of the overlap between segments.  The product of</span>
<span class="sd">        the direct FFTs of *x* and *y* are averaged over each segment</span>
<span class="sd">        to compute :math:`P_{xy}`, with a scaling to correct for power</span>
<span class="sd">        loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero</span>
<span class="sd">        padded to *NFFT*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : 1-D arrays or sequences</span>
<span class="sd">            Arrays or sequences containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : int, default: 0 (no overlap)</span>
<span class="sd">            The number of points of overlap between segments.</span>

<span class="sd">        Fc : int, default: 0</span>
<span class="sd">            The center frequency of *x*, which offsets the x extents of the</span>
<span class="sd">            plot to reflect the frequency range used when a signal is acquired</span>
<span class="sd">            and then filtered and downsampled to baseband.</span>

<span class="sd">        return_line : bool, default: False</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pxy : 1-D array</span>
<span class="sd">            The values for the cross spectrum :math:`P_{xy}` before scaling</span>
<span class="sd">            (complex valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxy*.</span>

<span class="sd">        line : `~matplotlib.lines.Line2D`</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returned if *return_line* is True.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        psd : is equivalent to setting ``y = x``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="c1"># pxy is complex</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pxy</span><span class="p">)),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Cross Spectrum Magnitude (dB)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ybound</span><span class="p">()</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span></div>

<div class="viewcode-block" id="Axes.magnitude_spectrum"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.magnitude_spectrum">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">magnitude_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the magnitude spectrum.</span>

<span class="sd">        Compute the magnitude spectrum of *x*.  Data is padded to a</span>
<span class="sd">        length of *pad_to* and the windowing function *window* is applied to</span>
<span class="sd">        the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        scale : {&#39;default&#39;, &#39;linear&#39;, &#39;dB&#39;}</span>
<span class="sd">            The scaling of the values in the *spec*.  &#39;linear&#39; is no scaling.</span>
<span class="sd">            &#39;dB&#39; returns the values in dB scale, i.e., the dB amplitude</span>
<span class="sd">            (20 * log10). &#39;default&#39; is &#39;linear&#39;.</span>

<span class="sd">        Fc : int, default: 0</span>
<span class="sd">            The center frequency of *x*, which offsets the x extents of the</span>
<span class="sd">            plot to reflect the frequency range used when a signal is acquired</span>
<span class="sd">            and then filtered and downsampled to baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the magnitude spectrum before scaling (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*.</span>

<span class="sd">        line : `~matplotlib.lines.Line2D`</span>
<span class="sd">            The line created by this function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        psd</span>
<span class="sd">            Plots the power spectral density.</span>
<span class="sd">        angle_spectrum</span>
<span class="sd">            Plots the angles of the corresponding frequencies.</span>
<span class="sd">        phase_spectrum</span>
<span class="sd">            Plots the phase (unwrapped angle) of the corresponding frequencies.</span>
<span class="sd">        specgram</span>
<span class="sd">            Can plot the magnitude spectrum of segments within the signal in a</span>
<span class="sd">            colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">magnitude_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                              <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">yunits</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">check_getitem</span><span class="p">(</span>
            <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="s1">&#39;energy&#39;</span><span class="p">,</span>
             <span class="s1">&#39;dB&#39;</span><span class="p">:</span> <span class="s1">&#39;dB&#39;</span><span class="p">},</span>
            <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yunits</span> <span class="o">==</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># yunits == &#39;dB&#39;</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

        <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">yunits</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span></div>

<div class="viewcode-block" id="Axes.angle_spectrum"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.angle_spectrum">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">angle_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the angle spectrum.</span>

<span class="sd">        Compute the angle spectrum (wrapped phase spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        Fc : int, default: 0</span>
<span class="sd">            The center frequency of *x*, which offsets the x extents of the</span>
<span class="sd">            plot to reflect the frequency range used when a signal is acquired</span>
<span class="sd">            and then filtered and downsampled to baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the angle spectrum in radians (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*.</span>

<span class="sd">        line : `~matplotlib.lines.Line2D`</span>
<span class="sd">            The line created by this function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        magnitude_spectrum</span>
<span class="sd">            Plots the magnitudes of the corresponding frequencies.</span>
<span class="sd">        phase_spectrum</span>
<span class="sd">            Plots the unwrapped version of this function.</span>
<span class="sd">        specgram</span>
<span class="sd">            Can plot the angle spectrum of segments within the signal in a</span>
<span class="sd">            colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">angle_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Angle (radians)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Axes.phase_spectrum"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.phase_spectrum">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">phase_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the phase spectrum.</span>

<span class="sd">        Compute the phase spectrum (unwrapped angle spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        Fc : int, default: 0</span>
<span class="sd">            The center frequency of *x*, which offsets the x extents of the</span>
<span class="sd">            plot to reflect the frequency range used when a signal is acquired</span>
<span class="sd">            and then filtered and downsampled to baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the phase spectrum in radians (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*.</span>

<span class="sd">        line : `~matplotlib.lines.Line2D`</span>
<span class="sd">            The line created by this function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        magnitude_spectrum</span>
<span class="sd">            Plots the magnitudes of the corresponding frequencies.</span>
<span class="sd">        angle_spectrum</span>
<span class="sd">            Plots the wrapped version of this function.</span>
<span class="sd">        specgram</span>
<span class="sd">            Can plot the phase spectrum of segments within the signal in a</span>
<span class="sd">            colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">phase_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (radians)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Axes.cohere"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.cohere">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">cohere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
               <span class="n">window</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">window_hanning</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the coherence between *x* and *y*.</span>

<span class="sd">        Coherence is the normalized cross spectral density:</span>

<span class="sd">        .. math::</span>

<span class="sd">          C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : int, default: 0 (no overlap)</span>
<span class="sd">            The number of points of overlap between blocks.</span>

<span class="sd">        Fc : int, default: 0</span>
<span class="sd">            The center frequency of *x*, which offsets the x extents of the</span>
<span class="sd">            plot to reflect the frequency range used when a signal is acquired</span>
<span class="sd">            and then filtered and downsampled to baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Cxy : 1-D array</span>
<span class="sd">            The coherence vector.</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies for the elements in *Cxy*.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the `.Line2D` properties:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">cohere</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                                 <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                 <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">cxy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span></div>

<div class="viewcode-block" id="Axes.specgram"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.specgram">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">specgram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xextent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a spectrogram.</span>

<span class="sd">        Compute and plot a spectrogram of data in *x*.  Data are split into</span>
<span class="sd">        *NFFT* length segments and the spectrum of each section is</span>
<span class="sd">        computed.  The windowing function *window* is applied to each</span>
<span class="sd">        segment, and the amount of overlap of each segment is</span>
<span class="sd">        specified with *noverlap*. The spectrogram is plotted as a colormap</span>
<span class="sd">        (using imshow).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        mode : {&#39;default&#39;, &#39;psd&#39;, &#39;magnitude&#39;, &#39;angle&#39;, &#39;phase&#39;}</span>
<span class="sd">            What sort of spectrum to use.  Default is &#39;psd&#39;, which takes the</span>
<span class="sd">            power spectral density.  &#39;magnitude&#39; returns the magnitude</span>
<span class="sd">            spectrum.  &#39;angle&#39; returns the phase spectrum without unwrapping.</span>
<span class="sd">            &#39;phase&#39; returns the phase spectrum with unwrapping.</span>

<span class="sd">        noverlap : int, default: 128</span>
<span class="sd">            The number of points of overlap between blocks.</span>

<span class="sd">        scale : {&#39;default&#39;, &#39;linear&#39;, &#39;dB&#39;}</span>
<span class="sd">            The scaling of the values in the *spec*.  &#39;linear&#39; is no scaling.</span>
<span class="sd">            &#39;dB&#39; returns the values in dB scale.  When *mode* is &#39;psd&#39;,</span>
<span class="sd">            this is dB power (10 * log10).  Otherwise this is dB amplitude</span>
<span class="sd">            (20 * log10). &#39;default&#39; is &#39;dB&#39; if *mode* is &#39;psd&#39; or</span>
<span class="sd">            &#39;magnitude&#39; and &#39;linear&#39; otherwise.  This must be &#39;linear&#39;</span>
<span class="sd">            if *mode* is &#39;angle&#39; or &#39;phase&#39;.</span>

<span class="sd">        Fc : int, default: 0</span>
<span class="sd">            The center frequency of *x*, which offsets the x extents of the</span>
<span class="sd">            plot to reflect the frequency range used when a signal is acquired</span>
<span class="sd">            and then filtered and downsampled to baseband.</span>

<span class="sd">        cmap : `.Colormap`, default: :rc:`image.cmap`</span>

<span class="sd">        xextent : *None* or (xmin, xmax)</span>
<span class="sd">            The image extent along the x-axis. The default sets *xmin* to the</span>
<span class="sd">            left border of the first bin (*spectrum* column) and *xmax* to the</span>
<span class="sd">            right border of the last bin. Note that for *noverlap&gt;0* the width</span>
<span class="sd">            of the bins is smaller than those of the segments.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments are passed on to `~.axes.Axes.imshow`</span>
<span class="sd">            which makes the specgram image. The origin keyword argument</span>
<span class="sd">            is not supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 2D array</span>
<span class="sd">            Columns are the periodograms of successive segments.</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the rows in *spectrum*.</span>

<span class="sd">        t : 1-D array</span>
<span class="sd">            The times corresponding to midpoints of segments (i.e., the columns</span>
<span class="sd">            in *spectrum*).</span>

<span class="sd">        im : `.AxesImage`</span>
<span class="sd">            The image created by imshow containing the spectrogram.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        psd</span>
<span class="sd">            Differs in the default overlap; in returning the mean of the</span>
<span class="sd">            segment periodograms; in not returning times; and in generating a</span>
<span class="sd">            line plot instead of colormap.</span>
<span class="sd">        magnitude_spectrum</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is &#39;magnitude&#39;. Plots a line instead of a colormap.</span>
<span class="sd">        angle_spectrum</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is &#39;angle&#39;. Plots a line instead of a colormap.</span>
<span class="sd">        phase_spectrum</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is &#39;phase&#39;. Plots a line instead of a colormap.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The parameters *detrend* and *scale_by_freq* do only apply when *mode*</span>
<span class="sd">        is set to &#39;psd&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># same default as in mlab.specgram()</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># same default as in mlab._spectral_helper()</span>
        <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># same default as in mlab.specgram()</span>
        <span class="k">if</span> <span class="n">Fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fs</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># same default as in mlab._spectral_helper()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot plot a complex specgram&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use dB scale with angle or phase mode&#39;</span><span class="p">)</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">specgram</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                       <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                       <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                       <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                       <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown scale </span><span class="si">{</span><span class="n">scale</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xextent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># padding is needed for first and last segment:</span>
            <span class="n">pad_xextent</span> <span class="o">=</span> <span class="p">(</span><span class="n">NFFT</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span> <span class="o">/</span> <span class="n">Fs</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">xextent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">pad_xextent</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">pad_xextent</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">xextent</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;origin&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;specgram() got an unexpected keyword argument &quot;</span>
                            <span class="s2">&quot;&#39;origin&#39;&quot;</span><span class="p">)</span>

        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                         <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">im</span></div>

<div class="viewcode-block" id="Axes.spy"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.spy">[docs]</a>    <span class="nd">@_docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">spy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the sparsity pattern of a 2D array.</span>

<span class="sd">        This visualizes the non-zero values of the array.</span>

<span class="sd">        Two plotting styles are available: image and marker. Both</span>
<span class="sd">        are available for full arrays, but only the marker style</span>
<span class="sd">        works for `scipy.sparse.spmatrix` instances.</span>

<span class="sd">        **Image style**</span>

<span class="sd">        If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any</span>
<span class="sd">        extra remaining keyword arguments are passed to this method.</span>

<span class="sd">        **Marker style**</span>

<span class="sd">        If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are</span>
<span class="sd">        *None*, a `.Line2D` object will be returned with the value of marker</span>
<span class="sd">        determining the marker type, and any remaining keyword arguments</span>
<span class="sd">        passed to `~.Axes.plot`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Z : (M, N) array-like</span>
<span class="sd">            The array to be plotted.</span>

<span class="sd">        precision : float or &#39;present&#39;, default: 0</span>
<span class="sd">            If *precision* is 0, any non-zero value will be plotted. Otherwise,</span>
<span class="sd">            values of :math:`|Z| &gt; precision` will be plotted.</span>

<span class="sd">            For `scipy.sparse.spmatrix` instances, you can also</span>
<span class="sd">            pass &#39;present&#39;. In this case any value present in the array</span>
<span class="sd">            will be plotted, even if it is identically zero.</span>

<span class="sd">        aspect : {&#39;equal&#39;, &#39;auto&#39;, None} or float, default: &#39;equal&#39;</span>
<span class="sd">            The aspect ratio of the Axes.  This parameter is particularly</span>
<span class="sd">            relevant for images since it determines whether data pixels are</span>
<span class="sd">            square.</span>

<span class="sd">            This parameter is a shortcut for explicitly calling</span>
<span class="sd">            `.Axes.set_aspect`. See there for further details.</span>

<span class="sd">            - &#39;equal&#39;: Ensures an aspect ratio of 1. Pixels will be square.</span>
<span class="sd">            - &#39;auto&#39;: The Axes is kept fixed and the aspect is adjusted so</span>
<span class="sd">              that the data fit in the Axes. In general, this will result in</span>
<span class="sd">              non-square pixels.</span>
<span class="sd">            - *None*: Use :rc:`image.aspect`.</span>

<span class="sd">        origin : {&#39;upper&#39;, &#39;lower&#39;}, default: :rc:`image.origin`</span>
<span class="sd">            Place the [0, 0] index of the array in the upper left or lower left</span>
<span class="sd">            corner of the Axes. The convention &#39;upper&#39; is typically used for</span>
<span class="sd">            matrices and images.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.image.AxesImage` or `.Line2D`</span>
<span class="sd">            The return type depends on the plotting style (see above).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            The supported additional parameters depend on the plotting style.</span>

<span class="sd">            For the image style, you can pass the following additional</span>
<span class="sd">            parameters of `~.Axes.imshow`:</span>

<span class="sd">            - *cmap*</span>
<span class="sd">            - *alpha*</span>
<span class="sd">            - *url*</span>
<span class="sd">            - any `.Artist` properties (passed on to the `.AxesImage`)</span>

<span class="sd">            For the marker style, you can pass any `.Line2D` property except</span>
<span class="sd">            for *linestyle*:</span>

<span class="sd">            %(Line2D:kwdoc)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">&#39;tocoo&#39;</span><span class="p">):</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">([</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">],</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>

            <span class="k">if</span> <span class="s1">&#39;cmap&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">([</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span>
                                                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;interpolation&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;spy() got an unexpected keyword argument &#39;interpolation&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;norm&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                              <span class="n">aspect</span><span class="o">=</span><span class="n">aspect</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">&#39;tocoo&#39;</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">precision</span> <span class="o">==</span> <span class="s1">&#39;present&#39;</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
                <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
            <span class="k">if</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">markersize</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="s1">&#39;linestyle&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;spy() got an unexpected keyword argument &#39;linestyle&#39;&quot;</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">nc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">nr</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># lower</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_bottom</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span>
            <span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span>
            <span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Axes.matshow"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.matshow">[docs]</a>    <span class="k">def</span> <span class="nf">matshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the values of a 2D matrix or array as color-coded image.</span>

<span class="sd">        The matrix will be shown the way it would be printed, with the first</span>
<span class="sd">        row at the top.  Row and column numbering is zero-based.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Z : (M, N) array-like</span>
<span class="sd">            The matrix to be displayed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.axes.Axes.imshow` arguments</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        imshow : More general function to plot data on a 2D regular raster.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is just a convenience function wrapping `.imshow` to set useful</span>
<span class="sd">        defaults for displaying a matrix. In particular:</span>

<span class="sd">        - Set ``origin=&#39;upper&#39;``.</span>
<span class="sd">        - Set ``interpolation=&#39;nearest&#39;``.</span>
<span class="sd">        - Set ``aspect=&#39;equal&#39;``.</span>
<span class="sd">        - Ticks are placed to the left and above.</span>
<span class="sd">        - Ticks are formatted to show integer indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;origin&#39;</span><span class="p">:</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span>
              <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
              <span class="s1">&#39;aspect&#39;</span><span class="p">:</span> <span class="s1">&#39;equal&#39;</span><span class="p">,</span>          <span class="c1"># (already the imshow default)</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">}</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span>
            <span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span>
            <span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">im</span></div>

<div class="viewcode-block" id="Axes.violinplot"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.violinplot">[docs]</a>    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dataset&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">violinplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                   <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">quantiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a violin plot.</span>

<span class="sd">        Make a violin plot for each column of *dataset* or each vector in</span>
<span class="sd">        sequence *dataset*.  Each filled area extends to represent the</span>
<span class="sd">        entire data range, with optional lines at the mean, the median,</span>
<span class="sd">        the minimum, the maximum, and user-specified quantiles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : Array or a sequence of vectors.</span>
<span class="sd">          The input data.</span>

<span class="sd">        positions : array-like, default: [1, 2, ..., n]</span>
<span class="sd">          The positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default: True.</span>
<span class="sd">          If true, creates a vertical violin plot.</span>
<span class="sd">          Otherwise, creates a horizontal violin plot.</span>

<span class="sd">        widths : array-like, default: 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default: False</span>
<span class="sd">          If `True`, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default: True</span>
<span class="sd">          If `True`, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default: False</span>
<span class="sd">          If `True`, will toggle rendering of the medians.</span>

<span class="sd">        quantiles : array-like, default: None</span>
<span class="sd">          If not None, set a list of floats in interval [0, 1] for each violin,</span>
<span class="sd">          which stands for the quantiles that will be rendered for that</span>
<span class="sd">          violin.</span>

<span class="sd">        points : int, default: 100</span>
<span class="sd">          Defines the number of points to evaluate each of the</span>
<span class="sd">          gaussian kernel density estimations at.</span>

<span class="sd">        bw_method : str, scalar or callable, optional</span>
<span class="sd">          The method used to calculate the estimator bandwidth.  This can be</span>
<span class="sd">          &#39;scott&#39;, &#39;silverman&#39;, a scalar constant or a callable.  If a</span>
<span class="sd">          scalar, this will be used directly as `kde.factor`.  If a</span>
<span class="sd">          callable, it should take a `matplotlib.mlab.GaussianKDE` instance as</span>
<span class="sd">          its only parameter and return a scalar. If None (default), &#39;scott&#39;</span>
<span class="sd">          is used.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            DATA_PARAMETER_PLACEHOLDER</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">          - ``bodies``: A list of the `~.collections.PolyCollection`</span>
<span class="sd">            instances containing the filled area of each violin.</span>

<span class="sd">          - ``cmeans``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the mean values of each of the violin&#39;s distribution.</span>

<span class="sd">          - ``cmins``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the bottom of each violin&#39;s distribution.</span>

<span class="sd">          - ``cmaxes``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the top of each violin&#39;s distribution.</span>

<span class="sd">          - ``cbars``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the centers of each violin&#39;s distribution.</span>

<span class="sd">          - ``cmedians``: A `~.collections.LineCollection` instance that</span>
<span class="sd">            marks the median values of each of the violin&#39;s distribution.</span>

<span class="sd">          - ``cquantiles``: A `~.collections.LineCollection` instance created</span>
<span class="sd">            to identify the quantile values of each of the violin&#39;s</span>
<span class="sd">            distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_kde_method</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
            <span class="c1"># Unpack in case of e.g. Pandas or xarray object</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_unpack_to_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="c1"># fallback gracefully if the vector contains only one value</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">kde</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">GaussianKDE</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bw_method</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kde</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">vpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">violin_stats</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">_kde_method</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                                     <span class="n">quantiles</span><span class="o">=</span><span class="n">quantiles</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">violin</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span>
                           <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showextrema</span><span class="o">=</span><span class="n">showextrema</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="n">showmedians</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.violin"><a class="viewcode-back" href="../../../_autosummary/smpl.plot.Axes.html#smpl.plot.Axes.violin">[docs]</a>    <span class="k">def</span> <span class="nf">violin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drawing function for violin plots.</span>

<span class="sd">        Draw a violin plot for each column of *vpstats*. Each filled area</span>
<span class="sd">        extends to represent the entire data range, with optional lines at the</span>
<span class="sd">        mean, the median, the minimum, the maximum, and the quantiles values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each violin plot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``coords``: A list of scalars containing the coordinates that</span>
<span class="sd">            the violin&#39;s kernel density estimate were evaluated at.</span>

<span class="sd">          - ``vals``: A list of scalars containing the values of the</span>
<span class="sd">            kernel density estimate at each of the coordinates given</span>
<span class="sd">            in *coords*.</span>

<span class="sd">          - ``mean``: The mean value for this violin&#39;s dataset.</span>

<span class="sd">          - ``median``: The median value for this violin&#39;s dataset.</span>

<span class="sd">          - ``min``: The minimum value for this violin&#39;s dataset.</span>

<span class="sd">          - ``max``: The maximum value for this violin&#39;s dataset.</span>

<span class="sd">          Optional keys are:</span>

<span class="sd">          - ``quantiles``: A list of scalars containing the quantile values</span>
<span class="sd">            for this violin&#39;s dataset.</span>

<span class="sd">        positions : array-like, default: [1, 2, ..., n]</span>
<span class="sd">          The positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default: True.</span>
<span class="sd">          If true, plots the violins vertically.</span>
<span class="sd">          Otherwise, plots the violins horizontally.</span>

<span class="sd">        widths : array-like, default: 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default: False</span>
<span class="sd">          If true, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default: True</span>
<span class="sd">          If true, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default: False</span>
<span class="sd">          If true, will toggle rendering of the medians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">          - ``bodies``: A list of the `~.collections.PolyCollection`</span>
<span class="sd">            instances containing the filled area of each violin.</span>

<span class="sd">          - ``cmeans``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the mean values of each of the violin&#39;s distribution.</span>

<span class="sd">          - ``cmins``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the bottom of each violin&#39;s distribution.</span>

<span class="sd">          - ``cmaxes``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the top of each violin&#39;s distribution.</span>

<span class="sd">          - ``cbars``: A `~.collections.LineCollection` instance that marks</span>
<span class="sd">            the centers of each violin&#39;s distribution.</span>

<span class="sd">          - ``cmedians``: A `~.collections.LineCollection` instance that</span>
<span class="sd">            marks the median values of each of the violin&#39;s distribution.</span>

<span class="sd">          - ``cquantiles``: A `~.collections.LineCollection` instance created</span>
<span class="sd">            to identify the quantiles values of each of the violin&#39;s</span>
<span class="sd">            distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Statistical quantities to be plotted on the violins</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quantiles</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">qlens</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Number of quantiles in each dataset.</span>

        <span class="n">artists</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Collections to be returned</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;List of violinplot statistics and `</span><span class="si">{0}</span><span class="s2">` &quot;</span>
                             <span class="s2">&quot;values must have the same length&quot;</span><span class="p">)</span>

        <span class="c1"># Validate positions</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;positions&quot;</span><span class="p">))</span>

        <span class="c1"># Validate widths</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;widths&quot;</span><span class="p">))</span>

        <span class="c1"># Calculate ranges for statistics lines (shape (2, N)).</span>
        <span class="n">line_ends</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.25</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">]]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">+</span> <span class="n">positions</span>

        <span class="c1"># Colors.</span>
        <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="n">fillcolor</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
            <span class="n">linecolor</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fillcolor</span> <span class="o">=</span> <span class="n">linecolor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>

        <span class="c1"># Check whether we are rendering vertically or horizontally</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_betweenx</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">linecolor</span><span class="p">)</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">linecolor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_between</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">linecolor</span><span class="p">)</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">linecolor</span><span class="p">)</span>

        <span class="c1"># Render violins</span>
        <span class="n">bodies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">):</span>
            <span class="c1"># The 0.5 factor reflects the fact that we plot from v-p to v+p.</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;vals&#39;</span><span class="p">])</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span> <span class="o">*</span> <span class="n">vals</span> <span class="o">/</span> <span class="n">vals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">bodies</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fill</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">],</span> <span class="o">-</span><span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
                            <span class="n">facecolor</span><span class="o">=</span><span class="n">fillcolor</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)]</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">])</span>
            <span class="n">mins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">])</span>
            <span class="n">maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;median&#39;</span><span class="p">])</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;quantiles&#39;</span><span class="p">)</span>  <span class="c1"># a list of floats, or None</span>
            <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">quantiles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">qlens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;bodies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bodies</span>

        <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>  <span class="c1"># Render means</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmeans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="o">*</span><span class="n">line_ends</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showextrema</span><span class="p">:</span>  <span class="c1"># Render extrema</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmaxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">maxes</span><span class="p">,</span> <span class="o">*</span><span class="n">line_ends</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">mins</span><span class="p">,</span> <span class="o">*</span><span class="n">line_ends</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cbars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_lines</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showmedians</span><span class="p">:</span>  <span class="c1"># Render medians</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmedians&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span> <span class="o">*</span><span class="n">line_ends</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">quantiles</span><span class="p">:</span>  <span class="c1"># Render quantiles: each width is repeated qlen times.</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cquantiles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span>
                <span class="n">quantiles</span><span class="p">,</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">line_ends</span><span class="p">,</span> <span class="n">qlens</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">artists</span></div>

    <span class="c1"># Methods that are entirely implemented in other modules.</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">mtable</span><span class="o">.</span><span class="n">table</span>

    <span class="c1"># args can by either Y or y1, y2, ... and all should be replaced</span>
    <span class="n">stackplot</span> <span class="o">=</span> <span class="n">_preprocess_data</span><span class="p">()(</span><span class="n">mstack</span><span class="o">.</span><span class="n">stackplot</span><span class="p">)</span>

    <span class="n">streamplot</span> <span class="o">=</span> <span class="n">_preprocess_data</span><span class="p">(</span>
        <span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;start_points&quot;</span><span class="p">])(</span><span class="n">mstream</span><span class="o">.</span><span class="n">streamplot</span><span class="p">)</span>

    <span class="n">tricontour</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontour</span>
    <span class="n">tricontourf</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontourf</span>
    <span class="n">tripcolor</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tripcolor</span>
    <span class="n">triplot</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">triplot</span>

    <span class="k">def</span> <span class="nf">_get_aspect_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to calculate the aspect ratio of the axes in</span>
<span class="sd">        the display coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">figure_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span><span class="o">.</span><span class="n">get_size_inches</span><span class="p">()</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">ur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span> <span class="o">*</span> <span class="n">figure_size</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">ur</span> <span class="o">-</span> <span class="n">ll</span>
        <span class="k">return</span> <span class="n">height</span> <span class="o">/</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_ratio</span><span class="p">())</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Alexander Puck Neuwirth.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>