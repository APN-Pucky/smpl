
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>uncertainties.unumpy.core &#8212; smpl  documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for uncertainties.unumpy.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core functions used by unumpy and some of its submodules.</span>

<span class="sd">(c) 2010-2016 by Eric O. LEBIGOT (EOL).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># The functions found in this module cannot be defined in unumpy or</span>
<span class="c1"># its submodule: this creates import loops, when unumpy explicitly</span>
<span class="c1"># imports one of the submodules in order to make it available to the</span>
<span class="c1"># user.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="c1"># Standard modules:</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">next</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">range</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="c1"># 3rd-party modules:</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="kn">import</span> <span class="n">numeric</span>

<span class="c1"># Local modules:</span>
<span class="kn">import</span> <span class="nn">uncertainties.umath_core</span> <span class="k">as</span> <span class="nn">umath_core</span>
<span class="kn">import</span> <span class="nn">uncertainties.core</span> <span class="k">as</span> <span class="nn">uncert_core</span>
<span class="kn">from</span> <span class="nn">uncertainties.core</span> <span class="kn">import</span> <span class="n">deprecation</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># Factory functions:</span>
    <span class="s1">&#39;uarray&#39;</span><span class="p">,</span> <span class="s1">&#39;umatrix&#39;</span><span class="p">,</span>

    <span class="c1"># Utilities:</span>
    <span class="s1">&#39;nominal_values&#39;</span><span class="p">,</span> <span class="s1">&#39;std_devs&#39;</span><span class="p">,</span>

    <span class="c1"># Classes:</span>
    <span class="s1">&#39;matrix&#39;</span>
    <span class="p">]</span>

<span class="c1">###############################################################################</span>
<span class="c1"># Utilities:</span>

<span class="c1"># nominal_values() and std_devs() are defined as functions (instead of</span>
<span class="c1"># as additional methods of the unumpy.matrix class) because the user</span>
<span class="c1"># might well directly build arrays of numbers with uncertainties</span>
<span class="c1"># without going through the factory functions found in this module</span>
<span class="c1"># (uarray() and umatrix()).  Thus,</span>
<span class="c1"># numpy.array([uncert_core.ufloat((1, 0.1))]) would not</span>
<span class="c1"># have a nominal_values() method.  Adding such a method to, say,</span>
<span class="c1"># unumpy.matrix, would break the symmetry between NumPy arrays and</span>
<span class="c1"># matrices (no nominal_values() method), and objects defined in this</span>
<span class="c1"># module.</span>

<span class="c1"># ! Warning: the __doc__ is set, but help(nominal_values) does not</span>
<span class="c1"># display it, but instead displays the documentation for the type of</span>
<span class="c1"># nominal_values (i.e. the documentation of its class):</span>

<span class="n">to_nominal_values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
    <span class="n">uncert_core</span><span class="o">.</span><span class="n">nominal_value</span><span class="p">,</span>
    <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>  <span class="c1"># Because vectorize() has side effects (dtype setting)</span>
    <span class="n">doc</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Return the nominal value of the numbers with uncertainties contained&quot;</span>
         <span class="s2">&quot; in a NumPy (or unumpy) array (this includes matrices).&quot;</span><span class="p">))</span>

<span class="n">to_std_devs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
    <span class="n">uncert_core</span><span class="o">.</span><span class="n">std_dev</span><span class="p">,</span>
    <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>  <span class="c1"># Because vectorize() has side effects (dtype setting)</span>
    <span class="n">doc</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Return the standard deviation of the numbers with uncertainties&quot;</span>
         <span class="s2">&quot; contained in a NumPy array, or zero for other objects.&quot;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">unumpy_to_numpy_matrix</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If arr in a unumpy.matrix, it is converted to a numpy.matrix.</span>
<span class="sd">    Otherwise, it is returned unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span> <span class="nf">nominal_values</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the nominal values of the numbers in NumPy array arr.</span>

<span class="sd">    Elements that are not numbers with uncertainties (derived from a</span>
<span class="sd">    class from this module) are passed through untouched (because a</span>
<span class="sd">    numpy.array can contain numbers with uncertainties and pure floats</span>
<span class="sd">    simultaneously).</span>

<span class="sd">    If arr is of type unumpy.matrix, the returned array is a</span>
<span class="sd">    numpy.matrix, because the resulting matrix does not contain</span>
<span class="sd">    numbers with uncertainties.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">unumpy_to_numpy_matrix</span><span class="p">(</span><span class="n">to_nominal_values</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">std_devs</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the standard deviations of the numbers in NumPy array arr.</span>

<span class="sd">    Elements that are not numbers with uncertainties (derived from a</span>
<span class="sd">    class from this module) are passed through untouched (because a</span>
<span class="sd">    numpy.array can contain numbers with uncertainties and pure floats</span>
<span class="sd">    simultaneously).</span>

<span class="sd">    If arr is of type unumpy.matrix, the returned array is a</span>
<span class="sd">    numpy.matrix, because the resulting matrix does not contain</span>
<span class="sd">    numbers with uncertainties.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">unumpy_to_numpy_matrix</span><span class="p">(</span><span class="n">to_std_devs</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>

<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the derivative of u along var, if u is an</span>
<span class="sd">    uncert_core.AffineScalarFunc instance, and if var is one of the</span>
<span class="sd">    variables on which it depends.  Otherwise, return 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">uncert_core</span><span class="o">.</span><span class="n">AffineScalarFunc</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">derivatives</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span>

<span class="k">def</span> <span class="nf">wrap_array_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="c1"># !!! This function is not used in the code, except in the tests.</span>
    <span class="c1">#</span>
    <span class="c1"># !!! The implementation seems superficially similar to</span>
    <span class="c1"># uncertainties.core.wrap(): is there code/logic duplication</span>
    <span class="c1"># (which should be removed)?</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a version of the function func() that works even when</span>
<span class="sd">    func() is given a NumPy array that contains numbers with</span>
<span class="sd">    uncertainties, as first argument.</span>

<span class="sd">    This wrapper is similar to uncertainties.core.wrap(), except that</span>
<span class="sd">    it handles an array argument instead of float arguments, and that</span>
<span class="sd">    the result can be an array.</span>

<span class="sd">    However, the returned function is more restricted: the array</span>
<span class="sd">    argument cannot be given as a keyword argument with the name in</span>
<span class="sd">    the original function (it is not a drop-in replacement).</span>

<span class="sd">    func -- function whose first argument is a single NumPy array,</span>
<span class="sd">    and which returns a NumPy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@uncert_core</span><span class="o">.</span><span class="n">set_doc</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">    Version of </span><span class="si">%s</span><span class="s2">(...) that works even when its first argument is a NumPy</span>
<span class="s2">    array that contains numbers with uncertainties.</span>

<span class="s2">    Warning: elements of the first argument array that are not</span>
<span class="s2">    AffineScalarFunc objects must not depend on uncert_core.Variable</span>
<span class="s2">    objects in any way.  Otherwise, the dependence of the result in</span>
<span class="s2">    uncert_core.Variable objects will be incorrect.</span>

<span class="s2">    Original documentation:</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">wrapped_func</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Nominal value:</span>
        <span class="n">arr_nominal_value</span> <span class="o">=</span> <span class="n">nominal_values</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">func_nominal_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">arr_nominal_value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># The algorithm consists in numerically calculating the derivatives</span>
        <span class="c1"># of func:</span>

        <span class="c1"># Variables on which the array depends are collected:</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
            <span class="c1"># floats, etc. might be present</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">uncert_core</span><span class="o">.</span><span class="n">AffineScalarFunc</span><span class="p">):</span>
                <span class="c1"># !!!! The following forces an evaluation of the</span>
                <span class="c1"># derivatives!? Isn&#39;t this very slow, when</span>
                <span class="c1"># working with a large number of arrays?</span>
                <span class="c1">#</span>
                <span class="c1"># !! set() is only needed for Python 2 compatibility:</span>
                <span class="n">variables</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">derivatives</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># If the matrix has no variables, then the function value can be</span>
        <span class="c1"># directly returned:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func_nominal_value</span>

        <span class="c1"># Calculation of the derivatives of each element with respect</span>
        <span class="c1"># to the variables.  Each element must be independent of the</span>
        <span class="c1"># others.  The derivatives have the same shape as the output</span>
        <span class="c1"># array (which might differ from the shape of the input array,</span>
        <span class="c1"># in the case of the pseudo-inverse).</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="p">{})(</span><span class="n">func_nominal_value</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>

            <span class="c1"># A basic assumption of this package is that the user</span>
            <span class="c1"># guarantees that uncertainties cover a zone where</span>
            <span class="c1"># evaluated functions are linear enough.  Thus, numerical</span>
            <span class="c1"># estimates of the derivative should be good over the</span>
            <span class="c1"># standard deviation interval.  This is true for the</span>
            <span class="c1"># common case of a non-zero standard deviation of var.  If</span>
            <span class="c1"># the standard deviation of var is zero, then var has no</span>
            <span class="c1"># impact on the uncertainty of the function func being</span>
            <span class="c1"># calculated: an incorrect derivative has no impact.  One</span>
            <span class="c1"># scenario can give incorrect results, however, but it</span>
            <span class="c1"># should be extremely uncommon: the user defines a</span>
            <span class="c1"># variable x with 0 standard deviation, sets y = func(x)</span>
            <span class="c1"># through this routine, changes the standard deviation of</span>
            <span class="c1"># x, and prints y; in this case, the uncertainty on y</span>
            <span class="c1"># might be incorrect, because this program had no idea of</span>
            <span class="c1"># the scale on which func() is linear, when it calculated</span>
            <span class="c1"># the numerical derivative.</span>

            <span class="c1"># The standard deviation might be numerically too small</span>
            <span class="c1"># for the evaluation of the derivative, though: we set the</span>
            <span class="c1"># minimum variable shift.</span>

            <span class="n">shift_var</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">_std_dev</span><span class="o">/</span><span class="mf">1e5</span><span class="p">,</span> <span class="mf">1e-8</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">_nominal_value</span><span class="p">))</span>
            <span class="c1"># An exceptional case is that of var being exactly zero.</span>
            <span class="c1"># In this case, an arbitrary shift is used for the</span>
            <span class="c1"># numerical calculation of the derivative.  The resulting</span>
            <span class="c1"># derivative value might be quite incorrect, but this does</span>
            <span class="c1"># not matter as long as the uncertainty of var remains 0,</span>
            <span class="c1"># since it is, in this case, a constant.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">shift_var</span><span class="p">:</span>
                <span class="n">shift_var</span> <span class="o">=</span> <span class="mf">1e-8</span>

            <span class="c1"># Shift of all the elements of arr when var changes by shift_var:</span>
            <span class="n">shift_arr</span> <span class="o">=</span> <span class="n">array_derivative</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span><span class="o">*</span><span class="n">shift_var</span>

            <span class="c1"># Origin value of array arr when var is shifted by shift_var:</span>
            <span class="n">shifted_arr_values</span> <span class="o">=</span> <span class="n">arr_nominal_value</span> <span class="o">+</span> <span class="n">shift_arr</span>
            <span class="n">func_shifted</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">shifted_arr_values</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">numerical_deriv</span> <span class="o">=</span> <span class="p">(</span><span class="n">func_shifted</span><span class="o">-</span><span class="n">func_nominal_value</span><span class="p">)</span><span class="o">/</span><span class="n">shift_var</span>

            <span class="c1"># Update of the list of variables and associated</span>
            <span class="c1"># derivatives, for each element:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">derivative_dict</span><span class="p">,</span> <span class="n">derivative_value</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">derivatives</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">numerical_deriv</span><span class="o">.</span><span class="n">flat</span><span class="p">)):</span>

                <span class="k">if</span> <span class="n">derivative_value</span><span class="p">:</span>
                    <span class="n">derivative_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">derivative_value</span>

        <span class="c1"># numbers with uncertainties are built from the result:</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">uncert_core</span><span class="o">.</span><span class="n">AffineScalarFunc</span><span class="p">)(</span>
            <span class="n">func_nominal_value</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">uncert_core</span><span class="o">.</span><span class="n">LinearCombination</span><span class="p">)(</span><span class="n">derivatives</span><span class="p">))</span>

    <span class="n">wrapped_func</span> <span class="o">=</span> <span class="n">uncert_core</span><span class="o">.</span><span class="n">set_doc</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">    Version of </span><span class="si">%s</span><span class="s2">(...) that works even when its first argument is a NumPy</span>
<span class="s2">    array that contains numbers with uncertainties.</span>

<span class="s2">    Warning: elements of the first argument array that are not</span>
<span class="s2">    AffineScalarFunc objects must not depend on uncert_core.Variable</span>
<span class="s2">    objects in any way.  Otherwise, the dependence of the result in</span>
<span class="s2">    uncert_core.Variable objects will be incorrect.</span>

<span class="s2">    Original documentation:</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))(</span><span class="n">wrapped_func</span><span class="p">)</span>

    <span class="c1"># It is easier to work with wrapped_func, which represents a</span>
    <span class="c1"># wrapped version of &#39;func&#39;, when it bears the same name as</span>
    <span class="c1"># &#39;func&#39; (the name is used by repr(wrapped_func)).</span>
    <span class="n">wrapped_func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">return</span> <span class="n">wrapped_func</span>

<span class="c1">###############################################################################</span>
<span class="c1"># Arrays</span>

<span class="k">def</span> <span class="nf">uarray</span><span class="p">(</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">std_devs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a NumPy array of numbers with uncertainties</span>
<span class="sd">    initialized with the given nominal values and standard</span>
<span class="sd">    deviations.</span>

<span class="sd">    nominal_values, std_devs -- valid arguments for numpy.array, with</span>
<span class="sd">    identical shapes (list of numbers, list of lists, numpy.ndarray,</span>
<span class="sd">    etc.).</span>

<span class="sd">    std_devs=None is only used for supporting legacy code, where</span>
<span class="sd">    nominal_values can be the tuple of nominal values and standard</span>
<span class="sd">    deviations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">std_devs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Obsolete, single tuple argument call</span>
        <span class="n">deprecation</span><span class="p">(</span><span class="s1">&#39;uarray() should now be called with two arguments.&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">std_devs</span><span class="p">)</span> <span class="o">=</span> <span class="n">nominal_values</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
        <span class="c1"># ! Looking up uncert_core.Variable beforehand through</span>
        <span class="c1"># &#39;_Variable = uncert_core.Variable&#39; does not result in a</span>
        <span class="c1"># significant speed up:</span>
        <span class="k">lambda</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">uncert_core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span>
        <span class="p">(</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">std_devs</span><span class="p">))</span>

<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">array_derivative</span><span class="p">(</span><span class="n">array_like</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the derivative of the given array with respect to the</span>
<span class="sd">    given variable.</span>

<span class="sd">    The returned derivative is a NumPy ndarray of the same shape as</span>
<span class="sd">    array_like, that contains floats.</span>

<span class="sd">    array_like -- array-like object (list, etc.)  that contains</span>
<span class="sd">    scalars or numbers with uncertainties.</span>

<span class="sd">    var -- Variable object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span>
                           <span class="c1"># The type is set because an</span>
                           <span class="c1"># integer derivative should not</span>
                           <span class="c1"># set the output type of the</span>
                           <span class="c1"># array:</span>
                           <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">])(</span><span class="n">array_like</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func_with_deriv_to_uncert_func</span><span class="p">(</span><span class="n">func_with_derivatives</span><span class="p">):</span>
    <span class="c1"># This function is used for instance for the calculation of the</span>
    <span class="c1"># inverse and pseudo-inverse of a matrix with uncertainties.</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a function that can be applied to array-like objects that</span>
<span class="sd">    contain numbers with uncertainties (lists, lists of lists, NumPy</span>
<span class="sd">    arrays, etc.).</span>

<span class="sd">    func_with_derivatives -- defines a function that takes an</span>
<span class="sd">    array-like object containing scalars and returns an array.  Both</span>
<span class="sd">    the value and the derivatives of this function with respect to</span>
<span class="sd">    multiple scalar parameters are calculated by this</span>
<span class="sd">    func_with_derivatives() argument.</span>

<span class="sd">    func_with_derivatives(arr, input_type, derivatives, *args,</span>
<span class="sd">    **kwargs) must return an iterator.  The first element returned by</span>
<span class="sd">    this iterator is the value of the function at the n-dimensional</span>
<span class="sd">    array-like &#39;arr&#39; (with the correct type).  The following elements</span>
<span class="sd">    are arrays that represent the derivative of the function for each</span>
<span class="sd">    derivative array from the iterator &#39;derivatives&#39;.</span>

<span class="sd">    func_with_derivatives() takes the following arguments:</span>

<span class="sd">      arr -- NumPy ndarray of scalars where the function must be</span>
<span class="sd">      evaluated.</span>

<span class="sd">      input_type -- data type of the input array-like object.  This</span>
<span class="sd">      type is used for determining the type that the function should</span>
<span class="sd">      return.</span>

<span class="sd">      derivatives -- iterator that returns the derivatives of the</span>
<span class="sd">      argument of the function with respect to multiple scalar</span>
<span class="sd">      variables.  func_with_derivatives() returns the derivatives of</span>
<span class="sd">      the defined function with respect to these variables.</span>

<span class="sd">      args -- additional arguments that define the result (example:</span>
<span class="sd">      for the pseudo-inverse numpy.linalg.pinv: numerical cutoff).</span>

<span class="sd">    Examples of func_with_derivatives: inv_with_derivatives().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapped_func</span><span class="p">(</span><span class="n">array_like</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        array_like -- n-dimensional array-like object that contains</span>
<span class="sd">        numbers with uncertainties (list, NumPy ndarray or matrix,</span>
<span class="sd">        etc.).</span>

<span class="sd">        args -- additional arguments that are passed directly to</span>
<span class="sd">        func_with_derivatives.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The calculation below is not lazy, contrary to the linear</span>
        <span class="c1"># error propagation done in AffineScalarFunc. Making it lazy</span>
        <span class="c1"># in the same way would be quite a specific task: basically</span>
        <span class="c1"># this would amount to generalizing scalar coefficients in</span>
        <span class="c1"># core.LinearCombination to more general matrix</span>
        <span class="c1"># multiplications, and to replace Variable differentials by</span>
        <span class="c1"># full matrices of coefficients. This does not look very</span>
        <span class="c1"># efficient, as matrices are quite big, and since caching the</span>
        <span class="c1"># result of a few matrix functions that are not typically</span>
        <span class="c1"># stringed one after the other (unlike a big sum of numbers)</span>
        <span class="c1"># should not be needed.</span>

        <span class="c1"># So that .flat works even if array_like is a list:</span>
        <span class="n">array_version</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array_like</span><span class="p">)</span>

        <span class="c1"># Variables on which the array depends are collected:</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">array_version</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
            <span class="c1"># floats, etc. might be present</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">uncert_core</span><span class="o">.</span><span class="n">AffineScalarFunc</span><span class="p">):</span>
                <span class="c1"># !!! set() is only needed for Python 2 compatibility:</span>
                <span class="n">variables</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">derivatives</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">array_nominal</span> <span class="o">=</span> <span class="n">nominal_values</span><span class="p">(</span><span class="n">array_version</span><span class="p">)</span>
        <span class="c1"># Function value, then derivatives at array_nominal (the</span>
        <span class="c1"># derivatives are with respect to the variables contained in</span>
        <span class="c1"># array_like):</span>
        <span class="n">func_then_derivs</span> <span class="o">=</span> <span class="n">func_with_derivatives</span><span class="p">(</span>
            <span class="n">array_nominal</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">array_like</span><span class="p">),</span>
            <span class="p">(</span><span class="n">array_derivative</span><span class="p">(</span><span class="n">array_version</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">func_nominal_value</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">func_then_derivs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func_nominal_value</span>

        <span class="c1"># The result is built progressively, with the contribution of</span>
        <span class="c1"># each variable added in turn:</span>

        <span class="c1"># Calculation of the derivatives of the result with respect to</span>
        <span class="c1"># the variables.</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">func_nominal_value</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">func_nominal_value</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="c1"># Memory-efficient approach.  A memory-hungry approach would</span>
        <span class="c1"># be to calculate the matrix derivatives will respect to all</span>
        <span class="c1"># variables and then combine them into a matrix of</span>
        <span class="c1"># AffineScalarFunc objects.  The approach followed here is to</span>
        <span class="c1"># progressively build the matrix of derivatives, by</span>
        <span class="c1"># progressively adding the derivatives with respect to</span>
        <span class="c1"># successive variables.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">deriv_wrt_var</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span>
                                                   <span class="n">func_then_derivs</span><span class="p">):</span>

            <span class="c1"># Update of the list of variables and associated</span>
            <span class="c1"># derivatives, for each element:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">derivative_dict</span><span class="p">,</span> <span class="n">derivative_value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">derivatives</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">deriv_wrt_var</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">derivative_value</span><span class="p">:</span>
                    <span class="n">derivative_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">derivative_value</span>

        <span class="c1"># An array of numbers with uncertainties is built from the</span>
        <span class="c1"># result:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">uncert_core</span><span class="o">.</span><span class="n">AffineScalarFunc</span><span class="p">)(</span>
            <span class="n">func_nominal_value</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">uncert_core</span><span class="o">.</span><span class="n">LinearCombination</span><span class="p">)(</span><span class="n">derivatives</span><span class="p">))</span>

        <span class="c1"># NumPy matrices that contain numbers with uncertainties are</span>
        <span class="c1"># better as unumpy matrices:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapped_func</span>

<span class="c1">########## Matrix inverse</span>

<span class="k">def</span> <span class="nf">inv_with_derivatives</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">input_type</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the matrix inverse and its derivatives.</span>

<span class="sd">    See the definition of func_with_deriv_to_uncert_func() for its</span>
<span class="sd">    detailed semantics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inverse</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># The inverse of a numpy.matrix is a numpy.matrix.  It is assumed</span>
    <span class="c1"># that numpy.linalg.inv is such that other types yield</span>
    <span class="c1"># numpy.ndarrays:</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">input_type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">inverse</span>

    <span class="c1"># It is mathematically convenient to work with matrices:</span>
    <span class="n">inverse_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">inverse</span><span class="p">)</span>

    <span class="c1"># Successive derivatives of the inverse:</span>
    <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">:</span>
        <span class="n">derivative_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">derivative</span><span class="p">)</span>
        <span class="k">yield</span> <span class="o">-</span><span class="n">inverse_mat</span> <span class="o">*</span> <span class="n">derivative_mat</span> <span class="o">*</span> <span class="n">inverse_mat</span>

<span class="n">inv</span> <span class="o">=</span> <span class="n">func_with_deriv_to_uncert_func</span><span class="p">(</span><span class="n">inv_with_derivatives</span><span class="p">)</span>
<span class="n">inv</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">    Version of numpy.linalg.inv that works with array-like objects</span>
<span class="s2">    that contain numbers with uncertainties.</span>

<span class="s2">    The result is a unumpy.matrix if numpy.linalg.pinv would return a</span>
<span class="s2">    matrix for the array of nominal values.</span>

<span class="s2">    Analytical formulas are used.</span>

<span class="s2">    Original documentation:</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="o">.</span><span class="vm">__doc__</span>

<span class="c1">########## Matrix pseudo-inverse</span>

<span class="k">def</span> <span class="nf">pinv_with_derivatives</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">input_type</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">,</span> <span class="n">rcond</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the matrix pseudo-inverse and its derivatives.</span>

<span class="sd">    Works with real or complex matrices.</span>

<span class="sd">    See the definition of func_with_deriv_to_uncert_func() for its</span>
<span class="sd">    detailed semantics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inverse</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">rcond</span><span class="p">)</span>
    <span class="c1"># The pseudo-inverse of a numpy.matrix is a numpy.matrix.  It is</span>
    <span class="c1"># assumed that numpy.linalg.pinv is such that other types yield</span>
    <span class="c1"># numpy.ndarrays:</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">input_type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">inverse</span>

    <span class="c1"># It is mathematically convenient to work with matrices:</span>
    <span class="n">inverse_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">inverse</span><span class="p">)</span>

    <span class="c1"># Formula (4.12) from The Differentiation of Pseudo-Inverses and</span>
    <span class="c1"># Nonlinear Least Squares Problems Whose Variables</span>
    <span class="c1"># Separate. Author(s): G. H. Golub and V. Pereyra. Source: SIAM</span>
    <span class="c1"># Journal on Numerical Analysis, Vol. 10, No. 2 (Apr., 1973),</span>
    <span class="c1"># pp. 413-432</span>

    <span class="c1"># See also</span>
    <span class="c1"># http://mathoverflow.net/questions/25778/analytical-formula-for-numerical-derivative-of-the-matrix-pseudo-inverse</span>

    <span class="c1"># Shortcuts.  All the following factors should be numpy.matrix objects:</span>
    <span class="n">PA</span> <span class="o">=</span> <span class="n">arr</span><span class="o">*</span><span class="n">inverse_mat</span>
    <span class="n">AP</span> <span class="o">=</span> <span class="n">inverse_mat</span><span class="o">*</span><span class="n">arr</span>
    <span class="n">factor21</span> <span class="o">=</span> <span class="n">inverse_mat</span><span class="o">*</span><span class="n">inverse_mat</span><span class="o">.</span><span class="n">H</span>
    <span class="n">factor22</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">PA</span>
    <span class="n">factor31</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">AP</span>
    <span class="n">factor32</span> <span class="o">=</span> <span class="n">inverse_mat</span><span class="o">.</span><span class="n">H</span><span class="o">*</span><span class="n">inverse_mat</span>

    <span class="c1"># Successive derivatives of the inverse:</span>
    <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">:</span>
        <span class="n">derivative_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">derivative</span><span class="p">)</span>
        <span class="n">term1</span> <span class="o">=</span> <span class="o">-</span><span class="n">inverse_mat</span><span class="o">*</span><span class="n">derivative_mat</span><span class="o">*</span><span class="n">inverse_mat</span>
        <span class="n">derivative_mat_H</span> <span class="o">=</span> <span class="n">derivative_mat</span><span class="o">.</span><span class="n">H</span>
        <span class="n">term2</span> <span class="o">=</span> <span class="n">factor21</span><span class="o">*</span><span class="n">derivative_mat_H</span><span class="o">*</span><span class="n">factor22</span>
        <span class="n">term3</span> <span class="o">=</span> <span class="n">factor31</span><span class="o">*</span><span class="n">derivative_mat_H</span><span class="o">*</span><span class="n">factor32</span>
        <span class="k">yield</span> <span class="n">term1</span><span class="o">+</span><span class="n">term2</span><span class="o">+</span><span class="n">term3</span>

<span class="c1"># Default rcond argument for the generalization of numpy.linalg.pinv:</span>
<span class="c1">#</span>
<span class="c1"># Most common modern case first:</span>
<span class="k">try</span><span class="p">:</span> 
    <span class="n">pinv_default</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;rcond&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># No inspect.signature() before Python 3.3</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># In numpy 1.17+, pinv is wrapped using a decorator which unfortunately</span>
        <span class="c1"># results in the metadata (argument defaults) being lost. However, we</span>
        <span class="c1"># can still get at the original function using the __wrapped__</span>
        <span class="c1"># attribute (which is what inspect.signature() does).</span>
        <span class="n">pinv_default</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="o">.</span><span class="n">__wrapped__</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># Function not wrapped in NumPy &lt; 1.17</span>
        <span class="n">pinv_default</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Python 1, 2.6+:</span>

<span class="n">pinv_with_uncert</span> <span class="o">=</span> <span class="n">func_with_deriv_to_uncert_func</span><span class="p">(</span><span class="n">pinv_with_derivatives</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span><span class="n">array_like</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">pinv_default</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pinv_with_uncert</span><span class="p">(</span><span class="n">array_like</span><span class="p">,</span> <span class="n">rcond</span><span class="p">)</span>

<span class="n">pinv</span> <span class="o">=</span> <span class="n">uncert_core</span><span class="o">.</span><span class="n">set_doc</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Version of numpy.linalg.pinv that works with array-like objects</span>
<span class="s2">    that contain numbers with uncertainties.</span>

<span class="s2">    The result is a unumpy.matrix if numpy.linalg.pinv would return a</span>
<span class="s2">    matrix for the array of nominal values.</span>

<span class="s2">    Analytical formulas are used.</span>

<span class="s2">    Original documentation:</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)(</span><span class="n">pinv</span><span class="p">)</span>

<span class="c1">########## Matrix class</span>

<span class="k">class</span> <span class="nc">CallableStdDevs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Class for standard deviation results, which used to be</span>
<span class="sd">    callable. Provided for compatibility with old code. Issues an</span>
<span class="sd">    obsolescence warning upon call.</span>

<span class="sd">    New objects must be created by passing an existing</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="c1"># The following prevents a copy of the original matrix, which</span>
        <span class="c1"># could be expensive, and is unnecessary (the CallableStdDevs</span>
        <span class="c1"># is just a wrapping around the original matrix, which can be</span>
        <span class="c1"># modified):</span>
        <span class="n">matrix</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">return</span> <span class="n">matrix</span>

    <span class="k">def</span> <span class="fm">__call__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">deprecation</span><span class="p">(</span><span class="s1">&#39;the std_devs attribute should not be called&#39;</span>
                    <span class="s1">&#39; anymore: use .std_devs instead of .std_devs().&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">matrix</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
    <span class="c1"># The name of this class is the same as NumPy&#39;s, which is why it</span>
    <span class="c1"># does not follow PEP 8.</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class equivalent to numpy.matrix, but that behaves better when the</span>
<span class="sd">    matrix contains numbers with uncertainties.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># ! NumPy&#39;s matrix __rmul__ uses an apparently restrictive</span>
        <span class="c1"># dot() function that cannot handle the multiplication of a</span>
        <span class="c1"># scalar and of a matrix containing objects (when the</span>
        <span class="c1"># arguments are given in this order).  We go around this</span>
        <span class="c1"># limitation:</span>
        <span class="k">if</span> <span class="n">numeric</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">numeric</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numeric</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>  <span class="c1"># The order is important</span>

    <span class="k">def</span> <span class="nf">getI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Matrix inverse or pseudo-inverse.&quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">inv</span> <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span> <span class="k">else</span> <span class="n">pinv</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">I</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">getter</span><span class="p">(</span><span class="n">getI</span><span class="p">)</span>


    <span class="c1"># !!! The following function is not in the official documentation</span>
    <span class="c1"># of the module. Maybe this is because arrays with uncertainties</span>
    <span class="c1"># do not have any equivalent in this module, and they should be</span>
    <span class="c1"># the first ones to have such methods?</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nominal value of all the elements of the matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># !!! The following function is not in the official documentation</span>
    <span class="c1"># of the module. Maybe this is because arrays with uncertainties</span>
    <span class="c1"># do not have any equivalent in this module, and they should be</span>
    <span class="c1"># the first ones to have such methods?</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">std_devs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CallableStdDevs</span><span class="p">(</span><span class="n">std_devs</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">umatrix</span><span class="p">(</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">std_devs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a matrix that contains numbers with uncertainties.</span>

<span class="sd">    The arguments are the same as for uarray(...): nominal values, and</span>
<span class="sd">    standard deviations.</span>

<span class="sd">    The returned matrix can be inverted, thanks to the fact that it is</span>
<span class="sd">    a unumpy.matrix object instead of a numpy.matrix one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">std_devs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Obsolete, single tuple argument call</span>
        <span class="n">deprecation</span><span class="p">(</span><span class="s1">&#39;umatrix() should now be called with two arguments.&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">std_devs</span><span class="p">)</span> <span class="o">=</span> <span class="n">nominal_values</span>

    <span class="k">return</span> <span class="n">uarray</span><span class="p">(</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">std_devs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">define_vectorized_funcs</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines vectorized versions of functions from uncertainties.umath_core.</span>

<span class="sd">    Some functions have their name translated, so as to follow NumPy&#39;s</span>
<span class="sd">    convention (example: math.acos -&gt; numpy.arccos).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">this_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>
    <span class="c1"># NumPy does not always use the same function names as the math</span>
    <span class="c1"># module:</span>
    <span class="n">func_name_translations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
        <span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="s1">&#39;arc&#39;</span><span class="o">+</span><span class="n">f_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;acos&#39;</span><span class="p">,</span> <span class="s1">&#39;acosh&#39;</span><span class="p">,</span> <span class="s1">&#39;asin&#39;</span><span class="p">,</span> <span class="s1">&#39;atan&#39;</span><span class="p">,</span> <span class="s1">&#39;atan2&#39;</span><span class="p">,</span> <span class="s1">&#39;atanh&#39;</span><span class="p">]])</span>

    <span class="n">new_func_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">func_name_translations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)</span>
        <span class="c1"># The functions from umath_core.non_std_wrapped_funcs</span>
        <span class="c1"># (available from umath) are normally not in</span>
        <span class="c1"># NumPy, so they are not included here:</span>
        <span class="k">for</span> <span class="n">function_name</span> <span class="ow">in</span> <span class="n">umath_core</span><span class="o">.</span><span class="n">many_scalars_to_scalar_funcs</span><span class="p">]</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">unumpy_name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">umath_core</span><span class="o">.</span><span class="n">many_scalars_to_scalar_funcs</span><span class="p">,</span> <span class="n">new_func_names</span><span class="p">):</span>

        <span class="c1"># ! The newly defined functions (uncertainties.unumpy.cos, etc.)</span>
        <span class="c1"># do not behave exactly like their NumPy equivalent (numpy.cos,</span>
        <span class="c1"># etc.): cos(0) gives an array() and not a</span>
        <span class="c1"># numpy.float... (equality tests succeed, though).</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">umath_core</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)</span>

        <span class="c1"># Data type of the result of the unumpy function:</span>
        <span class="n">otypes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="c1"># It is much more convenient to preserve the type of</span>
            <span class="c1"># functions that return a number without</span>
            <span class="c1"># uncertainty. Thus, for example, unumpy.isnan() can</span>
            <span class="c1"># return an array with a boolean data type (instead of</span>
            <span class="c1"># object), which allows the result to be used with NumPy&#39;s</span>
            <span class="c1"># boolean indexing.</span>
            <span class="p">{}</span> <span class="k">if</span> <span class="n">function_name</span> <span class="ow">in</span> <span class="n">umath_core</span><span class="o">.</span><span class="n">locally_cst_funcs</span>
            <span class="c1"># If by any chance a function returns, in a particular</span>
            <span class="c1"># case, an integer instead of a number with uncertainty,</span>
            <span class="c1"># side-effects in vectorize() would fix the resulting</span>
            <span class="c1"># dtype to integer, which is not what is wanted (as</span>
            <span class="c1"># vectorize(), at least in NumPy around 2010 maybe,</span>
            <span class="c1"># decided about the output data type by looking at the</span>
            <span class="c1"># type of first element only).</span>
            <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;otypes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">object</span><span class="p">]})</span>

        <span class="nb">setattr</span><span class="p">(</span>
            <span class="n">this_module</span><span class="p">,</span> <span class="n">unumpy_name</span><span class="p">,</span>
            <span class="c1">#!!!! For umath_core.locally_cst_funcs, would it make sense</span>
            <span class="c1"># to optimize this by using instead the equivalent (? see</span>
            <span class="c1"># above) vectorized NumPy function on the nominal values?</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Vectorized version of umath.</span><span class="si">%s</span><span class="s2">.</span>

<span class="s2">Original documentation:</span>
<span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">),</span>
                            <span class="o">**</span><span class="n">otypes</span><span class="p">))</span>


        <span class="n">__all__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unumpy_name</span><span class="p">)</span>

<span class="n">define_vectorized_funcs</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">smpl</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../example/index.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.debug.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.debug</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.doc.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.doc</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.functions.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.functions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.parallel.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.parallel</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.plot.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.plot</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.stat.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.stat</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/smpl.util.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smpl.util</span></code></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, APN-Pucky.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>